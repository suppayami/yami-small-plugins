{"version":3,"sources":["webpack:///YSP_Spine.js","webpack:///webpack/bootstrap 4022c9eee673183a739e","webpack:///./node_modules/core-js/library/modules/_global.js","webpack:///./node_modules/core-js/library/modules/_wks.js","webpack:///./node_modules/core-js/library/modules/_core.js","webpack:///./node_modules/core-js/library/modules/_descriptors.js","webpack:///./node_modules/core-js/library/modules/_hide.js","webpack:///./node_modules/core-js/library/modules/_an-object.js","webpack:///./node_modules/core-js/library/modules/_is-object.js","webpack:///./node_modules/core-js/library/modules/_to-iobject.js","webpack:///./node_modules/core-js/library/modules/_has.js","webpack:///./node_modules/core-js/library/modules/_iterators.js","webpack:///./node_modules/core-js/library/modules/_export.js","webpack:///./node_modules/core-js/library/modules/_object-dp.js","webpack:///./node_modules/core-js/library/modules/_to-integer.js","webpack:///./node_modules/core-js/library/modules/_cof.js","webpack:///./node_modules/core-js/library/modules/_defined.js","webpack:///./node_modules/core-js/library/modules/_ctx.js","webpack:///./node_modules/core-js/library/modules/_fails.js","webpack:///./node_modules/core-js/library/modules/_shared-key.js","webpack:///./node_modules/core-js/library/modules/_dom-create.js","webpack:///./node_modules/core-js/library/modules/_property-desc.js","webpack:///./node_modules/core-js/library/modules/_a-function.js","webpack:///./node_modules/core-js/library/modules/_shared.js","webpack:///./node_modules/core-js/library/modules/_uid.js","webpack:///./node_modules/core-js/library/modules/_enum-bug-keys.js","webpack:///./node_modules/core-js/library/modules/_iobject.js","webpack:///./node_modules/core-js/library/modules/_ie8-dom-define.js","webpack:///./node_modules/core-js/library/modules/_to-primitive.js","webpack:///./node_modules/core-js/library/modules/_object-keys.js","webpack:///./node_modules/core-js/library/modules/_to-length.js","webpack:///./node_modules/core-js/library/modules/_set-to-string-tag.js","webpack:///./node_modules/core-js/library/modules/_iter-define.js","webpack:///./node_modules/core-js/library/modules/_object-keys-internal.js","webpack:///./node_modules/core-js/library/modules/_array-includes.js","webpack:///./node_modules/core-js/library/modules/_to-index.js","webpack:///./node_modules/core-js/library/modules/_library.js","webpack:///./node_modules/core-js/library/modules/_object-create.js","webpack:///./node_modules/core-js/library/modules/_html.js","webpack:///./node_modules/core-js/library/modules/_to-object.js","webpack:///./node_modules/core-js/library/modules/_classof.js","webpack:///./node_modules/core-js/library/modules/_object-pie.js","webpack:///./node_modules/core-js/library/modules/web.dom.iterable.js","webpack:///./node_modules/core-js/library/modules/es6.array.iterator.js","webpack:///./node_modules/core-js/library/modules/_add-to-unscopables.js","webpack:///./node_modules/core-js/library/modules/_iter-step.js","webpack:///./node_modules/core-js/library/modules/_redefine.js","webpack:///./node_modules/core-js/library/modules/_iter-create.js","webpack:///./node_modules/core-js/library/modules/_object-dps.js","webpack:///./node_modules/core-js/library/modules/_object-gpo.js","webpack:///./node_modules/core-js/library/modules/es6.string.iterator.js","webpack:///./node_modules/core-js/library/modules/_string-at.js","webpack:///./node_modules/core-js/library/modules/core.get-iterator-method.js","webpack:///./src/Spine/loader.js","webpack:///./node_modules/core-js/library/modules/_task.js","webpack:///./src/Spine/index.js","webpack:///./node_modules/babel-runtime/core-js/object/assign.js","webpack:///./node_modules/core-js/library/fn/object/assign.js","webpack:///./node_modules/core-js/library/modules/es6.object.assign.js","webpack:///./node_modules/core-js/library/modules/_object-assign.js","webpack:///./node_modules/core-js/library/modules/_object-gops.js","webpack:///../compilation.ts","webpack:///./node_modules/babel-runtime/core-js/math/fround.js","webpack:///./node_modules/core-js/library/fn/math/fround.js","webpack:///./node_modules/core-js/library/modules/es6.math.fround.js","webpack:///./node_modules/core-js/library/modules/_math-sign.js","webpack:///./node_modules/babel-runtime/core-js/object/create.js","webpack:///./node_modules/core-js/library/fn/object/create.js","webpack:///./node_modules/core-js/library/modules/es6.object.create.js","webpack:///./node_modules/babel-runtime/core-js/object/set-prototype-of.js","webpack:///./node_modules/core-js/library/fn/object/set-prototype-of.js","webpack:///./node_modules/core-js/library/modules/es6.object.set-prototype-of.js","webpack:///./node_modules/core-js/library/modules/_set-proto.js","webpack:///./node_modules/core-js/library/modules/_object-gopd.js","webpack:///./src/Spine/spine.js","webpack:///./node_modules/babel-runtime/core-js/promise.js","webpack:///./node_modules/core-js/library/fn/promise.js","webpack:///./node_modules/core-js/library/modules/es6.promise.js","webpack:///./node_modules/core-js/library/modules/_an-instance.js","webpack:///./node_modules/core-js/library/modules/_for-of.js","webpack:///./node_modules/core-js/library/modules/_iter-call.js","webpack:///./node_modules/core-js/library/modules/_is-array-iter.js","webpack:///./node_modules/core-js/library/modules/_species-constructor.js","webpack:///./node_modules/core-js/library/modules/_invoke.js","webpack:///./node_modules/core-js/library/modules/_microtask.js","webpack:///./node_modules/core-js/library/modules/_redefine-all.js","webpack:///./node_modules/core-js/library/modules/_set-species.js","webpack:///./node_modules/core-js/library/modules/_iter-detect.js","webpack:///./src/Spine/scene-base.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","window","Math","self","Function","__g","store","uid","Symbol","USE_SYMBOL","core","version","__e","a","dP","createDesc","key","value","f","isObject","it","TypeError","IObject","defined","ctx","hide","$export","type","source","own","out","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","P","IS_BIND","B","IS_WRAP","W","expProto","target","undefined","C","b","this","arguments","length","apply","virtual","R","U","anObject","IE8_DOM_DEFINE","toPrimitive","O","Attributes","e","ceil","floor","isNaN","toString","slice","aFunction","fn","that","exec","shared","document","is","createElement","bitmap","writable","id","px","random","concat","split","cof","propertyIsEnumerable","val","valueOf","$keys","enumBugKeys","keys","toInteger","min","def","has","TAG","tag","stat","LIBRARY","redefine","Iterators","$iterCreate","setToStringTag","getPrototypeOf","ITERATOR","BUGGY","returnThis","Base","NAME","Constructor","next","DEFAULT","IS_SET","FORCED","methods","IteratorPrototype","getMethod","kind","proto","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","entries","values","toIObject","arrayIndexOf","IE_PROTO","names","result","push","toLength","toIndex","IS_INCLUDES","$this","el","fromIndex","index","max","dPs","Empty","createDict","iframeDocument","iframe","style","display","appendChild","src","contentWindow","open","write","lt","close","create","Properties","documentElement","ARG","tryGet","T","callee","TO_STRING_TAG","collections","Collection","Array","addToUnscopables","step","iterated","_t","_i","_k","Arguments","done","descriptor","getKeys","defineProperties","toObject","ObjectProto","constructor","$at","String","point","TO_STRING","pos","charCodeAt","charAt","classof","getIteratorMethod","_promise","_promise2","obj","default","raws","spines","filesToLoad","_loadRaw","path","resolve","reject","xhr","XMLHttpRequest","onload","responseText","onerror","statusText","send","_loadTexture","texture","PIXI","BaseTexture","fromImage","on","baseTexture","loadAssets","spineName","setup","ysp","Spine","SETUP","json","then","res","JSON","parse","catch","console","log","atlas","loadSkeleton","rawSkeletonData","rawAtlasData","spineAtlas","spine","TextureAtlas","line","callback","spineAtlasLoader","AtlasAttachmentLoader","spineJsonParser","SkeletonJson","spineData","readSkeletonData","isLoaded","defer","channel","port","invoke","html","cel","process","setTask","setImmediate","clearTask","clearImmediate","MessageChannel","counter","queue","run","listener","event","data","args","nextTick","port2","port1","onmessage","postMessage","addEventListener","importScripts","removeChild","setTimeout","set","clear","_interopRequireDefault","_assign","_assign2","_spine","_spine2","_loader","_loader2","_sceneBase","_sceneBase2","Scene_Base","loader","assign","gOPS","pIE","$assign","A","K","forEach","k","join","aLen","getSymbols","isEnum","j","getOwnPropertySymbols","pixi_spine","_fround","_fround2","_create","_create2","_setPrototypeOf","_setPrototypeOf2","__extends","extendStatics","__proto__","__","Animation","timelines","duration","Error","skeleton","lastTime","time","loop","events","alpha","pose","direction","binarySearch","low","high","current","linearSearch","last","MixPose","MixDirection","TimelineType","CurveTimeline","frameCount","curves","Utils","newFloatArray","BEZIER_SIZE","getFrameCount","setLinear","frameIndex","LINEAR","setStepped","STEPPED","getCurveType","BEZIER","setCurve","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","x","y","getCurvePercent","percent","MathUtils","clamp","start","prevX","prevY","RotateTimeline","_super","_this","frames","getPropertyId","rotate","boneIndex","setFrame","degrees","ROTATION","bone","bones","rotation","r_1","ENTRIES","PREV_ROTATION","r_2","frame","prevRotation","frameTime","PREV_TIME","r","TranslateTimeline","translate","X","Y","PREV_X","PREV_Y","ScaleTimeline","scale","scaleX","scaleY","bx","by","abs","signum","ShearTimeline","shear","shearX","shearY","ColorTimeline","color","slotIndex","g","slot","slots","setFromColor","add","PREV_R","PREV_G","PREV_B","PREV_A","TwoColorTimeline","twoColor","r2","g2","b2","R2","G2","B2","darkColor","light","dark","setupLight","setupDark","PREV_R2","PREV_G2","PREV_B2","AttachmentTimeline","attachmentNames","attachment","attachmentName","attachmentName_1","setAttachment","getAttachment","attachmentName_2","zeros","DeformTimeline","frameVertices","deform","vertices","firedEvents","slotAttachment","VertexAttachment","applyDeform","verticesArray","attachmentVertices","vertexCount","setArraySize","vertexAttachment","zeroVertices","arrayCopy","setupVertices","i_1","lastVertices","i_2","i_3","i_4","prevVertices","nextVertices","i_5","prev","i_6","i_7","i_8","EventTimeline","Number","MAX_VALUE","DrawOrderTimeline","drawOrders","drawOrder","drawOrderToSetupIndex","IkConstraintTimeline","ikConstraint","ikConstraintIndex","mix","bendDirection","MIX","BEND_DIRECTION","constraint","ikConstraints","PREV_MIX","PREV_BEND_DIRECTION","in","TransformConstraintTimeline","transformConstraint","transformConstraintIndex","rotateMix","translateMix","scaleMix","shearMix","ROTATE","TRANSLATE","SCALE","SHEAR","transformConstraints","PREV_ROTATE","PREV_TRANSLATE","PREV_SCALE","PREV_SHEAR","PathConstraintPositionTimeline","pathConstraintPosition","pathConstraintIndex","VALUE","pathConstraints","position","PREV_VALUE","PathConstraintSpacingTimeline","pathConstraintSpacing","spacing","PathConstraintMixTimeline","pathConstraintMix","AnimationState","tracks","listeners","EventQueue","propertyIDs","IntSet","mixingTo","animationsChanged","timeScale","trackEntryPool","Pool","TrackEntry","update","delta","animationLast","nextAnimationLast","trackLast","nextTrackLast","currentDelta","delay","nextTime","trackTime","setCurrent","mixingFrom","mixTime","trackEnd","end","disposeNext","updateMixingFrom","from","drain","to","finished","mixDuration","totalAlpha","interruptAlpha","_animationsChanged","applied","currentPose","currentLayered","applyMixingFrom","animationTime","getAnimationTime","timelineCount","animation","ii","timelineData","firstFrame","timelinesRotation","timeline","FIRST","applyRotateTimeline","queueEvents","eventThreshold","attachments","attachmentThreshold","drawOrderThreshold","timelineDipMix","alphaDip","alphaMix","SUBSEQUENT","DIP","dipMix","rotateTimeline","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","event_1","complete","clearTracks","oldDrainDisabled","drainDisabled","clearTrack","trackIndex","interrupt","expandToIndex","setAnimation","animationName","skeletonData","findAnimation","setAnimationWith","trackEntry","addAnimation","addAnimationWith","getMix","setEmptyAnimation","emptyAnimation","addEmptyAnimation","setEmptyAnimations","ensureArrayCapacity","obtain","dispose","setTimelineData","getCurrent","addListener","removeListener","indexOf","splice","clearListeners","clearListenerNotifications","setAnimationByName","deprecatedWarning1","warn","addAnimationByName","deprecatedWarning2","hasAnimation","hasAnimationByName","deprecatedWarning3","DIP_MIX","reset","mixingToArray","lastEntry","pop","mixingToLast","timelinesCount","outer","hasTimeline","setAnimationLast","isComplete","resetRotationDirections","loopsCount","animState","objects","EventType","deprecateStuff","onStart","onEnd","free","count","toInt","onComplete","event_3","onEvent","AnimationStateAdapter2","AnimationStateData","animationToMixTime","defaultMix","setMix","fromName","toName","setMixWith","setMixByName","newRegionAttachment","skin","region","findRegion","RegionAttachment","newMeshAttachment","MeshAttachment","newBoundingBoxAttachment","BoundingBoxAttachment","newPathAttachment","PathAttachment","newPointAttachment","PointAttachment","newClippingAttachment","ClippingAttachment","Attachment","nextID","worldVerticesLength","computeWorldVerticesOld","worldVertices","computeWorldVertices","offset","stride","deformArray","v","skip","skeletonBones","w","wx","wy","mat","matrix","vx","vy","weight","tx","ty","v_1","sourceAttachment","AttachmentType","Color","inheritDeform","tempColor","updateUVs","uvs","regionUVs","_uvs","w1","width","h1","height","w2","originalWidth","h2","originalHeight","offsetX","pixiOffsetY","u","x0","x1","x3","x2","y0","y1","y3","y2","parentMesh","getParentMesh","setParentMesh","triangles","hullLength","closed","constantSpeed","computeWorldPosition","worldX","worldY","computeWorldRotation","cos","cosDeg","sin","sinDeg","atan2","radDeg","updateOffset","regionScaleX","regionScaleY","localX","localY","offsetY","localX2","localY2","radians","PI","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","OX1","OY1","OX2","OY2","OX3","OY3","OX4","OY4","setRegion","v2","u2","vertexOffset","X1","Y1","C1R","C1G","C1B","C1A","U1","V1","X2","Y2","C2R","C2G","C2B","C2A","U2","V2","X3","Y3","C3R","C3G","C3B","C3A","U3","V3","X4","Y4","C4R","C4G","C4B","C4A","U4","V4","BlendMode","Bone","parent","Matrix","children","ax","ay","arotation","ascaleX","ascaleY","ashearX","ashearY","appliedValid","sorted","setToSetupPose","updateWorldTransformWith","updateWorldTransform","rotationY","la","lb","lc","ld","flipX","flipY","yDown","pa","pb","pc","pd","transformMode","TransformMode","Normal","OnlyTranslation","NoRotationOrReflection","prx","rx","ry","NoScale","NoScaleOrReflection","za","zc","sqrt","zb","zd","getWorldRotationX","getWorldRotationY","getWorldScaleX","getWorldScaleY","updateAppliedTransform","pm","pid","dx","dy","ia","ib","ic","ra","rb","rc","rd","det","worldToLocal","world","invDet","localToWorld","local","worldToLocalRotation","worldRotation","localToWorldRotation","localRotation","rotateWorld","BoneData","Event","EventData","IkConstraint","findBone","getOrder","order","apply1","apply2","targetX","targetY","rotationIK","child","bendDir","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","pp","l1","l2","a1","a2","acos","aa","bb","dd","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraintData","PathConstraint","spaces","positions","lengths","segments","findSlot","spacingMode","lengthSpacing","SpacingMode","Length","rotateMode","tangents","RotateMode","Tangent","ChainScale","boneCount","spacesCount","setupLength","length_1","computeWorldPositions","positionMode","PositionMode","Percent","boneX","boneY","offsetRotation","tip","Chain","degRad","length_2","length_3","PI2","percentPosition","percentSpacing","verticesLength","curveCount","prevCurve","NONE","pathLength_1","curve","space","BEFORE","addBeforePosition","AFTER","addAfterPosition","length_4","addCurvePosition","pathLength","curveLength","segment","length_5","length_6","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraintData","Skeleton","_updateCache","updateCacheReset","boneData","parent_1","slotData","Slot","ikConstraintData","transformConstraintData","TransformConstraint","pathConstraintData","updateCache","ikCount","transformCount","pathCount","constraintCount","sortIkConstraint","sortTransformConstraint","sortPathConstraint","sortBone","constrained","sortReset","slotBone","sortPathConstraintAttachment","defaultSkin","skins","sortPathConstraintAttachmentWith","pathBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","name_1","getAttachmentByName","findIkConstraint","constraintName","findTransformConstraint","findPathConstraint","getBounds","size","POSITIVE_INFINITY","NEGATIVE_INFINITY","mesh","nn","SkeletonBounds","boundingBoxes","polygons","polygonPool","updateAabb","slotCount","freeAll","boundingBox","polygon","aabbCompute","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","SkeletonClipping","triangulator","Triangulator","clippingPolygon","clipOutput","clippedVertices","clippedTriangles","scratch","clipStart","clip","clipAttachment","makeClockwise","clippingPolygons","decompose","triangulate","n_1","clipEndWithSlot","endSlot","clipEnd","isClipping","clipTriangles","trianglesLength","polygonsCount","vertexSize","u1","v1","u3","v3","clippedVerticesItems","clippedTrianglesItems","clipOutputLength","d0","d1","d2","d4","clipOutputCount","clipOutputItems","c0","clippingArea","output","originalOutput","clipped","input","clippingVertices","clippingVerticesLast","edgeX","edgeY","edgeX2","edgeY2","deltaX","deltaY","inputVertices","inputVerticesLength","outputStart","inputX","inputY","inputX2","inputY2","side2","ua","verticeslength","area","p1x","p1y","p2x","p2y","lastX","other","SkeletonData","animations","fps","findEvent","eventDataName","event_4","findPathConstraintIndex","pathConstraintName","attachmentLoader","linkedMeshes","root","skeletonMap","hash","imagesPath","images","boneMap","parent_2","parentName","getValue","transformModeFromString","slotMap","SlotData","setFromString","blendMode","blendModeFromString","ik","constraintMap","targetName","transform","TransformConstraintData","relative","offsetScaleX","offsetScaleY","offsetShearY","positionModeFromString","spacingModeFromString","rotateModeFromString","Fixed","skinMap","Skin","entryName","readAttachment","addAttachment","linkedMesh","parent_3","eventName","eventMap","intValue","floatValue","stringValue","animationMap","readAnimation","map","box","readVertices","parent_4","LinkedMesh","newArray","scaledVertices","toFloatArray","weights","timelineName","timelineMap","valueMap","readCurve","angle","timelineScale","paths","deformName","deformMap","weighted","deformLength","verticesValue","drawOrderNode","draworder","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","eventData","event_5","toSinglePrecision","prop","defaultValue","str","toLowerCase","Additive","Multiply","Screen","dictionary","oldSkin","attachmentTime","setAttachmentTime","getAttachmentTime","Texture","image","_image","getImage","filterFromString","text","TextureFilter","Nearest","Linear","MipMap","MipMapNearestNearest","MipMapLinearNearest","MipMapNearestLinear","MipMapLinearLinear","wrapFromString","TextureWrap","MirroredRepeat","ClampToEdge","Repeat","TextureRegion","tex","VERSION","crop","trim","orig","spineOffsetY","atlasText","textureLoader","pages","regions","addSpineAtlas","addTexture","page","TextureAtlasPage","realWidth","realHeight","minFilter","magFilter","uWrap","vWrap","TextureAtlasRegion","addTextureHash","textures","stripExtension","substr","lastIndexOf","load","reader","TextureAtlasReader","tuple","iterateParser","readLine","readTuple","parseInt","readValue","hasLoaded","setFilters","resolution","Rectangle","frame2","clone","_updateUvs","lines","colon","substring","lastMatch","comma","filter","scaleMode","SCALE_MODES","NEAREST","mipmap","Vector2","applyRelativeLocal","applyAbsoluteLocal","applyRelativeWorld","applyAbsoluteWorld","targetMat","tb","tc","td","degRadReflect","modified","ts","convexPolygons","convexPolygonsIndices","indicesArray","isConcaveArray","polygonIndicesPool","indices","isConcave","previous","p1","p2","p3","p3x","p3y","positiveArea","previousIndex","nextIndex","polygonIndices","fanBaseIndex","lastWinding","t1","t2","t3","merged","winding1","winding","winding2","firstIndex","lastIndex","prevPrevX","prevPrevY","firstX","firstY","secondX","secondY","otherIndices","otherFirstIndex","otherSecondIndex","otherLastIndex","otherPoly","array","contains","remove","hex","WHITE","RED","GREEN","BLUE","MAGENTA","cbrt","pow","randomTriangular","randomTriangularWith","mode","radiansToDegrees","degreesToRadians","Interpolation","applyInternal","Pow","power","PowOut","sourceStart","dest","destStart","numElements","oldSize","SUPPORTS_TYPED_ARRAYS","Float32Array","newShortArray","Int16Array","DebugUtils","logBones","instantiator","items","item","normalize","len","TimeKeeper","maxDelta","framesPerSecond","totalTime","Date","now","WindowedMean","windowSize","addedValues","lastValue","mean","dirty","hasEnoughData","addValue","getMean","JitterEffect","jitterX","jitterY","begin","uv","SwirlEffect","radius","centerX","centerY","radAngle","dist","theta","interpolation","isJson","resource","TYPE","loaders","Resource","atlasParser","metadata","metadataSkeletonScale","spineSkeletonScale","metadataAtlas","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","replace","baseUrl","atlasOptions","crossOrigin","xhrType","XHR_RESPONSE_TYPE","TEXT","spineMetadata","parentResource","imageOptions","imageMetadata","adapter","staticImageLoader","imageLoader","imageLoaderAdapter","atlasResource","namePrefix","syncImageLoaderAdapter","Loader","addPixiMiddleware","use","fround","SlotContainerUpdateTransformV3","pt","worldTransform","wt","localTransform","worldAlpha","_currentBounds","tempRgb","SpineSprite","Sprite","SpineMesh","drawMode","Mesh","hackTextureBySlotName","hackTextureBySlotIndex","stateData","state","slotContainers","tempClipContainers","slotContainer","Container","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","createGraphics","clippingContainer","currentGraphics","autoUpdate","tintRgb","updateTransform","autoUpdateTransform","utils","rgb2hex","hex2rgb","dt","g0","b0","attColor","visible","ar","sprites","transAny","matrix2d","_dirtyVersion","isStatic","operMode","TransformBase","setFromMatrix","copy","displayObjectUpdateTransform","tint","TransformStatic","DisplayObject","meshName","meshes","updateGraphics","clippingAttachment","renderable","setSpriteRegion","setMeshRegion","globalAutoUpdate","timeDelta","defName","tempAttachment","tempRegion","anchor","strip","Uint16Array","DRAW_MODES","TRIANGLES","canvasPadding","graphics","Graphics","poly","Polygon","beginFill","drawPolygon","mask","graphicsData","shape","points","clearDirty","sign","EPSILON","EPSILON32","MAX32","MIN32","roundTiesToEven","$abs","$sign","Infinity","$Object","D","setPrototypeOf","check","test","buggy","gOPD","getOwnPropertyDescriptor","newSpine","initAnimation","autoplay","playAnimation","Promise","Internal","GenericPromiseCapability","Wrapper","anInstance","forOf","speciesConstructor","task","microtask","$Promise","isNode","empty","USE_NATIVE","promise","FakePromise","PromiseRejectionEvent","sameConstructor","isThenable","newPromiseCapability","PromiseCapability","$$resolve","$$reject","perform","error","notify","isReject","_n","chain","_c","_v","ok","_s","reaction","handler","fail","domain","_h","onHandleUnhandled","enter","exit","onUnhandled","abrupt","isUnhandled","emit","onunhandledrejection","reason","_a","onrejectionhandled","$reject","_d","_w","$resolve","wrapper","executor","err","onFulfilled","onRejected","capability","iter","all","iterable","remaining","$index","alreadyCalled","race","forbiddenField","isArrayIter","getIterFn","BREAK","RETURN","iterator","iterFn","ret","ArrayProto","SPECIES","un","macrotask","Observer","MutationObserver","WebKitMutationObserver","head","flush","toggle","node","createTextNode","observe","characterData","safe","DESCRIPTORS","KEY","SAFE_CLOSING","riter","skipClosing","arr","_isReady","isReady"],"mappings":"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","file":"YSP_Spine.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 63);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store      = __webpack_require__(21)('wks')\n  , uid        = __webpack_require__(22)\n  , Symbol     = __webpack_require__(0).Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nvar core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(16)(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP         = __webpack_require__(11)\n  , createDesc = __webpack_require__(19);\nmodule.exports = __webpack_require__(3) ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6);\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(24)\n  , defined = __webpack_require__(14);\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global    = __webpack_require__(0)\n  , core      = __webpack_require__(2)\n  , ctx       = __webpack_require__(15)\n  , hide      = __webpack_require__(4)\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject       = __webpack_require__(5)\n  , IE8_DOM_DEFINE = __webpack_require__(25)\n  , toPrimitive    = __webpack_require__(26)\n  , dP             = Object.defineProperty;\n\nexports.f = __webpack_require__(3) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(20);\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(21)('keys')\n  , uid    = __webpack_require__(22);\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6)\n  , document = __webpack_require__(0).document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(0)\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nvar id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(13);\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(3) && !__webpack_require__(16)(function(){\n  return Object.defineProperty(__webpack_require__(18)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(6);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = __webpack_require__(31)\n  , enumBugKeys = __webpack_require__(23);\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.15 ToLength\nvar toInteger = __webpack_require__(12)\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar def = __webpack_require__(11).f\n  , has = __webpack_require__(8)\n  , TAG = __webpack_require__(1)('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY        = __webpack_require__(34)\n  , $export        = __webpack_require__(10)\n  , redefine       = __webpack_require__(45)\n  , hide           = __webpack_require__(4)\n  , has            = __webpack_require__(8)\n  , Iterators      = __webpack_require__(9)\n  , $iterCreate    = __webpack_require__(46)\n  , setToStringTag = __webpack_require__(29)\n  , getPrototypeOf = __webpack_require__(48)\n  , ITERATOR       = __webpack_require__(1)('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has          = __webpack_require__(8)\n  , toIObject    = __webpack_require__(7)\n  , arrayIndexOf = __webpack_require__(32)(false)\n  , IE_PROTO     = __webpack_require__(17)('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(7)\n  , toLength  = __webpack_require__(28)\n  , toIndex   = __webpack_require__(33);\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(12)\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\nmodule.exports = true;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = __webpack_require__(5)\n  , dPs         = __webpack_require__(47)\n  , enumBugKeys = __webpack_require__(23)\n  , IE_PROTO    = __webpack_require__(17)('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(18)('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(36).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0).document && document.documentElement;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(14);\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(13)\n  , TAG = __webpack_require__(1)('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\nexports.f = {}.propertyIsEnumerable;\n\n/***/ }),\n/* 40 */,\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(42);\nvar global        = __webpack_require__(0)\n  , hide          = __webpack_require__(4)\n  , Iterators     = __webpack_require__(9)\n  , TO_STRING_TAG = __webpack_require__(1)('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar addToUnscopables = __webpack_require__(43)\n  , step             = __webpack_require__(44)\n  , Iterators        = __webpack_require__(9)\n  , toIObject        = __webpack_require__(7);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(30)(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(){ /* empty */ };\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(4);\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar create         = __webpack_require__(35)\n  , descriptor     = __webpack_require__(19)\n  , setToStringTag = __webpack_require__(29)\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(4)(IteratorPrototype, __webpack_require__(1)('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP       = __webpack_require__(11)\n  , anObject = __webpack_require__(5)\n  , getKeys  = __webpack_require__(27);\n\nmodule.exports = __webpack_require__(3) ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = __webpack_require__(8)\n  , toObject    = __webpack_require__(37)\n  , IE_PROTO    = __webpack_require__(17)('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $at  = __webpack_require__(50)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(30)(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(12)\n  , defined   = __webpack_require__(14);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof   = __webpack_require__(38)\n  , ITERATOR  = __webpack_require__(1)('iterator')\n  , Iterators = __webpack_require__(9);\nmodule.exports = __webpack_require__(2).getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n/***/ }),\n/* 52 */,\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _promise = __webpack_require__(83);\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar raws = {};\nvar spines = {};\nvar filesToLoad = 0;\n\nvar _loadRaw = function _loadRaw(path) {\n    return new _promise2.default(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', path);\n        xhr.onload = function () {\n            return resolve(xhr.responseText);\n        };\n        xhr.onerror = function () {\n            return resolve(xhr.statusText);\n        };\n        xhr.send();\n    });\n};\n\nvar _loadTexture = function _loadTexture(path) {\n    return new _promise2.default(function (resolve, reject) {\n        var texture = PIXI.BaseTexture.fromImage(path);\n        texture.on('loaded', function (baseTexture) {\n            return resolve(baseTexture);\n        });\n        texture.on('error', function (baseTexture) {\n            return reject(baseTexture);\n        });\n    });\n};\n\nvar loadAssets = function loadAssets(spineName) {\n    var setup = ysp.Spine.SETUP[spineName];\n    if (raws[spineName]) {\n        return;\n    }\n    raws[spineName] = {};\n    filesToLoad = filesToLoad + 3;\n\n    _loadRaw(setup.json).then(function (res) {\n        raws[spineName].json = JSON.parse(res);\n        filesToLoad = filesToLoad - 1;\n    }).catch(function (res) {\n        console.log(res);\n    });\n\n    _loadRaw(setup.atlas).then(function (res) {\n        raws[spineName].atlas = res;\n        filesToLoad = filesToLoad - 1;\n    }).catch(function (res) {\n        console.log(res);\n    });\n\n    _loadTexture(setup.texture).then(function (texture) {\n        raws[spineName].texture = texture;\n        filesToLoad = filesToLoad - 1;\n    }).catch(function (texture) {\n        console.log('Couldn\\'t load: ' + setup.texture);\n    });\n};\n\nvar loadSkeleton = function loadSkeleton(spineName) {\n    var setup = ysp.Spine.SETUP[spineName];\n\n    if (spines[spineName]) {\n        return spines[spineName];\n    }\n\n    if (!raws[spineName]) {\n        console.log('[Error] Spine \\'' + spineName + '\\' hasn\\'t pre-loaded');\n        return;\n    }\n\n    var rawSkeletonData = raws[spineName].json;\n    var rawAtlasData = raws[spineName].atlas;\n\n    var spineAtlas = new PIXI.spine.core.TextureAtlas(rawAtlasData, function (line, callback) {\n        callback(raws[spineName].texture);\n    });\n\n    var spineAtlasLoader = new PIXI.spine.core.AtlasAttachmentLoader(spineAtlas);\n    var spineJsonParser = new PIXI.spine.core.SkeletonJson(spineAtlasLoader);\n\n    var spineData = spineJsonParser.readSkeletonData(rawSkeletonData);\n    spines[spineName] = spineData;\n\n    return spines[spineName];\n};\n\nvar isLoaded = function isLoaded() {\n    return filesToLoad === 0;\n};\n\nexports.default = {\n    loadAssets: loadAssets,\n    loadSkeleton: loadSkeleton,\n    isLoaded: isLoaded,\n    raws: raws,\n    spines: spines\n};\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx                = __webpack_require__(15)\n  , invoke             = __webpack_require__(92)\n  , html               = __webpack_require__(36)\n  , cel                = __webpack_require__(18)\n  , global             = __webpack_require__(0)\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(__webpack_require__(13)(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};\n\n/***/ }),\n/* 55 */,\n/* 56 */,\n/* 57 */,\n/* 58 */,\n/* 59 */,\n/* 60 */,\n/* 61 */,\n/* 62 */,\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _assign = __webpack_require__(64);\n\nvar _assign2 = _interopRequireDefault(_assign);\n\n__webpack_require__(69);\n\nvar _spine = __webpack_require__(82);\n\nvar _spine2 = _interopRequireDefault(_spine);\n\nvar _loader = __webpack_require__(53);\n\nvar _loader2 = _interopRequireDefault(_loader);\n\nvar _sceneBase = __webpack_require__(97);\n\nvar _sceneBase2 = _interopRequireDefault(_sceneBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.ysp = window.ysp || {};\n\n(0, _sceneBase2.default)(Scene_Base);\n\nvar _exports = {\n    spine: _spine2.default,\n    loader: _loader2.default\n};\nwindow.ysp.Spine = (0, _assign2.default)({}, window.ysp.Spine, _exports);\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(65), __esModule: true };\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(66);\nmodule.exports = __webpack_require__(2).Object.assign;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.3.1 Object.assign(target, source)\nvar $export = __webpack_require__(10);\n\n$export($export.S + $export.F, 'Object', {assign: __webpack_require__(67)});\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = __webpack_require__(27)\n  , gOPS     = __webpack_require__(68)\n  , pIE      = __webpack_require__(39)\n  , toObject = __webpack_require__(37)\n  , IObject  = __webpack_require__(24)\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __webpack_require__(16)(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _fround = __webpack_require__(70);\n\nvar _fround2 = _interopRequireDefault(_fround);\n\nvar _create = __webpack_require__(74);\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _setPrototypeOf = __webpack_require__(77);\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = _setPrototypeOf2.default || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? (0, _create2.default)(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar pixi_spine;\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Animation = function () {\n            function Animation(name, timelines, duration) {\n                if (name == null) throw new Error(\"name cannot be null.\");\n                if (timelines == null) throw new Error(\"timelines cannot be null.\");\n                this.name = name;\n                this.timelines = timelines;\n                this.duration = duration;\n            }\n            Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, pose, direction) {\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                if (loop && this.duration != 0) {\n                    time %= this.duration;\n                    if (lastTime > 0) lastTime %= this.duration;\n                }\n                var timelines = this.timelines;\n                for (var i = 0, n = timelines.length; i < n; i++) {\n                    timelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction);\n                }\n            };\n            Animation.binarySearch = function (values, target, step) {\n                if (step === void 0) {\n                    step = 1;\n                }\n                var low = 0;\n                var high = values.length / step - 2;\n                if (high == 0) return step;\n                var current = high >>> 1;\n                while (true) {\n                    if (values[(current + 1) * step] <= target) low = current + 1;else high = current;\n                    if (low == high) return (low + 1) * step;\n                    current = low + high >>> 1;\n                }\n            };\n            Animation.linearSearch = function (values, target, step) {\n                for (var i = 0, last = values.length - step; i <= last; i += step) {\n                    if (values[i] > target) return i;\n                }return -1;\n            };\n            return Animation;\n        }();\n        core.Animation = Animation;\n        var MixPose;\n        (function (MixPose) {\n            MixPose[MixPose[\"setup\"] = 0] = \"setup\";\n            MixPose[MixPose[\"current\"] = 1] = \"current\";\n            MixPose[MixPose[\"currentLayered\"] = 2] = \"currentLayered\";\n        })(MixPose = core.MixPose || (core.MixPose = {}));\n        var MixDirection;\n        (function (MixDirection) {\n            MixDirection[MixDirection[\"in\"] = 0] = \"in\";\n            MixDirection[MixDirection[\"out\"] = 1] = \"out\";\n        })(MixDirection = core.MixDirection || (core.MixDirection = {}));\n        var TimelineType;\n        (function (TimelineType) {\n            TimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\n            TimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\n            TimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\n            TimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\n            TimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\n            TimelineType[TimelineType[\"color\"] = 5] = \"color\";\n            TimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\n            TimelineType[TimelineType[\"event\"] = 7] = \"event\";\n            TimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\n            TimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\n            TimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\n            TimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\n            TimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\n            TimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\n            TimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\n        })(TimelineType = core.TimelineType || (core.TimelineType = {}));\n        var CurveTimeline = function () {\n            function CurveTimeline(frameCount) {\n                if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n                this.curves = core.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n            }\n            CurveTimeline.prototype.getFrameCount = function () {\n                return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n            };\n            CurveTimeline.prototype.setLinear = function (frameIndex) {\n                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n            };\n            CurveTimeline.prototype.setStepped = function (frameIndex) {\n                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n            };\n            CurveTimeline.prototype.getCurveType = function (frameIndex) {\n                var index = frameIndex * CurveTimeline.BEZIER_SIZE;\n                if (index == this.curves.length) return CurveTimeline.LINEAR;\n                var type = this.curves[index];\n                if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n                if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n                return CurveTimeline.BEZIER;\n            };\n            CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\n                var tmpx = (-cx1 * 2 + cx2) * 0.03,\n                    tmpy = (-cy1 * 2 + cy2) * 0.03;\n                var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006,\n                    dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n                var ddfx = tmpx * 2 + dddfx,\n                    ddfy = tmpy * 2 + dddfy;\n                var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667,\n                    dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n                var i = frameIndex * CurveTimeline.BEZIER_SIZE;\n                var curves = this.curves;\n                curves[i++] = CurveTimeline.BEZIER;\n                var x = dfx,\n                    y = dfy;\n                for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                    curves[i] = x;\n                    curves[i + 1] = y;\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    x += dfx;\n                    y += dfy;\n                }\n            };\n            CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\n                percent = core.MathUtils.clamp(percent, 0, 1);\n                var curves = this.curves;\n                var i = frameIndex * CurveTimeline.BEZIER_SIZE;\n                var type = curves[i];\n                if (type == CurveTimeline.LINEAR) return percent;\n                if (type == CurveTimeline.STEPPED) return 0;\n                i++;\n                var x = 0;\n                for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                    x = curves[i];\n                    if (x >= percent) {\n                        var prevX = void 0,\n                            prevY = void 0;\n                        if (i == start) {\n                            prevX = 0;\n                            prevY = 0;\n                        } else {\n                            prevX = curves[i - 2];\n                            prevY = curves[i - 1];\n                        }\n                        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n                    }\n                }\n                var y = curves[i - 1];\n                return y + (1 - y) * (percent - x) / (1 - x);\n            };\n            return CurveTimeline;\n        }();\n        CurveTimeline.LINEAR = 0;\n        CurveTimeline.STEPPED = 1;\n        CurveTimeline.BEZIER = 2;\n        CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\n        core.CurveTimeline = CurveTimeline;\n        var RotateTimeline = function (_super) {\n            __extends(RotateTimeline, _super);\n            function RotateTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount << 1);\n                return _this;\n            }\n            RotateTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.rotate << 24) + this.boneIndex;\n            };\n            RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\n                frameIndex <<= 1;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n            };\n            RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var frames = this.frames;\n                var bone = skeleton.bones[this.boneIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            bone.rotation = bone.data.rotation;\n                            return;\n                        case MixPose.current:\n                            var r_1 = bone.data.rotation - bone.rotation;\n                            r_1 -= (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360;\n                            bone.rotation += r_1 * alpha;\n                    }\n                    return;\n                }\n                if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\n                    if (pose == MixPose.setup) bone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;else {\n                        var r_2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\n                        r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;\n                        bone.rotation += r_2 * alpha;\n                    }\n                    return;\n                }\n                var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n                var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                r = prevRotation + r * percent;\n                if (pose == MixPose.setup) {\n                    r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                    bone.rotation = bone.data.rotation + r * alpha;\n                } else {\n                    r = bone.data.rotation + r - bone.rotation;\n                    r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                    bone.rotation += r * alpha;\n                }\n            };\n            return RotateTimeline;\n        }(CurveTimeline);\n        RotateTimeline.ENTRIES = 2;\n        RotateTimeline.PREV_TIME = -2;\n        RotateTimeline.PREV_ROTATION = -1;\n        RotateTimeline.ROTATION = 1;\n        core.RotateTimeline = RotateTimeline;\n        var TranslateTimeline = function (_super) {\n            __extends(TranslateTimeline, _super);\n            function TranslateTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n                return _this;\n            }\n            TranslateTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.translate << 24) + this.boneIndex;\n            };\n            TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\n                frameIndex *= TranslateTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + TranslateTimeline.X] = x;\n                this.frames[frameIndex + TranslateTimeline.Y] = y;\n            };\n            TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var frames = this.frames;\n                var bone = skeleton.bones[this.boneIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            bone.x = bone.data.x;\n                            bone.y = bone.data.y;\n                            return;\n                        case MixPose.current:\n                            bone.x += (bone.data.x - bone.x) * alpha;\n                            bone.y += (bone.data.y - bone.y) * alpha;\n                    }\n                    return;\n                }\n                var x = 0,\n                    y = 0;\n                if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\n                    x = frames[frames.length + TranslateTimeline.PREV_X];\n                    y = frames[frames.length + TranslateTimeline.PREV_Y];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n                    x = frames[frame + TranslateTimeline.PREV_X];\n                    y = frames[frame + TranslateTimeline.PREV_Y];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n                    x += (frames[frame + TranslateTimeline.X] - x) * percent;\n                    y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n                }\n                if (pose == MixPose.setup) {\n                    bone.x = bone.data.x + x * alpha;\n                    bone.y = bone.data.y + y * alpha;\n                } else {\n                    bone.x += (bone.data.x + x - bone.x) * alpha;\n                    bone.y += (bone.data.y + y - bone.y) * alpha;\n                }\n            };\n            return TranslateTimeline;\n        }(CurveTimeline);\n        TranslateTimeline.ENTRIES = 3;\n        TranslateTimeline.PREV_TIME = -3;\n        TranslateTimeline.PREV_X = -2;\n        TranslateTimeline.PREV_Y = -1;\n        TranslateTimeline.X = 1;\n        TranslateTimeline.Y = 2;\n        core.TranslateTimeline = TranslateTimeline;\n        var ScaleTimeline = function (_super) {\n            __extends(ScaleTimeline, _super);\n            function ScaleTimeline(frameCount) {\n                return _super.call(this, frameCount) || this;\n            }\n            ScaleTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.scale << 24) + this.boneIndex;\n            };\n            ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var frames = this.frames;\n                var bone = skeleton.bones[this.boneIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            bone.scaleX = bone.data.scaleX;\n                            bone.scaleY = bone.data.scaleY;\n                            return;\n                        case MixPose.current:\n                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n                    }\n                    return;\n                }\n                var x = 0,\n                    y = 0;\n                if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n                    x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n                    y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n                } else {\n                    var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n                    x = frames[frame + ScaleTimeline.PREV_X];\n                    y = frames[frame + ScaleTimeline.PREV_Y];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n                    x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n                    y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n                }\n                if (alpha == 1) {\n                    bone.scaleX = x;\n                    bone.scaleY = y;\n                } else {\n                    var bx = 0,\n                        by = 0;\n                    if (pose == MixPose.setup) {\n                        bx = bone.data.scaleX;\n                        by = bone.data.scaleY;\n                    } else {\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                    }\n                    if (direction == MixDirection.out) {\n                        x = Math.abs(x) * core.MathUtils.signum(bx);\n                        y = Math.abs(y) * core.MathUtils.signum(by);\n                    } else {\n                        bx = Math.abs(bx) * core.MathUtils.signum(x);\n                        by = Math.abs(by) * core.MathUtils.signum(y);\n                    }\n                    bone.scaleX = bx + (x - bx) * alpha;\n                    bone.scaleY = by + (y - by) * alpha;\n                }\n            };\n            return ScaleTimeline;\n        }(TranslateTimeline);\n        core.ScaleTimeline = ScaleTimeline;\n        var ShearTimeline = function (_super) {\n            __extends(ShearTimeline, _super);\n            function ShearTimeline(frameCount) {\n                return _super.call(this, frameCount) || this;\n            }\n            ShearTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.shear << 24) + this.boneIndex;\n            };\n            ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var frames = this.frames;\n                var bone = skeleton.bones[this.boneIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            bone.shearX = bone.data.shearX;\n                            bone.shearY = bone.data.shearY;\n                            return;\n                        case MixPose.current:\n                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n                    }\n                    return;\n                }\n                var x = 0,\n                    y = 0;\n                if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n                    x = frames[frames.length + ShearTimeline.PREV_X];\n                    y = frames[frames.length + ShearTimeline.PREV_Y];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n                    x = frames[frame + ShearTimeline.PREV_X];\n                    y = frames[frame + ShearTimeline.PREV_Y];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n                    x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n                    y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n                }\n                if (pose == MixPose.setup) {\n                    bone.shearX = bone.data.shearX + x * alpha;\n                    bone.shearY = bone.data.shearY + y * alpha;\n                } else {\n                    bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                }\n            };\n            return ShearTimeline;\n        }(TranslateTimeline);\n        core.ShearTimeline = ShearTimeline;\n        var ColorTimeline = function (_super) {\n            __extends(ColorTimeline, _super);\n            function ColorTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n                return _this;\n            }\n            ColorTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.color << 24) + this.slotIndex;\n            };\n            ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\n                frameIndex *= ColorTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + ColorTimeline.R] = r;\n                this.frames[frameIndex + ColorTimeline.G] = g;\n                this.frames[frameIndex + ColorTimeline.B] = b;\n                this.frames[frameIndex + ColorTimeline.A] = a;\n            };\n            ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var slot = skeleton.slots[this.slotIndex];\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            slot.color.setFromColor(slot.data.color);\n                            return;\n                        case MixPose.current:\n                            var color = slot.color,\n                                setup = slot.data.color;\n                            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n                    }\n                    return;\n                }\n                var r = 0,\n                    g = 0,\n                    b = 0,\n                    a = 0;\n                if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\n                    var i = frames.length;\n                    r = frames[i + ColorTimeline.PREV_R];\n                    g = frames[i + ColorTimeline.PREV_G];\n                    b = frames[i + ColorTimeline.PREV_B];\n                    a = frames[i + ColorTimeline.PREV_A];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n                    r = frames[frame + ColorTimeline.PREV_R];\n                    g = frames[frame + ColorTimeline.PREV_G];\n                    b = frames[frame + ColorTimeline.PREV_B];\n                    a = frames[frame + ColorTimeline.PREV_A];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n                    r += (frames[frame + ColorTimeline.R] - r) * percent;\n                    g += (frames[frame + ColorTimeline.G] - g) * percent;\n                    b += (frames[frame + ColorTimeline.B] - b) * percent;\n                    a += (frames[frame + ColorTimeline.A] - a) * percent;\n                }\n                if (alpha == 1) slot.color.set(r, g, b, a);else {\n                    var color = slot.color;\n                    if (pose == MixPose.setup) color.setFromColor(slot.data.color);\n                    color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n                }\n            };\n            return ColorTimeline;\n        }(CurveTimeline);\n        ColorTimeline.ENTRIES = 5;\n        ColorTimeline.PREV_TIME = -5;\n        ColorTimeline.PREV_R = -4;\n        ColorTimeline.PREV_G = -3;\n        ColorTimeline.PREV_B = -2;\n        ColorTimeline.PREV_A = -1;\n        ColorTimeline.R = 1;\n        ColorTimeline.G = 2;\n        ColorTimeline.B = 3;\n        ColorTimeline.A = 4;\n        core.ColorTimeline = ColorTimeline;\n        var TwoColorTimeline = function (_super) {\n            __extends(TwoColorTimeline, _super);\n            function TwoColorTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n                return _this;\n            }\n            TwoColorTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.twoColor << 24) + this.slotIndex;\n            };\n            TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\n                frameIndex *= TwoColorTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + TwoColorTimeline.R] = r;\n                this.frames[frameIndex + TwoColorTimeline.G] = g;\n                this.frames[frameIndex + TwoColorTimeline.B] = b;\n                this.frames[frameIndex + TwoColorTimeline.A] = a;\n                this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n                this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n                this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n            };\n            TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var slot = skeleton.slots[this.slotIndex];\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            slot.color.setFromColor(slot.data.color);\n                            slot.darkColor.setFromColor(slot.data.darkColor);\n                            return;\n                        case MixPose.current:\n                            var light = slot.color,\n                                dark = slot.darkColor,\n                                setupLight = slot.data.color,\n                                setupDark = slot.data.darkColor;\n                            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                            dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n                    }\n                    return;\n                }\n                var r = 0,\n                    g = 0,\n                    b = 0,\n                    a = 0,\n                    r2 = 0,\n                    g2 = 0,\n                    b2 = 0;\n                if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\n                    var i = frames.length;\n                    r = frames[i + TwoColorTimeline.PREV_R];\n                    g = frames[i + TwoColorTimeline.PREV_G];\n                    b = frames[i + TwoColorTimeline.PREV_B];\n                    a = frames[i + TwoColorTimeline.PREV_A];\n                    r2 = frames[i + TwoColorTimeline.PREV_R2];\n                    g2 = frames[i + TwoColorTimeline.PREV_G2];\n                    b2 = frames[i + TwoColorTimeline.PREV_B2];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n                    r = frames[frame + TwoColorTimeline.PREV_R];\n                    g = frames[frame + TwoColorTimeline.PREV_G];\n                    b = frames[frame + TwoColorTimeline.PREV_B];\n                    a = frames[frame + TwoColorTimeline.PREV_A];\n                    r2 = frames[frame + TwoColorTimeline.PREV_R2];\n                    g2 = frames[frame + TwoColorTimeline.PREV_G2];\n                    b2 = frames[frame + TwoColorTimeline.PREV_B2];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n                    r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n                    g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n                    b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n                    a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n                    r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n                    g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n                    b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n                }\n                if (alpha == 1) {\n                    slot.color.set(r, g, b, a);\n                    slot.darkColor.set(r2, g2, b2, 1);\n                } else {\n                    var light = slot.color,\n                        dark = slot.darkColor;\n                    if (pose == MixPose.setup) {\n                        light.setFromColor(slot.data.color);\n                        dark.setFromColor(slot.data.darkColor);\n                    }\n                    light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n                    dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n                }\n            };\n            return TwoColorTimeline;\n        }(CurveTimeline);\n        TwoColorTimeline.ENTRIES = 8;\n        TwoColorTimeline.PREV_TIME = -8;\n        TwoColorTimeline.PREV_R = -7;\n        TwoColorTimeline.PREV_G = -6;\n        TwoColorTimeline.PREV_B = -5;\n        TwoColorTimeline.PREV_A = -4;\n        TwoColorTimeline.PREV_R2 = -3;\n        TwoColorTimeline.PREV_G2 = -2;\n        TwoColorTimeline.PREV_B2 = -1;\n        TwoColorTimeline.R = 1;\n        TwoColorTimeline.G = 2;\n        TwoColorTimeline.B = 3;\n        TwoColorTimeline.A = 4;\n        TwoColorTimeline.R2 = 5;\n        TwoColorTimeline.G2 = 6;\n        TwoColorTimeline.B2 = 7;\n        core.TwoColorTimeline = TwoColorTimeline;\n        var AttachmentTimeline = function () {\n            function AttachmentTimeline(frameCount) {\n                this.frames = core.Utils.newFloatArray(frameCount);\n                this.attachmentNames = new Array(frameCount);\n            }\n            AttachmentTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.attachment << 24) + this.slotIndex;\n            };\n            AttachmentTimeline.prototype.getFrameCount = function () {\n                return this.frames.length;\n            };\n            AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\n                this.frames[frameIndex] = time;\n                this.attachmentNames[frameIndex] = attachmentName;\n            };\n            AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var slot = skeleton.slots[this.slotIndex];\n                if (direction == MixDirection.out && pose == MixPose.setup) {\n                    var attachmentName_1 = slot.data.attachmentName;\n                    slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));\n                    return;\n                }\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    if (pose == MixPose.setup) {\n                        var attachmentName_2 = slot.data.attachmentName;\n                        slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));\n                    }\n                    return;\n                }\n                var frameIndex = 0;\n                if (time >= frames[frames.length - 1]) frameIndex = frames.length - 1;else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n                var attachmentName = this.attachmentNames[frameIndex];\n                skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n            };\n            return AttachmentTimeline;\n        }();\n        core.AttachmentTimeline = AttachmentTimeline;\n        var zeros = null;\n        var DeformTimeline = function (_super) {\n            __extends(DeformTimeline, _super);\n            function DeformTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount);\n                _this.frameVertices = new Array(frameCount);\n                if (zeros == null) zeros = core.Utils.newFloatArray(64);\n                return _this;\n            }\n            DeformTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\n            };\n            DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\n                this.frames[frameIndex] = time;\n                this.frameVertices[frameIndex] = vertices;\n            };\n            DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var slot = skeleton.slots[this.slotIndex];\n                var slotAttachment = slot.getAttachment();\n                if (!(slotAttachment instanceof core.VertexAttachment) || !slotAttachment.applyDeform(this.attachment)) return;\n                var verticesArray = slot.attachmentVertices;\n                var frameVertices = this.frameVertices;\n                var vertexCount = frameVertices[0].length;\n                var vertices = core.Utils.setArraySize(verticesArray, vertexCount);\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    var vertexAttachment = slotAttachment;\n                    switch (pose) {\n                        case MixPose.setup:\n                            var zeroVertices = void 0;\n                            if (vertexAttachment.bones == null) {\n                                zeroVertices = vertexAttachment.vertices;\n                            } else {\n                                zeroVertices = zeros;\n                                if (zeroVertices.length < vertexCount) zeros = zeroVertices = core.Utils.newFloatArray(vertexCount);\n                            }\n                            core.Utils.arrayCopy(zeroVertices, 0, vertices, 0, vertexCount);\n                            return;\n                        case MixPose.current:\n                            if (alpha == 1) break;\n                            if (vertexAttachment.bones == null) {\n                                var setupVertices = vertexAttachment.vertices;\n                                for (var i_1 = 0; i_1 < vertexCount; i_1++) {\n                                    vertices[i_1] += (setupVertices[i_1] - vertices[i_1]) * alpha;\n                                }\n                            } else {\n                                alpha = 1 - alpha;\n                                for (var i = 0; i < vertexCount; i++) {\n                                    vertices[i] *= alpha;\n                                }\n                            }\n                    }\n                    return;\n                }\n                if (time >= frames[frames.length - 1]) {\n                    var lastVertices = frameVertices[frames.length - 1];\n                    if (alpha == 1) {\n                        core.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n                    } else if (pose == MixPose.setup) {\n                        var vertexAttachment = slotAttachment;\n                        if (vertexAttachment.bones == null) {\n                            var setupVertices = vertexAttachment.vertices;\n                            for (var i_2 = 0; i_2 < vertexCount; i_2++) {\n                                var setup = setupVertices[i_2];\n                                vertices[i_2] = setup + (lastVertices[i_2] - setup) * alpha;\n                            }\n                        } else {\n                            for (var i_3 = 0; i_3 < vertexCount; i_3++) {\n                                vertices[i_3] = lastVertices[i_3] * alpha;\n                            }\n                        }\n                    } else {\n                        for (var i_4 = 0; i_4 < vertexCount; i_4++) {\n                            vertices[i_4] += (lastVertices[i_4] - vertices[i_4]) * alpha;\n                        }\n                    }\n                    return;\n                }\n                var frame = Animation.binarySearch(frames, time);\n                var prevVertices = frameVertices[frame - 1];\n                var nextVertices = frameVertices[frame];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n                if (alpha == 1) {\n                    for (var i_5 = 0; i_5 < vertexCount; i_5++) {\n                        var prev = prevVertices[i_5];\n                        vertices[i_5] = prev + (nextVertices[i_5] - prev) * percent;\n                    }\n                } else if (pose == MixPose.setup) {\n                    var vertexAttachment = slotAttachment;\n                    if (vertexAttachment.bones == null) {\n                        var setupVertices = vertexAttachment.vertices;\n                        for (var i_6 = 0; i_6 < vertexCount; i_6++) {\n                            var prev = prevVertices[i_6],\n                                setup = setupVertices[i_6];\n                            vertices[i_6] = setup + (prev + (nextVertices[i_6] - prev) * percent - setup) * alpha;\n                        }\n                    } else {\n                        for (var i_7 = 0; i_7 < vertexCount; i_7++) {\n                            var prev = prevVertices[i_7];\n                            vertices[i_7] = (prev + (nextVertices[i_7] - prev) * percent) * alpha;\n                        }\n                    }\n                } else {\n                    for (var i_8 = 0; i_8 < vertexCount; i_8++) {\n                        var prev = prevVertices[i_8];\n                        vertices[i_8] += (prev + (nextVertices[i_8] - prev) * percent - vertices[i_8]) * alpha;\n                    }\n                }\n            };\n            return DeformTimeline;\n        }(CurveTimeline);\n        core.DeformTimeline = DeformTimeline;\n        var EventTimeline = function () {\n            function EventTimeline(frameCount) {\n                this.frames = core.Utils.newFloatArray(frameCount);\n                this.events = new Array(frameCount);\n            }\n            EventTimeline.prototype.getPropertyId = function () {\n                return TimelineType.event << 24;\n            };\n            EventTimeline.prototype.getFrameCount = function () {\n                return this.frames.length;\n            };\n            EventTimeline.prototype.setFrame = function (frameIndex, event) {\n                this.frames[frameIndex] = event.time;\n                this.events[frameIndex] = event;\n            };\n            EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                if (firedEvents == null) return;\n                var frames = this.frames;\n                var frameCount = this.frames.length;\n                if (lastTime > time) {\n                    this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);\n                    lastTime = -1;\n                } else if (lastTime >= frames[frameCount - 1]) return;\n                if (time < frames[0]) return;\n                var frame = 0;\n                if (lastTime < frames[0]) frame = 0;else {\n                    frame = Animation.binarySearch(frames, lastTime);\n                    var frameTime = frames[frame];\n                    while (frame > 0) {\n                        if (frames[frame - 1] != frameTime) break;\n                        frame--;\n                    }\n                }\n                for (; frame < frameCount && time >= frames[frame]; frame++) {\n                    firedEvents.push(this.events[frame]);\n                }\n            };\n            return EventTimeline;\n        }();\n        core.EventTimeline = EventTimeline;\n        var DrawOrderTimeline = function () {\n            function DrawOrderTimeline(frameCount) {\n                this.frames = core.Utils.newFloatArray(frameCount);\n                this.drawOrders = new Array(frameCount);\n            }\n            DrawOrderTimeline.prototype.getPropertyId = function () {\n                return TimelineType.drawOrder << 24;\n            };\n            DrawOrderTimeline.prototype.getFrameCount = function () {\n                return this.frames.length;\n            };\n            DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\n                this.frames[frameIndex] = time;\n                this.drawOrders[frameIndex] = drawOrder;\n            };\n            DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var drawOrder = skeleton.drawOrder;\n                var slots = skeleton.slots;\n                if (direction == MixDirection.out && pose == MixPose.setup) {\n                    core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                    return;\n                }\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    if (pose == MixPose.setup) core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                    return;\n                }\n                var frame = 0;\n                if (time >= frames[frames.length - 1]) frame = frames.length - 1;else frame = Animation.binarySearch(frames, time) - 1;\n                var drawOrderToSetupIndex = this.drawOrders[frame];\n                if (drawOrderToSetupIndex == null) core.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);else {\n                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) {\n                        drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n                    }\n                }\n            };\n            return DrawOrderTimeline;\n        }();\n        core.DrawOrderTimeline = DrawOrderTimeline;\n        var IkConstraintTimeline = function (_super) {\n            __extends(IkConstraintTimeline, _super);\n            function IkConstraintTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n                return _this;\n            }\n            IkConstraintTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n            };\n            IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection) {\n                frameIndex *= IkConstraintTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n                this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n            };\n            IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.mix = constraint.data.mix;\n                            constraint.bendDirection = constraint.data.bendDirection;\n                            return;\n                        case MixPose.current:\n                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                            constraint.bendDirection = constraint.data.bendDirection;\n                    }\n                    return;\n                }\n                if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\n                    if (pose == MixPose.setup) {\n                        constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                        constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    } else {\n                        constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                        if (direction == MixDirection.in) constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    }\n                    return;\n                }\n                var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n                var mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n                if (pose == MixPose.setup) {\n                    constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n                    constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                } else {\n                    constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n                    if (direction == MixDirection.in) constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                }\n            };\n            return IkConstraintTimeline;\n        }(CurveTimeline);\n        IkConstraintTimeline.ENTRIES = 3;\n        IkConstraintTimeline.PREV_TIME = -3;\n        IkConstraintTimeline.PREV_MIX = -2;\n        IkConstraintTimeline.PREV_BEND_DIRECTION = -1;\n        IkConstraintTimeline.MIX = 1;\n        IkConstraintTimeline.BEND_DIRECTION = 2;\n        core.IkConstraintTimeline = IkConstraintTimeline;\n        var TransformConstraintTimeline = function (_super) {\n            __extends(TransformConstraintTimeline, _super);\n            function TransformConstraintTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n                return _this;\n            }\n            TransformConstraintTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n            };\n            TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\n                frameIndex *= TransformConstraintTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n                this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n                this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n                this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n            };\n            TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n                if (time < frames[0]) {\n                    var data = constraint.data;\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.rotateMix = data.rotateMix;\n                            constraint.translateMix = data.translateMix;\n                            constraint.scaleMix = data.scaleMix;\n                            constraint.shearMix = data.shearMix;\n                            return;\n                        case MixPose.current:\n                            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n                    }\n                    return;\n                }\n                var rotate = 0,\n                    translate = 0,\n                    scale = 0,\n                    shear = 0;\n                if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\n                    var i = frames.length;\n                    rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n                    translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n                    scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n                    shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n                    rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n                    translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n                    scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n                    shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n                    rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n                    translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n                    scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n                    shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n                }\n                if (pose == MixPose.setup) {\n                    var data = constraint.data;\n                    constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n                    constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n                    constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n                    constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n                } else {\n                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (translate - constraint.translateMix) * alpha;\n                    constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n                    constraint.shearMix += (shear - constraint.shearMix) * alpha;\n                }\n            };\n            return TransformConstraintTimeline;\n        }(CurveTimeline);\n        TransformConstraintTimeline.ENTRIES = 5;\n        TransformConstraintTimeline.PREV_TIME = -5;\n        TransformConstraintTimeline.PREV_ROTATE = -4;\n        TransformConstraintTimeline.PREV_TRANSLATE = -3;\n        TransformConstraintTimeline.PREV_SCALE = -2;\n        TransformConstraintTimeline.PREV_SHEAR = -1;\n        TransformConstraintTimeline.ROTATE = 1;\n        TransformConstraintTimeline.TRANSLATE = 2;\n        TransformConstraintTimeline.SCALE = 3;\n        TransformConstraintTimeline.SHEAR = 4;\n        core.TransformConstraintTimeline = TransformConstraintTimeline;\n        var PathConstraintPositionTimeline = function (_super) {\n            __extends(PathConstraintPositionTimeline, _super);\n            function PathConstraintPositionTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n                return _this;\n            }\n            PathConstraintPositionTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n            };\n            PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\n                frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n            };\n            PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.position = constraint.data.position;\n                            return;\n                        case MixPose.current:\n                            constraint.position += (constraint.data.position - constraint.position) * alpha;\n                    }\n                    return;\n                }\n                var position = 0;\n                if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];else {\n                    var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n                    position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n                    position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n                }\n                if (pose == MixPose.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;else constraint.position += (position - constraint.position) * alpha;\n            };\n            return PathConstraintPositionTimeline;\n        }(CurveTimeline);\n        PathConstraintPositionTimeline.ENTRIES = 2;\n        PathConstraintPositionTimeline.PREV_TIME = -2;\n        PathConstraintPositionTimeline.PREV_VALUE = -1;\n        PathConstraintPositionTimeline.VALUE = 1;\n        core.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\n        var PathConstraintSpacingTimeline = function (_super) {\n            __extends(PathConstraintSpacingTimeline, _super);\n            function PathConstraintSpacingTimeline(frameCount) {\n                return _super.call(this, frameCount) || this;\n            }\n            PathConstraintSpacingTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n            };\n            PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.spacing = constraint.data.spacing;\n                            return;\n                        case MixPose.current:\n                            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n                    }\n                    return;\n                }\n                var spacing = 0;\n                if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];else {\n                    var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n                    spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n                    spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n                }\n                if (pose == MixPose.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;else constraint.spacing += (spacing - constraint.spacing) * alpha;\n            };\n            return PathConstraintSpacingTimeline;\n        }(PathConstraintPositionTimeline);\n        core.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\n        var PathConstraintMixTimeline = function (_super) {\n            __extends(PathConstraintMixTimeline, _super);\n            function PathConstraintMixTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n                return _this;\n            }\n            PathConstraintMixTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n            };\n            PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\n                frameIndex *= PathConstraintMixTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n                this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n            };\n            PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.rotateMix = constraint.data.rotateMix;\n                            constraint.translateMix = constraint.data.translateMix;\n                            return;\n                        case MixPose.current:\n                            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n                    }\n                    return;\n                }\n                var rotate = 0,\n                    translate = 0;\n                if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\n                    rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n                    translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n                    rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n                    translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n                    rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n                    translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n                }\n                if (pose == MixPose.setup) {\n                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n                } else {\n                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (translate - constraint.translateMix) * alpha;\n                }\n            };\n            return PathConstraintMixTimeline;\n        }(CurveTimeline);\n        PathConstraintMixTimeline.ENTRIES = 3;\n        PathConstraintMixTimeline.PREV_TIME = -3;\n        PathConstraintMixTimeline.PREV_ROTATE = -2;\n        PathConstraintMixTimeline.PREV_TRANSLATE = -1;\n        PathConstraintMixTimeline.ROTATE = 1;\n        PathConstraintMixTimeline.TRANSLATE = 2;\n        core.PathConstraintMixTimeline = PathConstraintMixTimeline;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var AnimationState = function () {\n            function AnimationState(data) {\n                this.tracks = new Array();\n                this.events = new Array();\n                this.listeners = new Array();\n                this.queue = new EventQueue(this);\n                this.propertyIDs = new core.IntSet();\n                this.mixingTo = new Array();\n                this.animationsChanged = false;\n                this.timeScale = 1;\n                this.trackEntryPool = new core.Pool(function () {\n                    return new TrackEntry();\n                });\n                this.data = data;\n            }\n            AnimationState.prototype.update = function (delta) {\n                delta *= this.timeScale;\n                var tracks = this.tracks;\n                for (var i = 0, n = tracks.length; i < n; i++) {\n                    var current = tracks[i];\n                    if (current == null) continue;\n                    current.animationLast = current.nextAnimationLast;\n                    current.trackLast = current.nextTrackLast;\n                    var currentDelta = delta * current.timeScale;\n                    if (current.delay > 0) {\n                        current.delay -= currentDelta;\n                        if (current.delay > 0) continue;\n                        currentDelta = -current.delay;\n                        current.delay = 0;\n                    }\n                    var next = current.next;\n                    if (next != null) {\n                        var nextTime = current.trackLast - next.delay;\n                        if (nextTime >= 0) {\n                            next.delay = 0;\n                            next.trackTime = nextTime + delta * next.timeScale;\n                            current.trackTime += currentDelta;\n                            this.setCurrent(i, next, true);\n                            while (next.mixingFrom != null) {\n                                next.mixTime += currentDelta;\n                                next = next.mixingFrom;\n                            }\n                            continue;\n                        }\n                    } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                        tracks[i] = null;\n                        this.queue.end(current);\n                        this.disposeNext(current);\n                        continue;\n                    }\n                    if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                        var from = current.mixingFrom;\n                        current.mixingFrom = null;\n                        while (from != null) {\n                            this.queue.end(from);\n                            from = from.mixingFrom;\n                        }\n                    }\n                    current.trackTime += currentDelta;\n                }\n                this.queue.drain();\n            };\n            AnimationState.prototype.updateMixingFrom = function (to, delta) {\n                var from = to.mixingFrom;\n                if (from == null) return true;\n                var finished = this.updateMixingFrom(from, delta);\n                if (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {\n                    if (from.totalAlpha == 0) {\n                        to.mixingFrom = from.mixingFrom;\n                        to.interruptAlpha = from.interruptAlpha;\n                        this.queue.end(from);\n                    }\n                    return finished;\n                }\n                from.animationLast = from.nextAnimationLast;\n                from.trackLast = from.nextTrackLast;\n                from.trackTime += delta * from.timeScale;\n                to.mixTime += delta * to.timeScale;\n                return false;\n            };\n            AnimationState.prototype.apply = function (skeleton) {\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                if (this.animationsChanged) this._animationsChanged();\n                var events = this.events;\n                var tracks = this.tracks;\n                var applied = false;\n                for (var i = 0, n = tracks.length; i < n; i++) {\n                    var current = tracks[i];\n                    if (current == null || current.delay > 0) continue;\n                    applied = true;\n                    var currentPose = i == 0 ? core.MixPose.current : core.MixPose.currentLayered;\n                    var mix = current.alpha;\n                    if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, currentPose);else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;\n                    var animationLast = current.animationLast,\n                        animationTime = current.getAnimationTime();\n                    var timelineCount = current.animation.timelines.length;\n                    var timelines = current.animation.timelines;\n                    if (mix == 1) {\n                        for (var ii = 0; ii < timelineCount; ii++) {\n                            timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, core.MixPose.setup, core.MixDirection.in);\n                        }\n                    } else {\n                        var timelineData = current.timelineData;\n                        var firstFrame = current.timelinesRotation.length == 0;\n                        if (firstFrame) core.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                        var timelinesRotation = current.timelinesRotation;\n                        for (var ii = 0; ii < timelineCount; ii++) {\n                            var timeline = timelines[ii];\n                            var pose = timelineData[ii] >= AnimationState.FIRST ? core.MixPose.setup : currentPose;\n                            if (timeline instanceof core.RotateTimeline) {\n                                this.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);\n                            } else timeline.apply(skeleton, animationLast, animationTime, events, mix, pose, core.MixDirection.in);\n                        }\n                    }\n                    this.queueEvents(current, animationTime);\n                    events.length = 0;\n                    current.nextAnimationLast = animationTime;\n                    current.nextTrackLast = current.trackTime;\n                }\n                this.queue.drain();\n                return applied;\n            };\n            AnimationState.prototype.applyMixingFrom = function (to, skeleton, currentPose) {\n                var from = to.mixingFrom;\n                if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, currentPose);\n                var mix = 0;\n                if (to.mixDuration == 0) mix = 1;else {\n                    mix = to.mixTime / to.mixDuration;\n                    if (mix > 1) mix = 1;\n                }\n                var events = mix < from.eventThreshold ? this.events : null;\n                var attachments = mix < from.attachmentThreshold,\n                    drawOrder = mix < from.drawOrderThreshold;\n                var animationLast = from.animationLast,\n                    animationTime = from.getAnimationTime();\n                var timelineCount = from.animation.timelines.length;\n                var timelines = from.animation.timelines;\n                var timelineData = from.timelineData;\n                var timelineDipMix = from.timelineDipMix;\n                var firstFrame = from.timelinesRotation.length == 0;\n                if (firstFrame) core.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n                var timelinesRotation = from.timelinesRotation;\n                var pose;\n                var alphaDip = from.alpha * to.interruptAlpha,\n                    alphaMix = alphaDip * (1 - mix),\n                    alpha = 0;\n                from.totalAlpha = 0;\n                for (var i = 0; i < timelineCount; i++) {\n                    var timeline = timelines[i];\n                    switch (timelineData[i]) {\n                        case AnimationState.SUBSEQUENT:\n                            if (!attachments && timeline instanceof core.AttachmentTimeline) continue;\n                            if (!drawOrder && timeline instanceof core.DrawOrderTimeline) continue;\n                            pose = currentPose;\n                            alpha = alphaMix;\n                            break;\n                        case AnimationState.FIRST:\n                            pose = core.MixPose.setup;\n                            alpha = alphaMix;\n                            break;\n                        case AnimationState.DIP:\n                            pose = core.MixPose.setup;\n                            alpha = alphaDip;\n                            break;\n                        default:\n                            pose = core.MixPose.setup;\n                            alpha = alphaDip;\n                            var dipMix = timelineDipMix[i];\n                            alpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);\n                            break;\n                    }\n                    from.totalAlpha += alpha;\n                    if (timeline instanceof core.RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);else {\n                        timeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, core.MixDirection.out);\n                    }\n                }\n                if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n                this.events.length = 0;\n                from.nextAnimationLast = animationTime;\n                from.nextTrackLast = from.trackTime;\n                return mix;\n            };\n            AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, pose, timelinesRotation, i, firstFrame) {\n                if (firstFrame) timelinesRotation[i] = 0;\n                if (alpha == 1) {\n                    timeline.apply(skeleton, 0, time, null, 1, pose, core.MixDirection.in);\n                    return;\n                }\n                var rotateTimeline = timeline;\n                var frames = rotateTimeline.frames;\n                var bone = skeleton.bones[rotateTimeline.boneIndex];\n                if (time < frames[0]) {\n                    if (pose == core.MixPose.setup) bone.rotation = bone.data.rotation;\n                    return;\n                }\n                var r2 = 0;\n                if (time >= frames[frames.length - core.RotateTimeline.ENTRIES]) r2 = bone.data.rotation + frames[frames.length + core.RotateTimeline.PREV_ROTATION];else {\n                    var frame = core.Animation.binarySearch(frames, time, core.RotateTimeline.ENTRIES);\n                    var prevRotation = frames[frame + core.RotateTimeline.PREV_ROTATION];\n                    var frameTime = frames[frame];\n                    var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + core.RotateTimeline.PREV_TIME] - frameTime));\n                    r2 = frames[frame + core.RotateTimeline.ROTATION] - prevRotation;\n                    r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n                    r2 = prevRotation + r2 * percent + bone.data.rotation;\n                    r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n                }\n                var r1 = pose == core.MixPose.setup ? bone.data.rotation : bone.rotation;\n                var total = 0,\n                    diff = r2 - r1;\n                if (diff == 0) {\n                    total = timelinesRotation[i];\n                } else {\n                    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n                    var lastTotal = 0,\n                        lastDiff = 0;\n                    if (firstFrame) {\n                        lastTotal = 0;\n                        lastDiff = diff;\n                    } else {\n                        lastTotal = timelinesRotation[i];\n                        lastDiff = timelinesRotation[i + 1];\n                    }\n                    var current = diff > 0,\n                        dir = lastTotal >= 0;\n                    if (core.MathUtils.signum(lastDiff) != core.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                        if (Math.abs(lastTotal) > 180) lastTotal += 360 * core.MathUtils.signum(lastTotal);\n                        dir = current;\n                    }\n                    total = diff + lastTotal - lastTotal % 360;\n                    if (dir != current) total += 360 * core.MathUtils.signum(lastTotal);\n                    timelinesRotation[i] = total;\n                }\n                timelinesRotation[i + 1] = diff;\n                r1 += total * alpha;\n                bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;\n            };\n            AnimationState.prototype.queueEvents = function (entry, animationTime) {\n                var animationStart = entry.animationStart,\n                    animationEnd = entry.animationEnd;\n                var duration = animationEnd - animationStart;\n                var trackLastWrapped = entry.trackLast % duration;\n                var events = this.events;\n                var i = 0,\n                    n = events.length;\n                for (; i < n; i++) {\n                    var event_1 = events[i];\n                    if (event_1.time < trackLastWrapped) break;\n                    if (event_1.time > animationEnd) continue;\n                    this.queue.event(entry, event_1);\n                }\n                if (entry.loop ? trackLastWrapped > entry.trackTime % duration : animationTime >= animationEnd && entry.animationLast < animationEnd) {\n                    this.queue.complete(entry);\n                }\n                for (; i < n; i++) {\n                    var event_2 = events[i];\n                    if (event_2.time < animationStart) continue;\n                    this.queue.event(entry, events[i]);\n                }\n            };\n            AnimationState.prototype.clearTracks = function () {\n                var oldDrainDisabled = this.queue.drainDisabled;\n                this.queue.drainDisabled = true;\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\n                    this.clearTrack(i);\n                }this.tracks.length = 0;\n                this.queue.drainDisabled = oldDrainDisabled;\n                this.queue.drain();\n            };\n            AnimationState.prototype.clearTrack = function (trackIndex) {\n                if (trackIndex >= this.tracks.length) return;\n                var current = this.tracks[trackIndex];\n                if (current == null) return;\n                this.queue.end(current);\n                this.disposeNext(current);\n                var entry = current;\n                while (true) {\n                    var from = entry.mixingFrom;\n                    if (from == null) break;\n                    this.queue.end(from);\n                    entry.mixingFrom = null;\n                    entry = from;\n                }\n                this.tracks[current.trackIndex] = null;\n                this.queue.drain();\n            };\n            AnimationState.prototype.setCurrent = function (index, current, interrupt) {\n                var from = this.expandToIndex(index);\n                this.tracks[index] = current;\n                if (from != null) {\n                    if (interrupt) this.queue.interrupt(from);\n                    current.mixingFrom = from;\n                    current.mixTime = 0;\n                    if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n                    from.timelinesRotation.length = 0;\n                }\n                this.queue.start(current);\n            };\n            AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\n                var animation = this.data.skeletonData.findAnimation(animationName);\n                if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n                return this.setAnimationWith(trackIndex, animation, loop);\n            };\n            AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\n                if (animation == null) throw new Error(\"animation cannot be null.\");\n                var interrupt = true;\n                var current = this.expandToIndex(trackIndex);\n                if (current != null) {\n                    if (current.nextTrackLast == -1) {\n                        this.tracks[trackIndex] = current.mixingFrom;\n                        this.queue.interrupt(current);\n                        this.queue.end(current);\n                        this.disposeNext(current);\n                        current = current.mixingFrom;\n                        interrupt = false;\n                    } else this.disposeNext(current);\n                }\n                var entry = this.trackEntry(trackIndex, animation, loop, current);\n                this.setCurrent(trackIndex, entry, interrupt);\n                this.queue.drain();\n                return entry;\n            };\n            AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\n                var animation = this.data.skeletonData.findAnimation(animationName);\n                if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n                return this.addAnimationWith(trackIndex, animation, loop, delay);\n            };\n            AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\n                if (animation == null) throw new Error(\"animation cannot be null.\");\n                var last = this.expandToIndex(trackIndex);\n                if (last != null) {\n                    while (last.next != null) {\n                        last = last.next;\n                    }\n                }\n                var entry = this.trackEntry(trackIndex, animation, loop, last);\n                if (last == null) {\n                    this.setCurrent(trackIndex, entry, true);\n                    this.queue.drain();\n                } else {\n                    last.next = entry;\n                    if (delay <= 0) {\n                        var duration = last.animationEnd - last.animationStart;\n                        if (duration != 0) delay += duration * (1 + (last.trackTime / duration | 0)) - this.data.getMix(last.animation, animation);else delay = 0;\n                    }\n                }\n                entry.delay = delay;\n                return entry;\n            };\n            AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\n                var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n                entry.mixDuration = mixDuration;\n                entry.trackEnd = mixDuration;\n                return entry;\n            };\n            AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\n                if (delay <= 0) delay -= mixDuration;\n                var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n                entry.mixDuration = mixDuration;\n                entry.trackEnd = mixDuration;\n                return entry;\n            };\n            AnimationState.prototype.setEmptyAnimations = function (mixDuration) {\n                var oldDrainDisabled = this.queue.drainDisabled;\n                this.queue.drainDisabled = true;\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\n                    var current = this.tracks[i];\n                    if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n                }\n                this.queue.drainDisabled = oldDrainDisabled;\n                this.queue.drain();\n            };\n            AnimationState.prototype.expandToIndex = function (index) {\n                if (index < this.tracks.length) return this.tracks[index];\n                core.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\n                this.tracks.length = index + 1;\n                return null;\n            };\n            AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\n                var entry = this.trackEntryPool.obtain();\n                entry.trackIndex = trackIndex;\n                entry.animation = animation;\n                entry.loop = loop;\n                entry.eventThreshold = 0;\n                entry.attachmentThreshold = 0;\n                entry.drawOrderThreshold = 0;\n                entry.animationStart = 0;\n                entry.animationEnd = animation.duration;\n                entry.animationLast = -1;\n                entry.nextAnimationLast = -1;\n                entry.delay = 0;\n                entry.trackTime = 0;\n                entry.trackLast = -1;\n                entry.nextTrackLast = -1;\n                entry.trackEnd = Number.MAX_VALUE;\n                entry.timeScale = 1;\n                entry.alpha = 1;\n                entry.interruptAlpha = 1;\n                entry.mixTime = 0;\n                entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n                return entry;\n            };\n            AnimationState.prototype.disposeNext = function (entry) {\n                var next = entry.next;\n                while (next != null) {\n                    this.queue.dispose(next);\n                    next = next.next;\n                }\n                entry.next = null;\n            };\n            AnimationState.prototype._animationsChanged = function () {\n                this.animationsChanged = false;\n                var propertyIDs = this.propertyIDs;\n                propertyIDs.clear();\n                var mixingTo = this.mixingTo;\n                var lastEntry = null;\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\n                    var entry = this.tracks[i];\n                    if (entry != null) entry.setTimelineData(null, mixingTo, propertyIDs);\n                }\n            };\n            AnimationState.prototype.getCurrent = function (trackIndex) {\n                if (trackIndex >= this.tracks.length) return null;\n                return this.tracks[trackIndex];\n            };\n            AnimationState.prototype.addListener = function (listener) {\n                if (listener == null) throw new Error(\"listener cannot be null.\");\n                this.listeners.push(listener);\n            };\n            AnimationState.prototype.removeListener = function (listener) {\n                var index = this.listeners.indexOf(listener);\n                if (index >= 0) this.listeners.splice(index, 1);\n            };\n            AnimationState.prototype.clearListeners = function () {\n                this.listeners.length = 0;\n            };\n            AnimationState.prototype.clearListenerNotifications = function () {\n                this.queue.clear();\n            };\n            AnimationState.prototype.setAnimationByName = function (trackIndex, animationName, loop) {\n                if (!AnimationState.deprecatedWarning1) {\n                    AnimationState.deprecatedWarning1 = true;\n                    console.warn(\"Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n                }\n                this.setAnimation(trackIndex, animationName, loop);\n            };\n            AnimationState.prototype.addAnimationByName = function (trackIndex, animationName, loop, delay) {\n                if (!AnimationState.deprecatedWarning2) {\n                    AnimationState.deprecatedWarning2 = true;\n                    console.warn(\"Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n                }\n                this.addAnimation(trackIndex, animationName, loop, delay);\n            };\n            AnimationState.prototype.hasAnimation = function (animationName) {\n                var animation = this.data.skeletonData.findAnimation(animationName);\n                return animation !== null;\n            };\n            AnimationState.prototype.hasAnimationByName = function (animationName) {\n                if (!AnimationState.deprecatedWarning3) {\n                    AnimationState.deprecatedWarning3 = true;\n                    console.warn(\"Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n                }\n                return this.hasAnimation(animationName);\n            };\n            return AnimationState;\n        }();\n        AnimationState.emptyAnimation = new core.Animation(\"<empty>\", [], 0);\n        AnimationState.SUBSEQUENT = 0;\n        AnimationState.FIRST = 1;\n        AnimationState.DIP = 2;\n        AnimationState.DIP_MIX = 3;\n        AnimationState.deprecatedWarning1 = false;\n        AnimationState.deprecatedWarning2 = false;\n        AnimationState.deprecatedWarning3 = false;\n        core.AnimationState = AnimationState;\n        var TrackEntry = function () {\n            function TrackEntry() {\n                this.timelineData = new Array();\n                this.timelineDipMix = new Array();\n                this.timelinesRotation = new Array();\n            }\n            TrackEntry.prototype.reset = function () {\n                this.next = null;\n                this.mixingFrom = null;\n                this.animation = null;\n                this.listener = null;\n                this.timelineData.length = 0;\n                this.timelineDipMix.length = 0;\n                this.timelinesRotation.length = 0;\n            };\n            TrackEntry.prototype.setTimelineData = function (to, mixingToArray, propertyIDs) {\n                if (to != null) mixingToArray.push(to);\n                var lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;\n                if (to != null) mixingToArray.pop();\n                var mixingTo = mixingToArray;\n                var mixingToLast = mixingToArray.length - 1;\n                var timelines = this.animation.timelines;\n                var timelinesCount = this.animation.timelines.length;\n                var timelineData = core.Utils.setArraySize(this.timelineData, timelinesCount);\n                this.timelineDipMix.length = 0;\n                var timelineDipMix = core.Utils.setArraySize(this.timelineDipMix, timelinesCount);\n                outer: for (var i = 0; i < timelinesCount; i++) {\n                    var id = timelines[i].getPropertyId();\n                    if (!propertyIDs.add(id)) timelineData[i] = AnimationState.SUBSEQUENT;else if (to == null || !to.hasTimeline(id)) timelineData[i] = AnimationState.FIRST;else {\n                        for (var ii = mixingToLast; ii >= 0; ii--) {\n                            var entry = mixingTo[ii];\n                            if (!entry.hasTimeline(id)) {\n                                if (entry.mixDuration > 0) {\n                                    timelineData[i] = AnimationState.DIP_MIX;\n                                    timelineDipMix[i] = entry;\n                                    continue outer;\n                                }\n                            }\n                        }\n                        timelineData[i] = AnimationState.DIP;\n                    }\n                }\n                return lastEntry;\n            };\n            TrackEntry.prototype.hasTimeline = function (id) {\n                var timelines = this.animation.timelines;\n                for (var i = 0, n = timelines.length; i < n; i++) {\n                    if (timelines[i].getPropertyId() == id) return true;\n                }return false;\n            };\n            TrackEntry.prototype.getAnimationTime = function () {\n                if (this.loop) {\n                    var duration = this.animationEnd - this.animationStart;\n                    if (duration == 0) return this.animationStart;\n                    return this.trackTime % duration + this.animationStart;\n                }\n                return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n            };\n            TrackEntry.prototype.setAnimationLast = function (animationLast) {\n                this.animationLast = animationLast;\n                this.nextAnimationLast = animationLast;\n            };\n            TrackEntry.prototype.isComplete = function () {\n                return this.trackTime >= this.animationEnd - this.animationStart;\n            };\n            TrackEntry.prototype.resetRotationDirections = function () {\n                this.timelinesRotation.length = 0;\n            };\n            Object.defineProperty(TrackEntry.prototype, \"time\", {\n                get: function get() {\n                    if (!TrackEntry.deprecatedWarning1) {\n                        TrackEntry.deprecatedWarning1 = true;\n                        console.warn(\"Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n                    }\n                    return this.trackTime;\n                },\n                set: function set(value) {\n                    if (!TrackEntry.deprecatedWarning1) {\n                        TrackEntry.deprecatedWarning1 = true;\n                        console.warn(\"Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n                    }\n                    this.trackTime = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TrackEntry.prototype, \"endTime\", {\n                get: function get() {\n                    if (!TrackEntry.deprecatedWarning2) {\n                        TrackEntry.deprecatedWarning2 = true;\n                        console.warn(\"Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n                    }\n                    return this.trackTime;\n                },\n                set: function set(value) {\n                    if (!TrackEntry.deprecatedWarning2) {\n                        TrackEntry.deprecatedWarning2 = true;\n                        console.warn(\"Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n                    }\n                    this.trackTime = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            TrackEntry.prototype.loopsCount = function () {\n                return Math.floor(this.trackTime / this.trackEnd);\n            };\n            return TrackEntry;\n        }();\n        TrackEntry.deprecatedWarning1 = false;\n        TrackEntry.deprecatedWarning2 = false;\n        core.TrackEntry = TrackEntry;\n        var EventQueue = function () {\n            function EventQueue(animState) {\n                this.objects = [];\n                this.drainDisabled = false;\n                this.animState = animState;\n            }\n            EventQueue.prototype.start = function (entry) {\n                this.objects.push(EventType.start);\n                this.objects.push(entry);\n                this.animState.animationsChanged = true;\n            };\n            EventQueue.prototype.interrupt = function (entry) {\n                this.objects.push(EventType.interrupt);\n                this.objects.push(entry);\n            };\n            EventQueue.prototype.end = function (entry) {\n                this.objects.push(EventType.end);\n                this.objects.push(entry);\n                this.animState.animationsChanged = true;\n            };\n            EventQueue.prototype.dispose = function (entry) {\n                this.objects.push(EventType.dispose);\n                this.objects.push(entry);\n            };\n            EventQueue.prototype.complete = function (entry) {\n                this.objects.push(EventType.complete);\n                this.objects.push(entry);\n            };\n            EventQueue.prototype.event = function (entry, event) {\n                this.objects.push(EventType.event);\n                this.objects.push(entry);\n                this.objects.push(event);\n            };\n            EventQueue.prototype.deprecateStuff = function () {\n                if (!EventQueue.deprecatedWarning1) {\n                    EventQueue.deprecatedWarning1 = true;\n                    console.warn(\"Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\n                }\n                return true;\n            };\n            EventQueue.prototype.drain = function () {\n                if (this.drainDisabled) return;\n                this.drainDisabled = true;\n                var objects = this.objects;\n                var listeners = this.animState.listeners;\n                for (var i = 0; i < objects.length; i += 2) {\n                    var type = objects[i];\n                    var entry = objects[i + 1];\n                    switch (type) {\n                        case EventType.start:\n                            if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].start) listeners[ii].start(entry);\n                            }entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                            break;\n                        case EventType.interrupt:\n                            if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                            }break;\n                        case EventType.end:\n                            if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].end) listeners[ii].end(entry);\n                            }entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                        case EventType.dispose:\n                            if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                            }this.animState.trackEntryPool.free(entry);\n                            break;\n                        case EventType.complete:\n                            if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].complete) listeners[ii].complete(entry);\n                            }var count = core.MathUtils.toInt(entry.loopsCount());\n                            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                            break;\n                        case EventType.event:\n                            var event_3 = objects[i++ + 2];\n                            if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event_3);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].event) listeners[ii].event(entry, event_3);\n                            }entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);\n                            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);\n                            break;\n                    }\n                }\n                this.clear();\n                this.drainDisabled = false;\n            };\n            EventQueue.prototype.clear = function () {\n                this.objects.length = 0;\n            };\n            return EventQueue;\n        }();\n        EventQueue.deprecatedWarning1 = false;\n        core.EventQueue = EventQueue;\n        var EventType;\n        (function (EventType) {\n            EventType[EventType[\"start\"] = 0] = \"start\";\n            EventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\n            EventType[EventType[\"end\"] = 2] = \"end\";\n            EventType[EventType[\"dispose\"] = 3] = \"dispose\";\n            EventType[EventType[\"complete\"] = 4] = \"complete\";\n            EventType[EventType[\"event\"] = 5] = \"event\";\n        })(EventType = core.EventType || (core.EventType = {}));\n        var AnimationStateAdapter2 = function () {\n            function AnimationStateAdapter2() {}\n            AnimationStateAdapter2.prototype.start = function (entry) {};\n            AnimationStateAdapter2.prototype.interrupt = function (entry) {};\n            AnimationStateAdapter2.prototype.end = function (entry) {};\n            AnimationStateAdapter2.prototype.dispose = function (entry) {};\n            AnimationStateAdapter2.prototype.complete = function (entry) {};\n            AnimationStateAdapter2.prototype.event = function (entry, event) {};\n            return AnimationStateAdapter2;\n        }();\n        core.AnimationStateAdapter2 = AnimationStateAdapter2;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var AnimationStateData = function () {\n            function AnimationStateData(skeletonData) {\n                this.animationToMixTime = {};\n                this.defaultMix = 0;\n                if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n                this.skeletonData = skeletonData;\n            }\n            AnimationStateData.prototype.setMix = function (fromName, toName, duration) {\n                var from = this.skeletonData.findAnimation(fromName);\n                if (from == null) throw new Error(\"Animation not found: \" + fromName);\n                var to = this.skeletonData.findAnimation(toName);\n                if (to == null) throw new Error(\"Animation not found: \" + toName);\n                this.setMixWith(from, to, duration);\n            };\n            AnimationStateData.prototype.setMixByName = function (fromName, toName, duration) {\n                if (!AnimationStateData.deprecatedWarning1) {\n                    AnimationStateData.deprecatedWarning1 = true;\n                    console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n                }\n                this.setMix(fromName, toName, duration);\n            };\n            AnimationStateData.prototype.setMixWith = function (from, to, duration) {\n                if (from == null) throw new Error(\"from cannot be null.\");\n                if (to == null) throw new Error(\"to cannot be null.\");\n                var key = from.name + to.name;\n                this.animationToMixTime[key] = duration;\n            };\n            AnimationStateData.prototype.getMix = function (from, to) {\n                var key = from.name + to.name;\n                var value = this.animationToMixTime[key];\n                return value === undefined ? this.defaultMix : value;\n            };\n            return AnimationStateData;\n        }();\n        AnimationStateData.deprecatedWarning1 = false;\n        core.AnimationStateData = AnimationStateData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var AtlasAttachmentLoader = function () {\n            function AtlasAttachmentLoader(atlas) {\n                this.atlas = atlas;\n            }\n            AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\n                var region = this.atlas.findRegion(path);\n                if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n                var attachment = new core.RegionAttachment(name);\n                attachment.region = region;\n                return attachment;\n            };\n            AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\n                var region = this.atlas.findRegion(path);\n                if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n                var attachment = new core.MeshAttachment(name);\n                attachment.region = region;\n                return attachment;\n            };\n            AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\n                return new core.BoundingBoxAttachment(name);\n            };\n            AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\n                return new core.PathAttachment(name);\n            };\n            AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\n                return new core.PointAttachment(name);\n            };\n            AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\n                return new core.ClippingAttachment(name);\n            };\n            return AtlasAttachmentLoader;\n        }();\n        core.AtlasAttachmentLoader = AtlasAttachmentLoader;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Attachment = function () {\n            function Attachment(name) {\n                if (name == null) throw new Error(\"name cannot be null.\");\n                this.name = name;\n            }\n            return Attachment;\n        }();\n        core.Attachment = Attachment;\n        var VertexAttachment = function (_super) {\n            __extends(VertexAttachment, _super);\n            function VertexAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.id = (VertexAttachment.nextID++ & 65535) << 11;\n                _this.worldVerticesLength = 0;\n                return _this;\n            }\n            VertexAttachment.prototype.computeWorldVerticesOld = function (slot, worldVertices) {\n                this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n            };\n            VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\n                count = offset + (count >> 1) * stride;\n                var skeleton = slot.bone.skeleton;\n                var deformArray = slot.attachmentVertices;\n                var vertices = this.vertices;\n                var bones = this.bones;\n                if (bones == null) {\n                    if (deformArray.length > 0) vertices = deformArray;\n                    var mat = slot.bone.matrix;\n                    var x = mat.tx;\n                    var y = mat.ty;\n                    var a = mat.a,\n                        b = mat.c,\n                        c = mat.b,\n                        d = mat.d;\n                    for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\n                        var vx = vertices[v_1],\n                            vy = vertices[v_1 + 1];\n                        worldVertices[w] = vx * a + vy * b + x;\n                        worldVertices[w + 1] = vx * c + vy * d + y;\n                    }\n                    return;\n                }\n                var v = 0,\n                    skip = 0;\n                for (var i = 0; i < start; i += 2) {\n                    var n = bones[v];\n                    v += n + 1;\n                    skip += n;\n                }\n                var skeletonBones = skeleton.bones;\n                if (deformArray.length == 0) {\n                    for (var w = offset, b = skip * 3; w < count; w += stride) {\n                        var wx = 0,\n                            wy = 0;\n                        var n = bones[v++];\n                        n += v;\n                        for (; v < n; v++, b += 3) {\n                            var mat = skeletonBones[bones[v]].matrix;\n                            var vx = vertices[b],\n                                vy = vertices[b + 1],\n                                weight = vertices[b + 2];\n                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                        }\n                        worldVertices[w] = wx;\n                        worldVertices[w + 1] = wy;\n                    }\n                } else {\n                    var deform = deformArray;\n                    for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                        var wx = 0,\n                            wy = 0;\n                        var n = bones[v++];\n                        n += v;\n                        for (; v < n; v++, b += 3, f += 2) {\n                            var mat = skeletonBones[bones[v]].matrix;\n                            var vx = vertices[b] + deform[f],\n                                vy = vertices[b + 1] + deform[f + 1],\n                                weight = vertices[b + 2];\n                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                        }\n                        worldVertices[w] = wx;\n                        worldVertices[w + 1] = wy;\n                    }\n                }\n            };\n            VertexAttachment.prototype.applyDeform = function (sourceAttachment) {\n                return this == sourceAttachment;\n            };\n            return VertexAttachment;\n        }(Attachment);\n        VertexAttachment.nextID = 0;\n        core.VertexAttachment = VertexAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var AttachmentType;\n        (function (AttachmentType) {\n            AttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\n            AttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\n            AttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\n            AttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\n            AttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\n            AttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\n        })(AttachmentType = core.AttachmentType || (core.AttachmentType = {}));\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var BoundingBoxAttachment = function (_super) {\n            __extends(BoundingBoxAttachment, _super);\n            function BoundingBoxAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.color = new core.Color(1, 1, 1, 1);\n                return _this;\n            }\n            return BoundingBoxAttachment;\n        }(core.VertexAttachment);\n        core.BoundingBoxAttachment = BoundingBoxAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var ClippingAttachment = function (_super) {\n            __extends(ClippingAttachment, _super);\n            function ClippingAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.color = new core.Color(0.2275, 0.2275, 0.8078, 1);\n                return _this;\n            }\n            return ClippingAttachment;\n        }(core.VertexAttachment);\n        core.ClippingAttachment = ClippingAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var MeshAttachment = function (_super) {\n            __extends(MeshAttachment, _super);\n            function MeshAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.color = new core.Color(1, 1, 1, 1);\n                _this.inheritDeform = false;\n                _this.tempColor = new core.Color(0, 0, 0, 0);\n                return _this;\n            }\n            MeshAttachment.prototype.updateUVs = function (region, uvs) {\n                var regionUVs = this.regionUVs;\n                var n = regionUVs.length;\n                if (!uvs || uvs.length != n) {\n                    uvs = core.Utils.newFloatArray(n);\n                }\n                if (region == null) {\n                    return;\n                }\n                var texture = region.texture;\n                var r = texture._uvs;\n                var w1 = region.width,\n                    h1 = region.height,\n                    w2 = region.originalWidth,\n                    h2 = region.originalHeight;\n                var x = region.offsetX,\n                    y = region.pixiOffsetY;\n                for (var i = 0; i < n; i += 2) {\n                    var u = this.regionUVs[i],\n                        v = this.regionUVs[i + 1];\n                    u = (u * w2 - x) / w1;\n                    v = (v * h2 - y) / h1;\n                    uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n                    uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n                }\n                return uvs;\n            };\n            MeshAttachment.prototype.applyDeform = function (sourceAttachment) {\n                return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;\n            };\n            MeshAttachment.prototype.getParentMesh = function () {\n                return this.parentMesh;\n            };\n            MeshAttachment.prototype.setParentMesh = function (parentMesh) {\n                this.parentMesh = parentMesh;\n                if (parentMesh != null) {\n                    this.bones = parentMesh.bones;\n                    this.vertices = parentMesh.vertices;\n                    this.worldVerticesLength = parentMesh.worldVerticesLength;\n                    this.regionUVs = parentMesh.regionUVs;\n                    this.triangles = parentMesh.triangles;\n                    this.hullLength = parentMesh.hullLength;\n                    this.worldVerticesLength = parentMesh.worldVerticesLength;\n                }\n            };\n            return MeshAttachment;\n        }(core.VertexAttachment);\n        core.MeshAttachment = MeshAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var PathAttachment = function (_super) {\n            __extends(PathAttachment, _super);\n            function PathAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.closed = false;\n                _this.constantSpeed = false;\n                _this.color = new core.Color(1, 1, 1, 1);\n                return _this;\n            }\n            return PathAttachment;\n        }(core.VertexAttachment);\n        core.PathAttachment = PathAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var PointAttachment = function (_super) {\n            __extends(PointAttachment, _super);\n            function PointAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.color = new core.Color(0.38, 0.94, 0, 1);\n                return _this;\n            }\n            PointAttachment.prototype.computeWorldPosition = function (bone, point) {\n                var mat = bone.matrix;\n                point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n                point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n                return point;\n            };\n            PointAttachment.prototype.computeWorldRotation = function (bone) {\n                var mat = bone.matrix;\n                var cos = core.MathUtils.cosDeg(this.rotation),\n                    sin = core.MathUtils.sinDeg(this.rotation);\n                var x = cos * mat.a + sin * mat.c;\n                var y = cos * mat.b + sin * mat.d;\n                return Math.atan2(y, x) * core.MathUtils.radDeg;\n            };\n            return PointAttachment;\n        }(core.VertexAttachment);\n        core.PointAttachment = PointAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var RegionAttachment = function (_super) {\n            __extends(RegionAttachment, _super);\n            function RegionAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.x = 0;\n                _this.y = 0;\n                _this.scaleX = 1;\n                _this.scaleY = 1;\n                _this.rotation = 0;\n                _this.width = 0;\n                _this.height = 0;\n                _this.color = new core.Color(1, 1, 1, 1);\n                _this.offset = core.Utils.newFloatArray(8);\n                _this.uvs = core.Utils.newFloatArray(8);\n                _this.tempColor = new core.Color(1, 1, 1, 1);\n                return _this;\n            }\n            RegionAttachment.prototype.updateOffset = function () {\n                var regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n                var regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n                var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n                var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n                var localX2 = localX + this.region.width * regionScaleX;\n                var localY2 = localY + this.region.height * regionScaleY;\n                var radians = this.rotation * Math.PI / 180;\n                var cos = Math.cos(radians);\n                var sin = Math.sin(radians);\n                var localXCos = localX * cos + this.x;\n                var localXSin = localX * sin;\n                var localYCos = localY * cos + this.y;\n                var localYSin = localY * sin;\n                var localX2Cos = localX2 * cos + this.x;\n                var localX2Sin = localX2 * sin;\n                var localY2Cos = localY2 * cos + this.y;\n                var localY2Sin = localY2 * sin;\n                var offset = this.offset;\n                offset[RegionAttachment.OX1] = localXCos - localYSin;\n                offset[RegionAttachment.OY1] = localYCos + localXSin;\n                offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n                offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n                offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n                offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n                offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n                offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n            };\n            RegionAttachment.prototype.setRegion = function (region) {\n                this.region = region;\n                var uvs = this.uvs;\n                if (region.rotate) {\n                    uvs[2] = region.u;\n                    uvs[3] = region.v2;\n                    uvs[4] = region.u;\n                    uvs[5] = region.v;\n                    uvs[6] = region.u2;\n                    uvs[7] = region.v;\n                    uvs[0] = region.u2;\n                    uvs[1] = region.v2;\n                } else {\n                    uvs[0] = region.u;\n                    uvs[1] = region.v2;\n                    uvs[2] = region.u;\n                    uvs[3] = region.v;\n                    uvs[4] = region.u2;\n                    uvs[5] = region.v;\n                    uvs[6] = region.u2;\n                    uvs[7] = region.v2;\n                }\n            };\n            RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\n                var vertexOffset = this.offset;\n                var mat = bone.matrix;\n                var x = mat.tx,\n                    y = mat.ty;\n                var a = mat.a,\n                    b = mat.c,\n                    c = mat.b,\n                    d = mat.d;\n                var offsetX = 0,\n                    offsetY = 0;\n                offsetX = vertexOffset[RegionAttachment.OX1];\n                offsetY = vertexOffset[RegionAttachment.OY1];\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n                offset += stride;\n                offsetX = vertexOffset[RegionAttachment.OX2];\n                offsetY = vertexOffset[RegionAttachment.OY2];\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n                offset += stride;\n                offsetX = vertexOffset[RegionAttachment.OX3];\n                offsetY = vertexOffset[RegionAttachment.OY3];\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n                offset += stride;\n                offsetX = vertexOffset[RegionAttachment.OX4];\n                offsetY = vertexOffset[RegionAttachment.OY4];\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            };\n            return RegionAttachment;\n        }(core.Attachment);\n        RegionAttachment.OX1 = 0;\n        RegionAttachment.OY1 = 1;\n        RegionAttachment.OX2 = 2;\n        RegionAttachment.OY2 = 3;\n        RegionAttachment.OX3 = 4;\n        RegionAttachment.OY3 = 5;\n        RegionAttachment.OX4 = 6;\n        RegionAttachment.OY4 = 7;\n        RegionAttachment.X1 = 0;\n        RegionAttachment.Y1 = 1;\n        RegionAttachment.C1R = 2;\n        RegionAttachment.C1G = 3;\n        RegionAttachment.C1B = 4;\n        RegionAttachment.C1A = 5;\n        RegionAttachment.U1 = 6;\n        RegionAttachment.V1 = 7;\n        RegionAttachment.X2 = 8;\n        RegionAttachment.Y2 = 9;\n        RegionAttachment.C2R = 10;\n        RegionAttachment.C2G = 11;\n        RegionAttachment.C2B = 12;\n        RegionAttachment.C2A = 13;\n        RegionAttachment.U2 = 14;\n        RegionAttachment.V2 = 15;\n        RegionAttachment.X3 = 16;\n        RegionAttachment.Y3 = 17;\n        RegionAttachment.C3R = 18;\n        RegionAttachment.C3G = 19;\n        RegionAttachment.C3B = 20;\n        RegionAttachment.C3A = 21;\n        RegionAttachment.U3 = 22;\n        RegionAttachment.V3 = 23;\n        RegionAttachment.X4 = 24;\n        RegionAttachment.Y4 = 25;\n        RegionAttachment.C4R = 26;\n        RegionAttachment.C4G = 27;\n        RegionAttachment.C4B = 28;\n        RegionAttachment.C4A = 29;\n        RegionAttachment.U4 = 30;\n        RegionAttachment.V4 = 31;\n        core.RegionAttachment = RegionAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var BlendMode;\n        (function (BlendMode) {\n            BlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\n            BlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\n            BlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\n            BlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\n        })(BlendMode = core.BlendMode || (core.BlendMode = {}));\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Bone = function () {\n            function Bone(data, skeleton, parent) {\n                this.matrix = new PIXI.Matrix();\n                this.children = new Array();\n                this.x = 0;\n                this.y = 0;\n                this.rotation = 0;\n                this.scaleX = 0;\n                this.scaleY = 0;\n                this.shearX = 0;\n                this.shearY = 0;\n                this.ax = 0;\n                this.ay = 0;\n                this.arotation = 0;\n                this.ascaleX = 0;\n                this.ascaleY = 0;\n                this.ashearX = 0;\n                this.ashearY = 0;\n                this.appliedValid = false;\n                this.sorted = false;\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                this.data = data;\n                this.skeleton = skeleton;\n                this.parent = parent;\n                this.setToSetupPose();\n            }\n            Object.defineProperty(Bone.prototype, \"worldX\", {\n                get: function get() {\n                    return this.matrix.tx;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(Bone.prototype, \"worldY\", {\n                get: function get() {\n                    return this.matrix.ty;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Bone.prototype.update = function () {\n                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n            };\n            Bone.prototype.updateWorldTransform = function () {\n                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n            };\n            Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\n                this.ax = x;\n                this.ay = y;\n                this.arotation = rotation;\n                this.ascaleX = scaleX;\n                this.ascaleY = scaleY;\n                this.ashearX = shearX;\n                this.ashearY = shearY;\n                this.appliedValid = true;\n                var parent = this.parent;\n                var m = this.matrix;\n                if (parent == null) {\n                    var rotationY = rotation + 90 + shearY;\n                    var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    var lb = core.MathUtils.cosDeg(rotationY) * scaleY;\n                    var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    var ld = core.MathUtils.sinDeg(rotationY) * scaleY;\n                    var skeleton = this.skeleton;\n                    if (skeleton.flipX) {\n                        x = -x;\n                        la = -la;\n                        lb = -lb;\n                    }\n                    if (skeleton.flipY !== Bone.yDown) {\n                        y = -y;\n                        lc = -lc;\n                        ld = -ld;\n                    }\n                    m.a = la;\n                    m.c = lb;\n                    m.b = lc;\n                    m.d = ld;\n                    m.tx = x + skeleton.x;\n                    m.ty = y + skeleton.y;\n                    return;\n                }\n                var pa = parent.matrix.a,\n                    pb = parent.matrix.c,\n                    pc = parent.matrix.b,\n                    pd = parent.matrix.d;\n                m.tx = pa * x + pb * y + parent.matrix.tx;\n                m.ty = pc * x + pd * y + parent.matrix.ty;\n                switch (this.data.transformMode) {\n                    case core.TransformMode.Normal:\n                        {\n                            var rotationY = rotation + 90 + shearY;\n                            var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\n                            var lb = core.MathUtils.cosDeg(rotationY) * scaleY;\n                            var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\n                            var ld = core.MathUtils.sinDeg(rotationY) * scaleY;\n                            m.a = pa * la + pb * lc;\n                            m.c = pa * lb + pb * ld;\n                            m.b = pc * la + pd * lc;\n                            m.d = pc * lb + pd * ld;\n                            return;\n                        }\n                    case core.TransformMode.OnlyTranslation:\n                        {\n                            var rotationY = rotation + 90 + shearY;\n                            m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\n                            m.c = core.MathUtils.cosDeg(rotationY) * scaleY;\n                            m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\n                            m.d = core.MathUtils.sinDeg(rotationY) * scaleY;\n                            break;\n                        }\n                    case core.TransformMode.NoRotationOrReflection:\n                        {\n                            var s = pa * pa + pc * pc;\n                            var prx = 0;\n                            if (s > 0.0001) {\n                                s = Math.abs(pa * pd - pb * pc) / s;\n                                pb = pc * s;\n                                pd = pa * s;\n                                prx = Math.atan2(pc, pa) * core.MathUtils.radDeg;\n                            } else {\n                                pa = 0;\n                                pc = 0;\n                                prx = 90 - Math.atan2(pd, pb) * core.MathUtils.radDeg;\n                            }\n                            var rx = rotation + shearX - prx;\n                            var ry = rotation + shearY - prx + 90;\n                            var la = core.MathUtils.cosDeg(rx) * scaleX;\n                            var lb = core.MathUtils.cosDeg(ry) * scaleY;\n                            var lc = core.MathUtils.sinDeg(rx) * scaleX;\n                            var ld = core.MathUtils.sinDeg(ry) * scaleY;\n                            m.a = pa * la - pb * lc;\n                            m.c = pa * lb - pb * ld;\n                            m.b = pc * la + pd * lc;\n                            m.d = pc * lb + pd * ld;\n                            break;\n                        }\n                    case core.TransformMode.NoScale:\n                    case core.TransformMode.NoScaleOrReflection:\n                        {\n                            var cos = core.MathUtils.cosDeg(rotation);\n                            var sin = core.MathUtils.sinDeg(rotation);\n                            var za = pa * cos + pb * sin;\n                            var zc = pc * cos + pd * sin;\n                            var s = Math.sqrt(za * za + zc * zc);\n                            if (s > 0.00001) s = 1 / s;\n                            za *= s;\n                            zc *= s;\n                            s = Math.sqrt(za * za + zc * zc);\n                            var r = Math.PI / 2 + Math.atan2(zc, za);\n                            var zb = Math.cos(r) * s;\n                            var zd = Math.sin(r) * s;\n                            var la = core.MathUtils.cosDeg(shearX) * scaleX;\n                            var lb = core.MathUtils.cosDeg(90 + shearY) * scaleY;\n                            var lc = core.MathUtils.sinDeg(shearX) * scaleX;\n                            var ld = core.MathUtils.sinDeg(90 + shearY) * scaleY;\n                            m.a = za * la + zb * lc;\n                            m.c = za * lb + zb * ld;\n                            m.b = zc * la + zd * lc;\n                            m.d = zc * lb + zd * ld;\n                            if (this.data.transformMode != core.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : this.skeleton.flipX != this.skeleton.flipY != Bone.yDown) {\n                                m.c = -m.c;\n                                m.d = -m.d;\n                            }\n                            return;\n                        }\n                }\n                if (this.skeleton.flipX) {\n                    m.a = -m.a;\n                    m.c = -m.c;\n                }\n                if (this.skeleton.flipY != Bone.yDown) {\n                    m.b = -m.b;\n                    m.d = -m.d;\n                }\n            };\n            Bone.prototype.setToSetupPose = function () {\n                var data = this.data;\n                this.x = data.x;\n                this.y = data.y;\n                this.rotation = data.rotation;\n                this.scaleX = data.scaleX;\n                this.scaleY = data.scaleY;\n                this.shearX = data.shearX;\n                this.shearY = data.shearY;\n            };\n            Bone.prototype.getWorldRotationX = function () {\n                return Math.atan2(this.matrix.b, this.matrix.a) * core.MathUtils.radDeg;\n            };\n            Bone.prototype.getWorldRotationY = function () {\n                return Math.atan2(this.matrix.d, this.matrix.c) * core.MathUtils.radDeg;\n            };\n            Bone.prototype.getWorldScaleX = function () {\n                var m = this.matrix;\n                return Math.sqrt(m.a * m.a + m.c * m.c);\n            };\n            Bone.prototype.getWorldScaleY = function () {\n                var m = this.matrix;\n                return Math.sqrt(m.b * m.b + m.d * m.d);\n            };\n            Bone.prototype.updateAppliedTransform = function () {\n                this.appliedValid = true;\n                var parent = this.parent;\n                var m = this.matrix;\n                if (parent == null) {\n                    this.ax = m.tx;\n                    this.ay = m.ty;\n                    this.arotation = Math.atan2(m.b, m.a) * core.MathUtils.radDeg;\n                    this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n                    this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n                    this.ashearX = 0;\n                    this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * core.MathUtils.radDeg;\n                    return;\n                }\n                var pm = parent.matrix;\n                var pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n                var dx = m.tx - pm.tx,\n                    dy = m.ty - pm.ty;\n                this.ax = dx * pm.d * pid - dy * pm.c * pid;\n                this.ay = dy * pm.a * pid - dx * pm.b * pid;\n                var ia = pid * pm.d;\n                var id = pid * pm.a;\n                var ib = pid * pm.c;\n                var ic = pid * pm.b;\n                var ra = ia * m.a - ib * m.b;\n                var rb = ia * m.c - ib * m.d;\n                var rc = id * m.b - ic * m.a;\n                var rd = id * m.d - ic * m.c;\n                this.ashearX = 0;\n                this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n                if (this.ascaleX > 0.0001) {\n                    var det = ra * rd - rb * rc;\n                    this.ascaleY = det / this.ascaleX;\n                    this.ashearY = Math.atan2(ra * rb + rc * rd, det) * core.MathUtils.radDeg;\n                    this.arotation = Math.atan2(rc, ra) * core.MathUtils.radDeg;\n                } else {\n                    this.ascaleX = 0;\n                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n                    this.ashearY = 0;\n                    this.arotation = 90 - Math.atan2(rd, rb) * core.MathUtils.radDeg;\n                }\n            };\n            Bone.prototype.worldToLocal = function (world) {\n                var m = this.matrix;\n                var a = m.a,\n                    b = m.c,\n                    c = m.b,\n                    d = m.d;\n                var invDet = 1 / (a * d - b * c);\n                var x = world.x - m.tx,\n                    y = world.y - m.ty;\n                world.x = x * d * invDet - y * b * invDet;\n                world.y = y * a * invDet - x * c * invDet;\n                return world;\n            };\n            Bone.prototype.localToWorld = function (local) {\n                var m = this.matrix;\n                var x = local.x,\n                    y = local.y;\n                local.x = x * m.a + y * m.c + m.tx;\n                local.y = x * m.b + y * m.d + m.ty;\n                return local;\n            };\n            Bone.prototype.worldToLocalRotation = function (worldRotation) {\n                var sin = core.MathUtils.sinDeg(worldRotation),\n                    cos = core.MathUtils.cosDeg(worldRotation);\n                var mat = this.matrix;\n                return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * core.MathUtils.radDeg;\n            };\n            Bone.prototype.localToWorldRotation = function (localRotation) {\n                var sin = core.MathUtils.sinDeg(localRotation),\n                    cos = core.MathUtils.cosDeg(localRotation);\n                var mat = this.matrix;\n                return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * core.MathUtils.radDeg;\n            };\n            Bone.prototype.rotateWorld = function (degrees) {\n                var mat = this.matrix;\n                var a = mat.a,\n                    b = mat.c,\n                    c = mat.b,\n                    d = mat.d;\n                var cos = core.MathUtils.cosDeg(degrees),\n                    sin = core.MathUtils.sinDeg(degrees);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                this.appliedValid = false;\n            };\n            return Bone;\n        }();\n        Bone.yDown = false;\n        core.Bone = Bone;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var BoneData = function () {\n            function BoneData(index, name, parent) {\n                this.x = 0;\n                this.y = 0;\n                this.rotation = 0;\n                this.scaleX = 1;\n                this.scaleY = 1;\n                this.shearX = 0;\n                this.shearY = 0;\n                this.transformMode = TransformMode.Normal;\n                if (index < 0) throw new Error(\"index must be >= 0.\");\n                if (name == null) throw new Error(\"name cannot be null.\");\n                this.index = index;\n                this.name = name;\n                this.parent = parent;\n            }\n            return BoneData;\n        }();\n        core.BoneData = BoneData;\n        var TransformMode;\n        (function (TransformMode) {\n            TransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\n            TransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\n            TransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\n            TransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\n            TransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\n        })(TransformMode = core.TransformMode || (core.TransformMode = {}));\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Event = function () {\n            function Event(time, data) {\n                if (data == null) throw new Error(\"data cannot be null.\");\n                this.time = time;\n                this.data = data;\n            }\n            return Event;\n        }();\n        core.Event = Event;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var EventData = function () {\n            function EventData(name) {\n                this.name = name;\n            }\n            return EventData;\n        }();\n        core.EventData = EventData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var IkConstraint = function () {\n            function IkConstraint(data, skeleton) {\n                this.mix = 1;\n                this.bendDirection = 0;\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                this.data = data;\n                this.mix = data.mix;\n                this.bendDirection = data.bendDirection;\n                this.bones = new Array();\n                for (var i = 0; i < data.bones.length; i++) {\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\n                }this.target = skeleton.findBone(data.target.name);\n            }\n            IkConstraint.prototype.getOrder = function () {\n                return this.data.order;\n            };\n            IkConstraint.prototype.apply = function () {\n                this.update();\n            };\n            IkConstraint.prototype.update = function () {\n                var target = this.target;\n                var bones = this.bones;\n                switch (bones.length) {\n                    case 1:\n                        this.apply1(bones[0], target.worldX, target.worldY, this.mix);\n                        break;\n                    case 2:\n                        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n                        break;\n                }\n            };\n            IkConstraint.prototype.apply1 = function (bone, targetX, targetY, alpha) {\n                if (!bone.appliedValid) bone.updateAppliedTransform();\n                var p = bone.parent.matrix;\n                var id = 1 / (p.a * p.d - p.b * p.c);\n                var x = targetX - p.tx,\n                    y = targetY - p.ty;\n                var tx = (x * p.d - y * p.c) * id - bone.ax,\n                    ty = (y * p.a - x * p.b) * id - bone.ay;\n                var rotationIK = Math.atan2(ty, tx) * core.MathUtils.radDeg - bone.ashearX - bone.arotation;\n                if (bone.ascaleX < 0) rotationIK += 180;\n                if (rotationIK > 180) rotationIK -= 360;else if (rotationIK < -180) rotationIK += 360;\n                bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY);\n            };\n            IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, alpha) {\n                if (alpha == 0) {\n                    child.updateWorldTransform();\n                    return;\n                }\n                if (!parent.appliedValid) parent.updateAppliedTransform();\n                if (!child.appliedValid) child.updateAppliedTransform();\n                var px = parent.ax,\n                    py = parent.ay,\n                    psx = parent.ascaleX,\n                    psy = parent.ascaleY,\n                    csx = child.ascaleX;\n                var pmat = parent.matrix;\n                var os1 = 0,\n                    os2 = 0,\n                    s2 = 0;\n                if (psx < 0) {\n                    psx = -psx;\n                    os1 = 180;\n                    s2 = -1;\n                } else {\n                    os1 = 0;\n                    s2 = 1;\n                }\n                if (psy < 0) {\n                    psy = -psy;\n                    s2 = -s2;\n                }\n                if (csx < 0) {\n                    csx = -csx;\n                    os2 = 180;\n                } else os2 = 0;\n                var cx = child.ax,\n                    cy = 0,\n                    cwx = 0,\n                    cwy = 0,\n                    a = pmat.a,\n                    b = pmat.c,\n                    c = pmat.b,\n                    d = pmat.d;\n                var u = Math.abs(psx - psy) <= 0.0001;\n                if (!u) {\n                    cy = 0;\n                    cwx = a * cx + pmat.tx;\n                    cwy = c * cx + pmat.ty;\n                } else {\n                    cy = child.ay;\n                    cwx = a * cx + b * cy + pmat.tx;\n                    cwy = c * cx + d * cy + pmat.ty;\n                }\n                var pp = parent.parent.matrix;\n                a = pp.a;\n                b = pp.c;\n                c = pp.b;\n                d = pp.d;\n                var id = 1 / (a * d - b * c),\n                    x = targetX - pp.tx,\n                    y = targetY - pp.ty;\n                var tx = (x * d - y * b) * id - px,\n                    ty = (y * a - x * c) * id - py;\n                x = cwx - pp.tx;\n                y = cwy - pp.ty;\n                var dx = (x * d - y * b) * id - px,\n                    dy = (y * a - x * c) * id - py;\n                var l1 = Math.sqrt(dx * dx + dy * dy),\n                    l2 = child.data.length * csx,\n                    a1 = 0,\n                    a2 = 0;\n                outer: if (u) {\n                    l2 *= psx;\n                    var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n                    if (cos < -1) cos = -1;else if (cos > 1) cos = 1;\n                    a2 = Math.acos(cos) * bendDir;\n                    a = l1 + l2 * cos;\n                    b = l2 * Math.sin(a2);\n                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n                } else {\n                    a = psx * l2;\n                    b = psy * l2;\n                    var aa = a * a,\n                        bb = b * b,\n                        dd = tx * tx + ty * ty,\n                        ta = Math.atan2(ty, tx);\n                    c = bb * l1 * l1 + aa * dd - aa * bb;\n                    var c1 = -2 * bb * l1,\n                        c2 = bb - aa;\n                    d = c1 * c1 - 4 * c2 * c;\n                    if (d >= 0) {\n                        var q = Math.sqrt(d);\n                        if (c1 < 0) q = -q;\n                        q = -(c1 + q) / 2;\n                        var r0 = q / c2,\n                            r1 = c / q;\n                        var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                        if (r * r <= dd) {\n                            y = Math.sqrt(dd - r * r) * bendDir;\n                            a1 = ta - Math.atan2(y, r);\n                            a2 = Math.atan2(y / psy, (r - l1) / psx);\n                            break outer;\n                        }\n                    }\n                    var minAngle = core.MathUtils.PI,\n                        minX = l1 - a,\n                        minDist = minX * minX,\n                        minY = 0;\n                    var maxAngle = 0,\n                        maxX = l1 + a,\n                        maxDist = maxX * maxX,\n                        maxY = 0;\n                    c = -a * l1 / (aa - bb);\n                    if (c >= -1 && c <= 1) {\n                        c = Math.acos(c);\n                        x = a * Math.cos(c) + l1;\n                        y = b * Math.sin(c);\n                        d = x * x + y * y;\n                        if (d < minDist) {\n                            minAngle = c;\n                            minDist = d;\n                            minX = x;\n                            minY = y;\n                        }\n                        if (d > maxDist) {\n                            maxAngle = c;\n                            maxDist = d;\n                            maxX = x;\n                            maxY = y;\n                        }\n                    }\n                    if (dd <= (minDist + maxDist) / 2) {\n                        a1 = ta - Math.atan2(minY * bendDir, minX);\n                        a2 = minAngle * bendDir;\n                    } else {\n                        a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                        a2 = maxAngle * bendDir;\n                    }\n                }\n                var os = Math.atan2(cy, cx) * s2;\n                var rotation = parent.arotation;\n                a1 = (a1 - os) * core.MathUtils.radDeg + os1 - rotation;\n                if (a1 > 180) a1 -= 360;else if (a1 < -180) a1 += 360;\n                parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);\n                rotation = child.arotation;\n                a2 = ((a2 + os) * core.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n                if (a2 > 180) a2 -= 360;else if (a2 < -180) a2 += 360;\n                child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n            };\n            return IkConstraint;\n        }();\n        core.IkConstraint = IkConstraint;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var IkConstraintData = function () {\n            function IkConstraintData(name) {\n                this.order = 0;\n                this.bones = new Array();\n                this.bendDirection = 1;\n                this.mix = 1;\n                this.name = name;\n            }\n            return IkConstraintData;\n        }();\n        core.IkConstraintData = IkConstraintData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var PathConstraint = function () {\n            function PathConstraint(data, skeleton) {\n                this.position = 0;\n                this.spacing = 0;\n                this.rotateMix = 0;\n                this.translateMix = 0;\n                this.spaces = new Array();\n                this.positions = new Array();\n                this.world = new Array();\n                this.curves = new Array();\n                this.lengths = new Array();\n                this.segments = new Array();\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                this.data = data;\n                this.bones = new Array();\n                for (var i = 0, n = data.bones.length; i < n; i++) {\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\n                }this.target = skeleton.findSlot(data.target.name);\n                this.position = data.position;\n                this.spacing = data.spacing;\n                this.rotateMix = data.rotateMix;\n                this.translateMix = data.translateMix;\n            }\n            PathConstraint.prototype.apply = function () {\n                this.update();\n            };\n            PathConstraint.prototype.update = function () {\n                var attachment = this.target.getAttachment();\n                if (!(attachment instanceof core.PathAttachment)) return;\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix;\n                var translate = translateMix > 0,\n                    rotate = rotateMix > 0;\n                if (!translate && !rotate) return;\n                var data = this.data;\n                var spacingMode = data.spacingMode;\n                var lengthSpacing = spacingMode == core.SpacingMode.Length;\n                var rotateMode = data.rotateMode;\n                var tangents = rotateMode == core.RotateMode.Tangent,\n                    scale = rotateMode == core.RotateMode.ChainScale;\n                var boneCount = this.bones.length,\n                    spacesCount = tangents ? boneCount : boneCount + 1;\n                var bones = this.bones;\n                var spaces = core.Utils.setArraySize(this.spaces, spacesCount),\n                    lengths = null;\n                var spacing = this.spacing;\n                if (scale || lengthSpacing) {\n                    if (scale) lengths = core.Utils.setArraySize(this.lengths, boneCount);\n                    for (var i = 0, n = spacesCount - 1; i < n;) {\n                        var bone = bones[i];\n                        var setupLength = bone.data.length,\n                            x = setupLength * bone.matrix.a,\n                            y = setupLength * bone.matrix.b;\n                        var length_1 = Math.sqrt(x * x + y * y);\n                        if (scale) lengths[i] = length_1;\n                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;\n                    }\n                } else {\n                    for (var i = 1; i < spacesCount; i++) {\n                        spaces[i] = spacing;\n                    }\n                }\n                var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == core.PositionMode.Percent, spacingMode == core.SpacingMode.Percent);\n                var boneX = positions[0],\n                    boneY = positions[1],\n                    offsetRotation = data.offsetRotation;\n                var tip = false;\n                if (offsetRotation == 0) tip = rotateMode == core.RotateMode.Chain;else {\n                    tip = false;\n                    var p = this.target.bone.matrix;\n                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n                }\n                for (var i = 0, p = 3; i < boneCount; i++, p += 3) {\n                    var bone = bones[i];\n                    var mat = bone.matrix;\n                    mat.tx += (boneX - mat.tx) * translateMix;\n                    mat.ty += (boneY - mat.ty) * translateMix;\n                    var x = positions[p],\n                        y = positions[p + 1],\n                        dx = x - boneX,\n                        dy = y - boneY;\n                    if (scale) {\n                        var length_2 = lengths[i];\n                        if (length_2 != 0) {\n                            var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;\n                            mat.a *= s;\n                            mat.b *= s;\n                        }\n                    }\n                    boneX = x;\n                    boneY = y;\n                    if (rotate) {\n                        var a = mat.a,\n                            b = mat.c,\n                            c = mat.b,\n                            d = mat.d,\n                            r = 0,\n                            cos = 0,\n                            sin = 0;\n                        if (tangents) r = positions[p - 1];else if (spaces[i + 1] == 0) r = positions[p + 2];else r = Math.atan2(dy, dx);\n                        r -= Math.atan2(c, a);\n                        if (tip) {\n                            cos = Math.cos(r);\n                            sin = Math.sin(r);\n                            var length_3 = bone.data.length;\n                            boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;\n                            boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;\n                        } else {\n                            r += offsetRotation;\n                        }\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        r *= rotateMix;\n                        cos = Math.cos(r);\n                        sin = Math.sin(r);\n                        mat.a = cos * a - sin * c;\n                        mat.c = cos * b - sin * d;\n                        mat.b = sin * a + cos * c;\n                        mat.d = sin * b + cos * d;\n                    }\n                    bone.appliedValid = false;\n                }\n            };\n            PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\n                var target = this.target;\n                var position = this.position;\n                var spaces = this.spaces,\n                    out = core.Utils.setArraySize(this.positions, spacesCount * 3 + 2),\n                    world = null;\n                var closed = path.closed;\n                var verticesLength = path.worldVerticesLength,\n                    curveCount = verticesLength / 6,\n                    prevCurve = PathConstraint.NONE;\n                if (!path.constantSpeed) {\n                    var lengths = path.lengths;\n                    curveCount -= closed ? 1 : 2;\n                    var pathLength_1 = lengths[curveCount];\n                    if (percentPosition) position *= pathLength_1;\n                    if (percentSpacing) {\n                        for (var i = 0; i < spacesCount; i++) {\n                            spaces[i] *= pathLength_1;\n                        }\n                    }\n                    world = core.Utils.setArraySize(this.world, 8);\n                    for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                        var space = spaces[i];\n                        position += space;\n                        var p = position;\n                        if (closed) {\n                            p %= pathLength_1;\n                            if (p < 0) p += pathLength_1;\n                            curve = 0;\n                        } else if (p < 0) {\n                            if (prevCurve != PathConstraint.BEFORE) {\n                                prevCurve = PathConstraint.BEFORE;\n                                path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                            }\n                            this.addBeforePosition(p, world, 0, out, o);\n                            continue;\n                        } else if (p > pathLength_1) {\n                            if (prevCurve != PathConstraint.AFTER) {\n                                prevCurve = PathConstraint.AFTER;\n                                path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                            }\n                            this.addAfterPosition(p - pathLength_1, world, 0, out, o);\n                            continue;\n                        }\n                        for (;; curve++) {\n                            var length_4 = lengths[curve];\n                            if (p > length_4) continue;\n                            if (curve == 0) p /= length_4;else {\n                                var prev = lengths[curve - 1];\n                                p = (p - prev) / (length_4 - prev);\n                            }\n                            break;\n                        }\n                        if (curve != prevCurve) {\n                            prevCurve = curve;\n                            if (closed && curve == curveCount) {\n                                path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                                path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                            } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                        }\n                        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n                    }\n                    return out;\n                }\n                if (closed) {\n                    verticesLength += 2;\n                    world = core.Utils.setArraySize(this.world, verticesLength);\n                    path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n                    path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n                    world[verticesLength - 2] = world[0];\n                    world[verticesLength - 1] = world[1];\n                } else {\n                    curveCount--;\n                    verticesLength -= 4;\n                    world = core.Utils.setArraySize(this.world, verticesLength);\n                    path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n                }\n                var curves = core.Utils.setArraySize(this.curves, curveCount);\n                var pathLength = 0;\n                var x1 = world[0],\n                    y1 = world[1],\n                    cx1 = 0,\n                    cy1 = 0,\n                    cx2 = 0,\n                    cy2 = 0,\n                    x2 = 0,\n                    y2 = 0;\n                var tmpx = 0,\n                    tmpy = 0,\n                    dddfx = 0,\n                    dddfy = 0,\n                    ddfx = 0,\n                    ddfy = 0,\n                    dfx = 0,\n                    dfy = 0;\n                for (var i = 0, w = 2; i < curveCount; i++, w += 6) {\n                    cx1 = world[w];\n                    cy1 = world[w + 1];\n                    cx2 = world[w + 2];\n                    cy2 = world[w + 3];\n                    x2 = world[w + 4];\n                    y2 = world[w + 5];\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n                    ddfx = tmpx * 2 + dddfx;\n                    ddfy = tmpy * 2 + dddfy;\n                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    dfx += ddfx + dddfx;\n                    dfy += ddfy + dddfy;\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    curves[i] = pathLength;\n                    x1 = x2;\n                    y1 = y2;\n                }\n                if (percentPosition) position *= pathLength;\n                if (percentSpacing) {\n                    for (var i = 0; i < spacesCount; i++) {\n                        spaces[i] *= pathLength;\n                    }\n                }\n                var segments = this.segments;\n                var curveLength = 0;\n                for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n                    var space = spaces[i];\n                    position += space;\n                    var p = position;\n                    if (closed) {\n                        p %= pathLength;\n                        if (p < 0) p += pathLength;\n                        curve = 0;\n                    } else if (p < 0) {\n                        this.addBeforePosition(p, world, 0, out, o);\n                        continue;\n                    } else if (p > pathLength) {\n                        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                        continue;\n                    }\n                    for (;; curve++) {\n                        var length_5 = curves[curve];\n                        if (p > length_5) continue;\n                        if (curve == 0) p /= length_5;else {\n                            var prev = curves[curve - 1];\n                            p = (p - prev) / (length_5 - prev);\n                        }\n                        break;\n                    }\n                    if (curve != prevCurve) {\n                        prevCurve = curve;\n                        var ii = curve * 6;\n                        x1 = world[ii];\n                        y1 = world[ii + 1];\n                        cx1 = world[ii + 2];\n                        cy1 = world[ii + 3];\n                        cx2 = world[ii + 4];\n                        cy2 = world[ii + 5];\n                        x2 = world[ii + 6];\n                        y2 = world[ii + 7];\n                        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                        ddfx = tmpx * 2 + dddfx;\n                        ddfy = tmpy * 2 + dddfy;\n                        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[0] = curveLength;\n                        for (ii = 1; ii < 8; ii++) {\n                            dfx += ddfx;\n                            dfy += ddfy;\n                            ddfx += dddfx;\n                            ddfy += dddfy;\n                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                            segments[ii] = curveLength;\n                        }\n                        dfx += ddfx;\n                        dfy += ddfy;\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[8] = curveLength;\n                        dfx += ddfx + dddfx;\n                        dfy += ddfy + dddfy;\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[9] = curveLength;\n                        segment = 0;\n                    }\n                    p *= curveLength;\n                    for (;; segment++) {\n                        var length_6 = segments[segment];\n                        if (p > length_6) continue;\n                        if (segment == 0) p /= length_6;else {\n                            var prev = segments[segment - 1];\n                            p = segment + (p - prev) / (length_6 - prev);\n                        }\n                        break;\n                    }\n                    this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n                }\n                return out;\n            };\n            PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\n                var x1 = temp[i],\n                    y1 = temp[i + 1],\n                    dx = temp[i + 2] - x1,\n                    dy = temp[i + 3] - y1,\n                    r = Math.atan2(dy, dx);\n                out[o] = x1 + p * Math.cos(r);\n                out[o + 1] = y1 + p * Math.sin(r);\n                out[o + 2] = r;\n            };\n            PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\n                var x1 = temp[i + 2],\n                    y1 = temp[i + 3],\n                    dx = x1 - temp[i],\n                    dy = y1 - temp[i + 1],\n                    r = Math.atan2(dy, dx);\n                out[o] = x1 + p * Math.cos(r);\n                out[o + 1] = y1 + p * Math.sin(r);\n                out[o + 2] = r;\n            };\n            PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n                if (p == 0 || isNaN(p)) p = 0.0001;\n                var tt = p * p,\n                    ttt = tt * p,\n                    u = 1 - p,\n                    uu = u * u,\n                    uuu = uu * u;\n                var ut = u * p,\n                    ut3 = ut * 3,\n                    uut3 = u * ut3,\n                    utt3 = ut3 * p;\n                var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt,\n                    y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n                out[o] = x;\n                out[o + 1] = y;\n                if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n            };\n            PathConstraint.prototype.getOrder = function () {\n                return this.data.order;\n            };\n            return PathConstraint;\n        }();\n        PathConstraint.NONE = -1;\n        PathConstraint.BEFORE = -2;\n        PathConstraint.AFTER = -3;\n        core.PathConstraint = PathConstraint;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var PathConstraintData = function () {\n            function PathConstraintData(name) {\n                this.order = 0;\n                this.bones = new Array();\n                this.name = name;\n            }\n            return PathConstraintData;\n        }();\n        core.PathConstraintData = PathConstraintData;\n        var PositionMode;\n        (function (PositionMode) {\n            PositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\n            PositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\n        })(PositionMode = core.PositionMode || (core.PositionMode = {}));\n        var SpacingMode;\n        (function (SpacingMode) {\n            SpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\n            SpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\n            SpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\n        })(SpacingMode = core.SpacingMode || (core.SpacingMode = {}));\n        var RotateMode;\n        (function (RotateMode) {\n            RotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\n            RotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\n            RotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\n        })(RotateMode = core.RotateMode || (core.RotateMode = {}));\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Skeleton = function () {\n            function Skeleton(data) {\n                this._updateCache = new Array();\n                this.updateCacheReset = new Array();\n                this.time = 0;\n                this.flipX = false;\n                this.flipY = false;\n                this.x = 0;\n                this.y = 0;\n                if (data == null) throw new Error(\"data cannot be null.\");\n                this.data = data;\n                this.bones = new Array();\n                for (var i = 0; i < data.bones.length; i++) {\n                    var boneData = data.bones[i];\n                    var bone = void 0;\n                    if (boneData.parent == null) bone = new core.Bone(boneData, this, null);else {\n                        var parent_1 = this.bones[boneData.parent.index];\n                        bone = new core.Bone(boneData, this, parent_1);\n                        parent_1.children.push(bone);\n                    }\n                    this.bones.push(bone);\n                }\n                this.slots = new Array();\n                this.drawOrder = new Array();\n                for (var i = 0; i < data.slots.length; i++) {\n                    var slotData = data.slots[i];\n                    var bone = this.bones[slotData.boneData.index];\n                    var slot = new core.Slot(slotData, bone);\n                    this.slots.push(slot);\n                    this.drawOrder.push(slot);\n                }\n                this.ikConstraints = new Array();\n                for (var i = 0; i < data.ikConstraints.length; i++) {\n                    var ikConstraintData = data.ikConstraints[i];\n                    this.ikConstraints.push(new core.IkConstraint(ikConstraintData, this));\n                }\n                this.transformConstraints = new Array();\n                for (var i = 0; i < data.transformConstraints.length; i++) {\n                    var transformConstraintData = data.transformConstraints[i];\n                    this.transformConstraints.push(new core.TransformConstraint(transformConstraintData, this));\n                }\n                this.pathConstraints = new Array();\n                for (var i = 0; i < data.pathConstraints.length; i++) {\n                    var pathConstraintData = data.pathConstraints[i];\n                    this.pathConstraints.push(new core.PathConstraint(pathConstraintData, this));\n                }\n                this.color = new core.Color(1, 1, 1, 1);\n                this.updateCache();\n            }\n            Skeleton.prototype.updateCache = function () {\n                var updateCache = this._updateCache;\n                updateCache.length = 0;\n                this.updateCacheReset.length = 0;\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    bones[i].sorted = false;\n                }var ikConstraints = this.ikConstraints;\n                var transformConstraints = this.transformConstraints;\n                var pathConstraints = this.pathConstraints;\n                var ikCount = ikConstraints.length,\n                    transformCount = transformConstraints.length,\n                    pathCount = pathConstraints.length;\n                var constraintCount = ikCount + transformCount + pathCount;\n                outer: for (var i = 0; i < constraintCount; i++) {\n                    for (var ii = 0; ii < ikCount; ii++) {\n                        var constraint = ikConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortIkConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                    for (var ii = 0; ii < transformCount; ii++) {\n                        var constraint = transformConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortTransformConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                    for (var ii = 0; ii < pathCount; ii++) {\n                        var constraint = pathConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortPathConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                }\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    this.sortBone(bones[i]);\n                }\n            };\n            Skeleton.prototype.sortIkConstraint = function (constraint) {\n                var target = constraint.target;\n                this.sortBone(target);\n                var constrained = constraint.bones;\n                var parent = constrained[0];\n                this.sortBone(parent);\n                if (constrained.length > 1) {\n                    var child = constrained[constrained.length - 1];\n                    if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n                }\n                this._updateCache.push(constraint);\n                this.sortReset(parent.children);\n                constrained[constrained.length - 1].sorted = true;\n            };\n            Skeleton.prototype.sortPathConstraint = function (constraint) {\n                var slot = constraint.target;\n                var slotIndex = slot.data.index;\n                var slotBone = slot.bone;\n                if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n                if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n                for (var i = 0, n = this.data.skins.length; i < n; i++) {\n                    this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n                }var attachment = slot.getAttachment();\n                if (attachment instanceof core.PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n                var constrained = constraint.bones;\n                var boneCount = constrained.length;\n                for (var i = 0; i < boneCount; i++) {\n                    this.sortBone(constrained[i]);\n                }this._updateCache.push(constraint);\n                for (var i = 0; i < boneCount; i++) {\n                    this.sortReset(constrained[i].children);\n                }for (var i = 0; i < boneCount; i++) {\n                    constrained[i].sorted = true;\n                }\n            };\n            Skeleton.prototype.sortTransformConstraint = function (constraint) {\n                this.sortBone(constraint.target);\n                var constrained = constraint.bones;\n                var boneCount = constrained.length;\n                if (constraint.data.local) {\n                    for (var i = 0; i < boneCount; i++) {\n                        var child = constrained[i];\n                        this.sortBone(child.parent);\n                        if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n                    }\n                } else {\n                    for (var i = 0; i < boneCount; i++) {\n                        this.sortBone(constrained[i]);\n                    }\n                }\n                this._updateCache.push(constraint);\n                for (var ii = 0; ii < boneCount; ii++) {\n                    this.sortReset(constrained[ii].children);\n                }for (var ii = 0; ii < boneCount; ii++) {\n                    constrained[ii].sorted = true;\n                }\n            };\n            Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\n                var attachments = skin.attachments[slotIndex];\n                if (!attachments) return;\n                for (var key in attachments) {\n                    this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n                }\n            };\n            Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\n                if (!(attachment instanceof core.PathAttachment)) return;\n                var pathBones = attachment.bones;\n                if (pathBones == null) this.sortBone(slotBone);else {\n                    var bones = this.bones;\n                    var i = 0;\n                    while (i < pathBones.length) {\n                        var boneCount = pathBones[i++];\n                        for (var n = i + boneCount; i < n; i++) {\n                            var boneIndex = pathBones[i];\n                            this.sortBone(bones[boneIndex]);\n                        }\n                    }\n                }\n            };\n            Skeleton.prototype.sortBone = function (bone) {\n                if (bone.sorted) return;\n                var parent = bone.parent;\n                if (parent != null) this.sortBone(parent);\n                bone.sorted = true;\n                this._updateCache.push(bone);\n            };\n            Skeleton.prototype.sortReset = function (bones) {\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (bone.sorted) this.sortReset(bone.children);\n                    bone.sorted = false;\n                }\n            };\n            Skeleton.prototype.updateWorldTransform = function () {\n                var updateCacheReset = this.updateCacheReset;\n                for (var i = 0, n = updateCacheReset.length; i < n; i++) {\n                    var bone = updateCacheReset[i];\n                    bone.ax = bone.x;\n                    bone.ay = bone.y;\n                    bone.arotation = bone.rotation;\n                    bone.ascaleX = bone.scaleX;\n                    bone.ascaleY = bone.scaleY;\n                    bone.ashearX = bone.shearX;\n                    bone.ashearY = bone.shearY;\n                    bone.appliedValid = true;\n                }\n                var updateCache = this._updateCache;\n                for (var i = 0, n = updateCache.length; i < n; i++) {\n                    updateCache[i].update();\n                }\n            };\n            Skeleton.prototype.setToSetupPose = function () {\n                this.setBonesToSetupPose();\n                this.setSlotsToSetupPose();\n            };\n            Skeleton.prototype.setBonesToSetupPose = function () {\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    bones[i].setToSetupPose();\n                }var ikConstraints = this.ikConstraints;\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                    var constraint = ikConstraints[i];\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.mix = constraint.data.mix;\n                }\n                var transformConstraints = this.transformConstraints;\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                    var constraint = transformConstraints[i];\n                    var data = constraint.data;\n                    constraint.rotateMix = data.rotateMix;\n                    constraint.translateMix = data.translateMix;\n                    constraint.scaleMix = data.scaleMix;\n                    constraint.shearMix = data.shearMix;\n                }\n                var pathConstraints = this.pathConstraints;\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                    var constraint = pathConstraints[i];\n                    var data = constraint.data;\n                    constraint.position = data.position;\n                    constraint.spacing = data.spacing;\n                    constraint.rotateMix = data.rotateMix;\n                    constraint.translateMix = data.translateMix;\n                }\n            };\n            Skeleton.prototype.setSlotsToSetupPose = function () {\n                var slots = this.slots;\n                core.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    slots[i].setToSetupPose();\n                }\n            };\n            Skeleton.prototype.getRootBone = function () {\n                if (this.bones.length == 0) return null;\n                return this.bones[0];\n            };\n            Skeleton.prototype.findBone = function (boneName) {\n                if (boneName == null) throw new Error(\"boneName cannot be null.\");\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (bone.data.name == boneName) return bone;\n                }\n                return null;\n            };\n            Skeleton.prototype.findBoneIndex = function (boneName) {\n                if (boneName == null) throw new Error(\"boneName cannot be null.\");\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    if (bones[i].data.name == boneName) return i;\n                }return -1;\n            };\n            Skeleton.prototype.findSlot = function (slotName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    var slot = slots[i];\n                    if (slot.data.name == slotName) return slot;\n                }\n                return null;\n            };\n            Skeleton.prototype.findSlotIndex = function (slotName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    if (slots[i].data.name == slotName) return i;\n                }return -1;\n            };\n            Skeleton.prototype.setSkinByName = function (skinName) {\n                var skin = this.data.findSkin(skinName);\n                if (skin == null) throw new Error(\"Skin not found: \" + skinName);\n                this.setSkin(skin);\n            };\n            Skeleton.prototype.setSkin = function (newSkin) {\n                if (newSkin != null) {\n                    if (this.skin != null) newSkin.attachAll(this, this.skin);else {\n                        var slots = this.slots;\n                        for (var i = 0, n = slots.length; i < n; i++) {\n                            var slot = slots[i];\n                            var name_1 = slot.data.attachmentName;\n                            if (name_1 != null) {\n                                var attachment = newSkin.getAttachment(i, name_1);\n                                if (attachment != null) slot.setAttachment(attachment);\n                            }\n                        }\n                    }\n                }\n                this.skin = newSkin;\n            };\n            Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\n                return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n            };\n            Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\n                if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\n                if (this.skin != null) {\n                    var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n                    if (attachment != null) return attachment;\n                }\n                if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n                return null;\n            };\n            Skeleton.prototype.setAttachment = function (slotName, attachmentName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    var slot = slots[i];\n                    if (slot.data.name == slotName) {\n                        var attachment = null;\n                        if (attachmentName != null) {\n                            attachment = this.getAttachment(i, attachmentName);\n                            if (attachment == null) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                        }\n                        slot.setAttachment(attachment);\n                        return;\n                    }\n                }\n                throw new Error(\"Slot not found: \" + slotName);\n            };\n            Skeleton.prototype.findIkConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var ikConstraints = this.ikConstraints;\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                    var ikConstraint = ikConstraints[i];\n                    if (ikConstraint.data.name == constraintName) return ikConstraint;\n                }\n                return null;\n            };\n            Skeleton.prototype.findTransformConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var transformConstraints = this.transformConstraints;\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                    var constraint = transformConstraints[i];\n                    if (constraint.data.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            Skeleton.prototype.findPathConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var pathConstraints = this.pathConstraints;\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                    var constraint = pathConstraints[i];\n                    if (constraint.data.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            Skeleton.prototype.getBounds = function (offset, size, temp) {\n                if (offset == null) throw new Error(\"offset cannot be null.\");\n                if (size == null) throw new Error(\"size cannot be null.\");\n                var drawOrder = this.drawOrder;\n                var minX = Number.POSITIVE_INFINITY,\n                    minY = Number.POSITIVE_INFINITY,\n                    maxX = Number.NEGATIVE_INFINITY,\n                    maxY = Number.NEGATIVE_INFINITY;\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\n                    var slot = drawOrder[i];\n                    var verticesLength = 0;\n                    var vertices = null;\n                    var attachment = slot.getAttachment();\n                    if (attachment instanceof core.RegionAttachment) {\n                        verticesLength = 8;\n                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);\n                        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n                    } else if (attachment instanceof core.MeshAttachment) {\n                        var mesh = attachment;\n                        verticesLength = mesh.worldVerticesLength;\n                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);\n                        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n                    }\n                    if (vertices != null) {\n                        for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                            var x = vertices[ii],\n                                y = vertices[ii + 1];\n                            minX = Math.min(minX, x);\n                            minY = Math.min(minY, y);\n                            maxX = Math.max(maxX, x);\n                            maxY = Math.max(maxY, y);\n                        }\n                    }\n                }\n                offset.set(minX, minY);\n                size.set(maxX - minX, maxY - minY);\n            };\n            Skeleton.prototype.update = function (delta) {\n                this.time += delta;\n            };\n            return Skeleton;\n        }();\n        core.Skeleton = Skeleton;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SkeletonBounds = function () {\n            function SkeletonBounds() {\n                this.minX = 0;\n                this.minY = 0;\n                this.maxX = 0;\n                this.maxY = 0;\n                this.boundingBoxes = new Array();\n                this.polygons = new Array();\n                this.polygonPool = new core.Pool(function () {\n                    return core.Utils.newFloatArray(16);\n                });\n            }\n            SkeletonBounds.prototype.update = function (skeleton, updateAabb) {\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                var boundingBoxes = this.boundingBoxes;\n                var polygons = this.polygons;\n                var polygonPool = this.polygonPool;\n                var slots = skeleton.slots;\n                var slotCount = slots.length;\n                boundingBoxes.length = 0;\n                polygonPool.freeAll(polygons);\n                polygons.length = 0;\n                for (var i = 0; i < slotCount; i++) {\n                    var slot = slots[i];\n                    var attachment = slot.getAttachment();\n                    if (attachment instanceof core.BoundingBoxAttachment) {\n                        var boundingBox = attachment;\n                        boundingBoxes.push(boundingBox);\n                        var polygon = polygonPool.obtain();\n                        if (polygon.length != boundingBox.worldVerticesLength) {\n                            polygon = core.Utils.newFloatArray(boundingBox.worldVerticesLength);\n                        }\n                        polygons.push(polygon);\n                        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n                    }\n                }\n                if (updateAabb) {\n                    this.aabbCompute();\n                } else {\n                    this.minX = Number.POSITIVE_INFINITY;\n                    this.minY = Number.POSITIVE_INFINITY;\n                    this.maxX = Number.NEGATIVE_INFINITY;\n                    this.maxY = Number.NEGATIVE_INFINITY;\n                }\n            };\n            SkeletonBounds.prototype.aabbCompute = function () {\n                var minX = Number.POSITIVE_INFINITY,\n                    minY = Number.POSITIVE_INFINITY,\n                    maxX = Number.NEGATIVE_INFINITY,\n                    maxY = Number.NEGATIVE_INFINITY;\n                var polygons = this.polygons;\n                for (var i = 0, n = polygons.length; i < n; i++) {\n                    var polygon = polygons[i];\n                    var vertices = polygon;\n                    for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                        var x = vertices[ii];\n                        var y = vertices[ii + 1];\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n                this.minX = minX;\n                this.minY = minY;\n                this.maxX = maxX;\n                this.maxY = maxY;\n            };\n            SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\n                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n            };\n            SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\n                var minX = this.minX;\n                var minY = this.minY;\n                var maxX = this.maxX;\n                var maxY = this.maxY;\n                if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;\n                var m = (y2 - y1) / (x2 - x1);\n                var y = m * (minX - x1) + y1;\n                if (y > minY && y < maxY) return true;\n                y = m * (maxX - x1) + y1;\n                if (y > minY && y < maxY) return true;\n                var x = (minY - y1) / m + x1;\n                if (x > minX && x < maxX) return true;\n                x = (maxY - y1) / m + x1;\n                if (x > minX && x < maxX) return true;\n                return false;\n            };\n            SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\n                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n            };\n            SkeletonBounds.prototype.containsPoint = function (x, y) {\n                var polygons = this.polygons;\n                for (var i = 0, n = polygons.length; i < n; i++) {\n                    if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n                }return null;\n            };\n            SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\n                var vertices = polygon;\n                var nn = polygon.length;\n                var prevIndex = nn - 2;\n                var inside = false;\n                for (var ii = 0; ii < nn; ii += 2) {\n                    var vertexY = vertices[ii + 1];\n                    var prevY = vertices[prevIndex + 1];\n                    if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {\n                        var vertexX = vertices[ii];\n                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n                    }\n                    prevIndex = ii;\n                }\n                return inside;\n            };\n            SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\n                var polygons = this.polygons;\n                for (var i = 0, n = polygons.length; i < n; i++) {\n                    if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n                }return null;\n            };\n            SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\n                var vertices = polygon;\n                var nn = polygon.length;\n                var width12 = x1 - x2,\n                    height12 = y1 - y2;\n                var det1 = x1 * y2 - y1 * x2;\n                var x3 = vertices[nn - 2],\n                    y3 = vertices[nn - 1];\n                for (var ii = 0; ii < nn; ii += 2) {\n                    var x4 = vertices[ii],\n                        y4 = vertices[ii + 1];\n                    var det2 = x3 * y4 - y3 * x4;\n                    var width34 = x3 - x4,\n                        height34 = y3 - y4;\n                    var det3 = width12 * height34 - height12 * width34;\n                    var x = (det1 * width34 - width12 * det2) / det3;\n                    if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {\n                        var y = (det1 * height34 - height12 * det2) / det3;\n                        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;\n                    }\n                    x3 = x4;\n                    y3 = y4;\n                }\n                return false;\n            };\n            SkeletonBounds.prototype.getPolygon = function (boundingBox) {\n                if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\n                var index = this.boundingBoxes.indexOf(boundingBox);\n                return index == -1 ? null : this.polygons[index];\n            };\n            SkeletonBounds.prototype.getWidth = function () {\n                return this.maxX - this.minX;\n            };\n            SkeletonBounds.prototype.getHeight = function () {\n                return this.maxY - this.minY;\n            };\n            return SkeletonBounds;\n        }();\n        core.SkeletonBounds = SkeletonBounds;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SkeletonClipping = function () {\n            function SkeletonClipping() {\n                this.triangulator = new core.Triangulator();\n                this.clippingPolygon = new Array();\n                this.clipOutput = new Array();\n                this.clippedVertices = new Array();\n                this.clippedTriangles = new Array();\n                this.scratch = new Array();\n            }\n            SkeletonClipping.prototype.clipStart = function (slot, clip) {\n                if (this.clipAttachment != null) return 0;\n                this.clipAttachment = clip;\n                var n = clip.worldVerticesLength;\n                var vertices = core.Utils.setArraySize(this.clippingPolygon, n);\n                clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n                var clippingPolygon = this.clippingPolygon;\n                SkeletonClipping.makeClockwise(clippingPolygon);\n                var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n                for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {\n                    var polygon = clippingPolygons[i];\n                    SkeletonClipping.makeClockwise(polygon);\n                    polygon.push(polygon[0]);\n                    polygon.push(polygon[1]);\n                }\n                return clippingPolygons.length;\n            };\n            SkeletonClipping.prototype.clipEndWithSlot = function (slot) {\n                if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd();\n            };\n            SkeletonClipping.prototype.clipEnd = function () {\n                if (this.clipAttachment == null) return;\n                this.clipAttachment = null;\n                this.clippingPolygons = null;\n                this.clippedVertices.length = 0;\n                this.clippedTriangles.length = 0;\n                this.clippingPolygon.length = 0;\n            };\n            SkeletonClipping.prototype.isClipping = function () {\n                return this.clipAttachment != null;\n            };\n            SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\n                var clipOutput = this.clipOutput,\n                    clippedVertices = this.clippedVertices;\n                var clippedTriangles = this.clippedTriangles;\n                var polygons = this.clippingPolygons;\n                var polygonsCount = this.clippingPolygons.length;\n                var vertexSize = twoColor ? 12 : 8;\n                var index = 0;\n                clippedVertices.length = 0;\n                clippedTriangles.length = 0;\n                outer: for (var i = 0; i < trianglesLength; i += 3) {\n                    var vertexOffset = triangles[i] << 1;\n                    var x1 = vertices[vertexOffset],\n                        y1 = vertices[vertexOffset + 1];\n                    var u1 = uvs[vertexOffset],\n                        v1 = uvs[vertexOffset + 1];\n                    vertexOffset = triangles[i + 1] << 1;\n                    var x2 = vertices[vertexOffset],\n                        y2 = vertices[vertexOffset + 1];\n                    var u2 = uvs[vertexOffset],\n                        v2 = uvs[vertexOffset + 1];\n                    vertexOffset = triangles[i + 2] << 1;\n                    var x3 = vertices[vertexOffset],\n                        y3 = vertices[vertexOffset + 1];\n                    var u3 = uvs[vertexOffset],\n                        v3 = uvs[vertexOffset + 1];\n                    for (var p = 0; p < polygonsCount; p++) {\n                        var s = clippedVertices.length;\n                        if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n                            var clipOutputLength = clipOutput.length;\n                            if (clipOutputLength == 0) continue;\n                            var d0 = y2 - y3,\n                                d1 = x3 - x2,\n                                d2 = x1 - x3,\n                                d4 = y3 - y1;\n                            var d = 1 / (d0 * d2 + d1 * (y1 - y3));\n                            var clipOutputCount = clipOutputLength >> 1;\n                            var clipOutputItems = this.clipOutput;\n                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n                            for (var ii = 0; ii < clipOutputLength; ii += 2) {\n                                var x = clipOutputItems[ii],\n                                    y = clipOutputItems[ii + 1];\n                                clippedVerticesItems[s] = x;\n                                clippedVerticesItems[s + 1] = y;\n                                clippedVerticesItems[s + 2] = light.r;\n                                clippedVerticesItems[s + 3] = light.g;\n                                clippedVerticesItems[s + 4] = light.b;\n                                clippedVerticesItems[s + 5] = light.a;\n                                var c0 = x - x3,\n                                    c1 = y - y3;\n                                var a = (d0 * c0 + d1 * c1) * d;\n                                var b = (d4 * c0 + d2 * c1) * d;\n                                var c = 1 - a - b;\n                                clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n                                clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n                                if (twoColor) {\n                                    clippedVerticesItems[s + 8] = dark.r;\n                                    clippedVerticesItems[s + 9] = dark.g;\n                                    clippedVerticesItems[s + 10] = dark.b;\n                                    clippedVerticesItems[s + 11] = dark.a;\n                                }\n                                s += vertexSize;\n                            }\n                            s = clippedTriangles.length;\n                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n                            clipOutputCount--;\n                            for (var ii = 1; ii < clipOutputCount; ii++) {\n                                clippedTrianglesItems[s] = index;\n                                clippedTrianglesItems[s + 1] = index + ii;\n                                clippedTrianglesItems[s + 2] = index + ii + 1;\n                                s += 3;\n                            }\n                            index += clipOutputCount + 1;\n                        } else {\n                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n                            clippedVerticesItems[s] = x1;\n                            clippedVerticesItems[s + 1] = y1;\n                            clippedVerticesItems[s + 2] = light.r;\n                            clippedVerticesItems[s + 3] = light.g;\n                            clippedVerticesItems[s + 4] = light.b;\n                            clippedVerticesItems[s + 5] = light.a;\n                            if (!twoColor) {\n                                clippedVerticesItems[s + 6] = u1;\n                                clippedVerticesItems[s + 7] = v1;\n                                clippedVerticesItems[s + 8] = x2;\n                                clippedVerticesItems[s + 9] = y2;\n                                clippedVerticesItems[s + 10] = light.r;\n                                clippedVerticesItems[s + 11] = light.g;\n                                clippedVerticesItems[s + 12] = light.b;\n                                clippedVerticesItems[s + 13] = light.a;\n                                clippedVerticesItems[s + 14] = u2;\n                                clippedVerticesItems[s + 15] = v2;\n                                clippedVerticesItems[s + 16] = x3;\n                                clippedVerticesItems[s + 17] = y3;\n                                clippedVerticesItems[s + 18] = light.r;\n                                clippedVerticesItems[s + 19] = light.g;\n                                clippedVerticesItems[s + 20] = light.b;\n                                clippedVerticesItems[s + 21] = light.a;\n                                clippedVerticesItems[s + 22] = u3;\n                                clippedVerticesItems[s + 23] = v3;\n                            } else {\n                                clippedVerticesItems[s + 6] = u1;\n                                clippedVerticesItems[s + 7] = v1;\n                                clippedVerticesItems[s + 8] = dark.r;\n                                clippedVerticesItems[s + 9] = dark.g;\n                                clippedVerticesItems[s + 10] = dark.b;\n                                clippedVerticesItems[s + 11] = dark.a;\n                                clippedVerticesItems[s + 12] = x2;\n                                clippedVerticesItems[s + 13] = y2;\n                                clippedVerticesItems[s + 14] = light.r;\n                                clippedVerticesItems[s + 15] = light.g;\n                                clippedVerticesItems[s + 16] = light.b;\n                                clippedVerticesItems[s + 17] = light.a;\n                                clippedVerticesItems[s + 18] = u2;\n                                clippedVerticesItems[s + 19] = v2;\n                                clippedVerticesItems[s + 20] = dark.r;\n                                clippedVerticesItems[s + 21] = dark.g;\n                                clippedVerticesItems[s + 22] = dark.b;\n                                clippedVerticesItems[s + 23] = dark.a;\n                                clippedVerticesItems[s + 24] = x3;\n                                clippedVerticesItems[s + 25] = y3;\n                                clippedVerticesItems[s + 26] = light.r;\n                                clippedVerticesItems[s + 27] = light.g;\n                                clippedVerticesItems[s + 28] = light.b;\n                                clippedVerticesItems[s + 29] = light.a;\n                                clippedVerticesItems[s + 30] = u3;\n                                clippedVerticesItems[s + 31] = v3;\n                                clippedVerticesItems[s + 32] = dark.r;\n                                clippedVerticesItems[s + 33] = dark.g;\n                                clippedVerticesItems[s + 34] = dark.b;\n                                clippedVerticesItems[s + 35] = dark.a;\n                            }\n                            s = clippedTriangles.length;\n                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3);\n                            clippedTrianglesItems[s] = index;\n                            clippedTrianglesItems[s + 1] = index + 1;\n                            clippedTrianglesItems[s + 2] = index + 2;\n                            index += 3;\n                            continue outer;\n                        }\n                    }\n                }\n            };\n            SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\n                var originalOutput = output;\n                var clipped = false;\n                var input = null;\n                if (clippingArea.length % 4 >= 2) {\n                    input = output;\n                    output = this.scratch;\n                } else input = this.scratch;\n                input.length = 0;\n                input.push(x1);\n                input.push(y1);\n                input.push(x2);\n                input.push(y2);\n                input.push(x3);\n                input.push(y3);\n                input.push(x1);\n                input.push(y1);\n                output.length = 0;\n                var clippingVertices = clippingArea;\n                var clippingVerticesLast = clippingArea.length - 4;\n                for (var i = 0;; i += 2) {\n                    var edgeX = clippingVertices[i],\n                        edgeY = clippingVertices[i + 1];\n                    var edgeX2 = clippingVertices[i + 2],\n                        edgeY2 = clippingVertices[i + 3];\n                    var deltaX = edgeX - edgeX2,\n                        deltaY = edgeY - edgeY2;\n                    var inputVertices = input;\n                    var inputVerticesLength = input.length - 2,\n                        outputStart = output.length;\n                    for (var ii = 0; ii < inputVerticesLength; ii += 2) {\n                        var inputX = inputVertices[ii],\n                            inputY = inputVertices[ii + 1];\n                        var inputX2 = inputVertices[ii + 2],\n                            inputY2 = inputVertices[ii + 3];\n                        var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n                            if (side2) {\n                                output.push(inputX2);\n                                output.push(inputY2);\n                                continue;\n                            }\n                            var c0 = inputY2 - inputY,\n                                c2 = inputX2 - inputX;\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\n                        } else if (side2) {\n                            var c0 = inputY2 - inputY,\n                                c2 = inputX2 - inputX;\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\n                            output.push(inputX2);\n                            output.push(inputY2);\n                        }\n                        clipped = true;\n                    }\n                    if (outputStart == output.length) {\n                        originalOutput.length = 0;\n                        return true;\n                    }\n                    output.push(output[0]);\n                    output.push(output[1]);\n                    if (i == clippingVerticesLast) break;\n                    var temp = output;\n                    output = input;\n                    output.length = 0;\n                    input = temp;\n                }\n                if (originalOutput != output) {\n                    originalOutput.length = 0;\n                    for (var i = 0, n = output.length - 2; i < n; i++) {\n                        originalOutput[i] = output[i];\n                    }\n                } else originalOutput.length = originalOutput.length - 2;\n                return clipped;\n            };\n            SkeletonClipping.makeClockwise = function (polygon) {\n                var vertices = polygon;\n                var verticeslength = polygon.length;\n                var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1],\n                    p1x = 0,\n                    p1y = 0,\n                    p2x = 0,\n                    p2y = 0;\n                for (var i = 0, n = verticeslength - 3; i < n; i += 2) {\n                    p1x = vertices[i];\n                    p1y = vertices[i + 1];\n                    p2x = vertices[i + 2];\n                    p2y = vertices[i + 3];\n                    area += p1x * p2y - p2x * p1y;\n                }\n                if (area < 0) return;\n                for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n                    var x = vertices[i],\n                        y = vertices[i + 1];\n                    var other = lastX - i;\n                    vertices[i] = vertices[other];\n                    vertices[i + 1] = vertices[other + 1];\n                    vertices[other] = x;\n                    vertices[other + 1] = y;\n                }\n            };\n            return SkeletonClipping;\n        }();\n        core.SkeletonClipping = SkeletonClipping;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SkeletonData = function () {\n            function SkeletonData() {\n                this.bones = new Array();\n                this.slots = new Array();\n                this.skins = new Array();\n                this.events = new Array();\n                this.animations = new Array();\n                this.ikConstraints = new Array();\n                this.transformConstraints = new Array();\n                this.pathConstraints = new Array();\n                this.fps = 0;\n            }\n            SkeletonData.prototype.findBone = function (boneName) {\n                if (boneName == null) throw new Error(\"boneName cannot be null.\");\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (bone.name == boneName) return bone;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findBoneIndex = function (boneName) {\n                if (boneName == null) throw new Error(\"boneName cannot be null.\");\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    if (bones[i].name == boneName) return i;\n                }return -1;\n            };\n            SkeletonData.prototype.findSlot = function (slotName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    var slot = slots[i];\n                    if (slot.name == slotName) return slot;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findSlotIndex = function (slotName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    if (slots[i].name == slotName) return i;\n                }return -1;\n            };\n            SkeletonData.prototype.findSkin = function (skinName) {\n                if (skinName == null) throw new Error(\"skinName cannot be null.\");\n                var skins = this.skins;\n                for (var i = 0, n = skins.length; i < n; i++) {\n                    var skin = skins[i];\n                    if (skin.name == skinName) return skin;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findEvent = function (eventDataName) {\n                if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\n                var events = this.events;\n                for (var i = 0, n = events.length; i < n; i++) {\n                    var event_4 = events[i];\n                    if (event_4.name == eventDataName) return event_4;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findAnimation = function (animationName) {\n                if (animationName == null) throw new Error(\"animationName cannot be null.\");\n                var animations = this.animations;\n                for (var i = 0, n = animations.length; i < n; i++) {\n                    var animation = animations[i];\n                    if (animation.name == animationName) return animation;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findIkConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var ikConstraints = this.ikConstraints;\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                    var constraint = ikConstraints[i];\n                    if (constraint.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findTransformConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var transformConstraints = this.transformConstraints;\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                    var constraint = transformConstraints[i];\n                    if (constraint.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findPathConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var pathConstraints = this.pathConstraints;\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                    var constraint = pathConstraints[i];\n                    if (constraint.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\n                if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n                var pathConstraints = this.pathConstraints;\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                    if (pathConstraints[i].name == pathConstraintName) return i;\n                }return -1;\n            };\n            return SkeletonData;\n        }();\n        core.SkeletonData = SkeletonData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SkeletonJson = function () {\n            function SkeletonJson(attachmentLoader) {\n                this.scale = 1;\n                this.linkedMeshes = new Array();\n                this.attachmentLoader = attachmentLoader;\n            }\n            SkeletonJson.prototype.readSkeletonData = function (json) {\n                var scale = this.scale;\n                var skeletonData = new core.SkeletonData();\n                var root = typeof json === \"string\" ? JSON.parse(json) : json;\n                var skeletonMap = root.skeleton;\n                if (skeletonMap != null) {\n                    skeletonData.hash = skeletonMap.hash;\n                    skeletonData.version = skeletonMap.spine;\n                    skeletonData.width = skeletonMap.width;\n                    skeletonData.height = skeletonMap.height;\n                    skeletonData.fps = skeletonMap.fps;\n                    skeletonData.imagesPath = skeletonMap.images;\n                }\n                if (root.bones) {\n                    for (var i = 0; i < root.bones.length; i++) {\n                        var boneMap = root.bones[i];\n                        var parent_2 = null;\n                        var parentName = this.getValue(boneMap, \"parent\", null);\n                        if (parentName != null) {\n                            parent_2 = skeletonData.findBone(parentName);\n                            if (parent_2 == null) throw new Error(\"Parent bone not found: \" + parentName);\n                        }\n                        var data = new core.BoneData(skeletonData.bones.length, boneMap.name, parent_2);\n                        data.length = this.getValue(boneMap, \"length\", 0) * scale;\n                        data.x = this.getValue(boneMap, \"x\", 0) * scale;\n                        data.y = this.getValue(boneMap, \"y\", 0) * scale;\n                        data.rotation = this.getValue(boneMap, \"rotation\", 0);\n                        data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n                        data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n                        data.shearX = this.getValue(boneMap, \"shearX\", 0);\n                        data.shearY = this.getValue(boneMap, \"shearY\", 0);\n                        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n                        skeletonData.bones.push(data);\n                    }\n                }\n                if (root.slots) {\n                    for (var i = 0; i < root.slots.length; i++) {\n                        var slotMap = root.slots[i];\n                        var slotName = slotMap.name;\n                        var boneName = slotMap.bone;\n                        var boneData = skeletonData.findBone(boneName);\n                        if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n                        var data = new core.SlotData(skeletonData.slots.length, slotName, boneData);\n                        var color = this.getValue(slotMap, \"color\", null);\n                        if (color != null) data.color.setFromString(color);\n                        var dark = this.getValue(slotMap, \"dark\", null);\n                        if (dark != null) {\n                            data.darkColor = new core.Color(1, 1, 1, 1);\n                            data.darkColor.setFromString(dark);\n                        }\n                        data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n                        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n                        skeletonData.slots.push(data);\n                    }\n                }\n                if (root.ik) {\n                    for (var i = 0; i < root.ik.length; i++) {\n                        var constraintMap = root.ik[i];\n                        var data = new core.IkConstraintData(constraintMap.name);\n                        data.order = this.getValue(constraintMap, \"order\", 0);\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\n                            var boneName = constraintMap.bones[j];\n                            var bone = skeletonData.findBone(boneName);\n                            if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n                            data.bones.push(bone);\n                        }\n                        var targetName = constraintMap.target;\n                        data.target = skeletonData.findBone(targetName);\n                        if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\n                        data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n                        data.mix = this.getValue(constraintMap, \"mix\", 1);\n                        skeletonData.ikConstraints.push(data);\n                    }\n                }\n                if (root.transform) {\n                    for (var i = 0; i < root.transform.length; i++) {\n                        var constraintMap = root.transform[i];\n                        var data = new core.TransformConstraintData(constraintMap.name);\n                        data.order = this.getValue(constraintMap, \"order\", 0);\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\n                            var boneName = constraintMap.bones[j];\n                            var bone = skeletonData.findBone(boneName);\n                            if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                            data.bones.push(bone);\n                        }\n                        var targetName = constraintMap.target;\n                        data.target = skeletonData.findBone(targetName);\n                        if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n                        data.local = this.getValue(constraintMap, \"local\", false);\n                        data.relative = this.getValue(constraintMap, \"relative\", false);\n                        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                        data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n                        data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n                        data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n                        data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n                        data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n                        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                        data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n                        data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n                        skeletonData.transformConstraints.push(data);\n                    }\n                }\n                if (root.path) {\n                    for (var i = 0; i < root.path.length; i++) {\n                        var constraintMap = root.path[i];\n                        var data = new core.PathConstraintData(constraintMap.name);\n                        data.order = this.getValue(constraintMap, \"order\", 0);\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\n                            var boneName = constraintMap.bones[j];\n                            var bone = skeletonData.findBone(boneName);\n                            if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                            data.bones.push(bone);\n                        }\n                        var targetName = constraintMap.target;\n                        data.target = skeletonData.findSlot(targetName);\n                        if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n                        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n                        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n                        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n                        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                        data.position = this.getValue(constraintMap, \"position\", 0);\n                        if (data.positionMode == core.PositionMode.Fixed) data.position *= scale;\n                        data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n                        if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed) data.spacing *= scale;\n                        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                        skeletonData.pathConstraints.push(data);\n                    }\n                }\n                if (root.skins) {\n                    for (var skinName in root.skins) {\n                        var skinMap = root.skins[skinName];\n                        var skin = new core.Skin(skinName);\n                        for (var slotName in skinMap) {\n                            var slotIndex = skeletonData.findSlotIndex(slotName);\n                            if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                            var slotMap = skinMap[slotName];\n                            for (var entryName in slotMap) {\n                                var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n                                if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                            }\n                        }\n                        skeletonData.skins.push(skin);\n                        if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n                    }\n                }\n                for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\n                    var linkedMesh = this.linkedMeshes[i];\n                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n                    if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n                    var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n                    if (parent_3 == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n                    linkedMesh.mesh.setParentMesh(parent_3);\n                }\n                this.linkedMeshes.length = 0;\n                if (root.events) {\n                    for (var eventName in root.events) {\n                        var eventMap = root.events[eventName];\n                        var data = new core.EventData(eventName);\n                        data.intValue = this.getValue(eventMap, \"int\", 0);\n                        data.floatValue = this.getValue(eventMap, \"float\", 0);\n                        data.stringValue = this.getValue(eventMap, \"string\", \"\");\n                        skeletonData.events.push(data);\n                    }\n                }\n                if (root.animations) {\n                    for (var animationName in root.animations) {\n                        var animationMap = root.animations[animationName];\n                        this.readAnimation(animationMap, animationName, skeletonData);\n                    }\n                }\n                return skeletonData;\n            };\n            SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\n                var scale = this.scale;\n                name = this.getValue(map, \"name\", name);\n                var type = this.getValue(map, \"type\", \"region\");\n                switch (type) {\n                    case \"region\":\n                        {\n                            var path = this.getValue(map, \"path\", name);\n                            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n                            if (region == null) return null;\n                            region.path = path;\n                            region.x = this.getValue(map, \"x\", 0) * scale;\n                            region.y = this.getValue(map, \"y\", 0) * scale;\n                            region.scaleX = this.getValue(map, \"scaleX\", 1);\n                            region.scaleY = this.getValue(map, \"scaleY\", 1);\n                            region.rotation = this.getValue(map, \"rotation\", 0);\n                            region.width = map.width * scale;\n                            region.height = map.height * scale;\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) region.color.setFromString(color);\n                            return region;\n                        }\n                    case \"boundingbox\":\n                        {\n                            var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n                            if (box == null) return null;\n                            this.readVertices(map, box, map.vertexCount << 1);\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) box.color.setFromString(color);\n                            return box;\n                        }\n                    case \"mesh\":\n                    case \"linkedmesh\":\n                        {\n                            var path = this.getValue(map, \"path\", name);\n                            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                            if (mesh == null) return null;\n                            mesh.path = path;\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) mesh.color.setFromString(color);\n                            var parent_4 = this.getValue(map, \"parent\", null);\n                            if (parent_4 != null) {\n                                mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                                this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_4));\n                                return mesh;\n                            }\n                            var uvs = map.uvs;\n                            this.readVertices(map, mesh, uvs.length);\n                            mesh.triangles = map.triangles;\n                            mesh.regionUVs = uvs;\n                            mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n                            return mesh;\n                        }\n                    case \"path\":\n                        {\n                            var path = this.attachmentLoader.newPathAttachment(skin, name);\n                            if (path == null) return null;\n                            path.closed = this.getValue(map, \"closed\", false);\n                            path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n                            var vertexCount = map.vertexCount;\n                            this.readVertices(map, path, vertexCount << 1);\n                            var lengths = core.Utils.newArray(vertexCount / 3, 0);\n                            for (var i = 0; i < map.lengths.length; i++) {\n                                lengths[i] = map.lengths[i] * scale;\n                            }path.lengths = lengths;\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) path.color.setFromString(color);\n                            return path;\n                        }\n                    case \"point\":\n                        {\n                            var point = this.attachmentLoader.newPointAttachment(skin, name);\n                            if (point == null) return null;\n                            point.x = this.getValue(map, \"x\", 0) * scale;\n                            point.y = this.getValue(map, \"y\", 0) * scale;\n                            point.rotation = this.getValue(map, \"rotation\", 0);\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) point.color.setFromString(color);\n                            return point;\n                        }\n                    case \"clipping\":\n                        {\n                            var clip = this.attachmentLoader.newClippingAttachment(skin, name);\n                            if (clip == null) return null;\n                            var end = this.getValue(map, \"end\", null);\n                            if (end != null) {\n                                var slot = skeletonData.findSlot(end);\n                                if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\n                                clip.endSlot = slot;\n                            }\n                            var vertexCount = map.vertexCount;\n                            this.readVertices(map, clip, vertexCount << 1);\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) clip.color.setFromString(color);\n                            return clip;\n                        }\n                }\n                return null;\n            };\n            SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\n                var scale = this.scale;\n                attachment.worldVerticesLength = verticesLength;\n                var vertices = map.vertices;\n                if (verticesLength == vertices.length) {\n                    var scaledVertices = core.Utils.toFloatArray(vertices);\n                    if (scale != 1) {\n                        for (var i = 0, n = vertices.length; i < n; i++) {\n                            scaledVertices[i] *= scale;\n                        }\n                    }\n                    attachment.vertices = scaledVertices;\n                    return;\n                }\n                var weights = new Array();\n                var bones = new Array();\n                for (var i = 0, n = vertices.length; i < n;) {\n                    var boneCount = vertices[i++];\n                    bones.push(boneCount);\n                    for (var nn = i + boneCount * 4; i < nn; i += 4) {\n                        bones.push(vertices[i]);\n                        weights.push(vertices[i + 1] * scale);\n                        weights.push(vertices[i + 2] * scale);\n                        weights.push(vertices[i + 3]);\n                    }\n                }\n                attachment.bones = bones;\n                attachment.vertices = core.Utils.toFloatArray(weights);\n            };\n            SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\n                var scale = this.scale;\n                var timelines = new Array();\n                var duration = 0;\n                if (map.slots) {\n                    for (var slotName in map.slots) {\n                        var slotMap = map.slots[slotName];\n                        var slotIndex = skeletonData.findSlotIndex(slotName);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                        for (var timelineName in slotMap) {\n                            var timelineMap = slotMap[timelineName];\n                            if (timelineName == \"attachment\") {\n                                var timeline = new core.AttachmentTimeline(timelineMap.length);\n                                timeline.slotIndex = slotIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                            } else if (timelineName == \"color\") {\n                                var timeline = new core.ColorTimeline(timelineMap.length);\n                                timeline.slotIndex = slotIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    var color = new core.Color();\n                                    color.setFromString(valueMap.color);\n                                    timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.ColorTimeline.ENTRIES]);\n                            } else if (timelineName == \"twoColor\") {\n                                var timeline = new core.TwoColorTimeline(timelineMap.length);\n                                timeline.slotIndex = slotIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    var light = new core.Color();\n                                    var dark = new core.Color();\n                                    light.setFromString(valueMap.light);\n                                    dark.setFromString(valueMap.dark);\n                                    timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TwoColorTimeline.ENTRIES]);\n                            } else throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n                        }\n                    }\n                }\n                if (map.bones) {\n                    for (var boneName in map.bones) {\n                        var boneMap = map.bones[boneName];\n                        var boneIndex = skeletonData.findBoneIndex(boneName);\n                        if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n                        for (var timelineName in boneMap) {\n                            var timelineMap = boneMap[timelineName];\n                            if (timelineName === \"rotate\") {\n                                var timeline = new core.RotateTimeline(timelineMap.length);\n                                timeline.boneIndex = boneIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.RotateTimeline.ENTRIES]);\n                            } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                                var timeline = null;\n                                var timelineScale = 1;\n                                if (timelineName === \"scale\") timeline = new core.ScaleTimeline(timelineMap.length);else if (timelineName === \"shear\") timeline = new core.ShearTimeline(timelineMap.length);else {\n                                    timeline = new core.TranslateTimeline(timelineMap.length);\n                                    timelineScale = scale;\n                                }\n                                timeline.boneIndex = boneIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    var x = this.getValue(valueMap, \"x\", 0),\n                                        y = this.getValue(valueMap, \"y\", 0);\n                                    timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TranslateTimeline.ENTRIES]);\n                            } else throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n                        }\n                    }\n                }\n                if (map.ik) {\n                    for (var constraintName in map.ik) {\n                        var constraintMap = map.ik[constraintName];\n                        var constraint = skeletonData.findIkConstraint(constraintName);\n                        var timeline = new core.IkConstraintTimeline(constraintMap.length);\n                        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                        var frameIndex = 0;\n                        for (var i = 0; i < constraintMap.length; i++) {\n                            var valueMap = constraintMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.IkConstraintTimeline.ENTRIES]);\n                    }\n                }\n                if (map.transform) {\n                    for (var constraintName in map.transform) {\n                        var constraintMap = map.transform[constraintName];\n                        var constraint = skeletonData.findTransformConstraint(constraintName);\n                        var timeline = new core.TransformConstraintTimeline(constraintMap.length);\n                        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                        var frameIndex = 0;\n                        for (var i = 0; i < constraintMap.length; i++) {\n                            var valueMap = constraintMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TransformConstraintTimeline.ENTRIES]);\n                    }\n                }\n                if (map.paths) {\n                    for (var constraintName in map.paths) {\n                        var constraintMap = map.paths[constraintName];\n                        var index = skeletonData.findPathConstraintIndex(constraintName);\n                        if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n                        var data = skeletonData.pathConstraints[index];\n                        for (var timelineName in constraintMap) {\n                            var timelineMap = constraintMap[timelineName];\n                            if (timelineName === \"position\" || timelineName === \"spacing\") {\n                                var timeline = null;\n                                var timelineScale = 1;\n                                if (timelineName === \"spacing\") {\n                                    timeline = new core.PathConstraintSpacingTimeline(timelineMap.length);\n                                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed) timelineScale = scale;\n                                } else {\n                                    timeline = new core.PathConstraintPositionTimeline(timelineMap.length);\n                                    if (data.positionMode == core.PositionMode.Fixed) timelineScale = scale;\n                                }\n                                timeline.pathConstraintIndex = index;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintPositionTimeline.ENTRIES]);\n                            } else if (timelineName === \"mix\") {\n                                var timeline = new core.PathConstraintMixTimeline(timelineMap.length);\n                                timeline.pathConstraintIndex = index;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintMixTimeline.ENTRIES]);\n                            }\n                        }\n                    }\n                }\n                if (map.deform) {\n                    for (var deformName in map.deform) {\n                        var deformMap = map.deform[deformName];\n                        var skin = skeletonData.findSkin(deformName);\n                        if (skin == null) throw new Error(\"Skin not found: \" + deformName);\n                        for (var slotName in deformMap) {\n                            var slotMap = deformMap[slotName];\n                            var slotIndex = skeletonData.findSlotIndex(slotName);\n                            if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n                            for (var timelineName in slotMap) {\n                                var timelineMap = slotMap[timelineName];\n                                var attachment = skin.getAttachment(slotIndex, timelineName);\n                                if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                                var weighted = attachment.bones != null;\n                                var vertices = attachment.vertices;\n                                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n                                var timeline = new core.DeformTimeline(timelineMap.length);\n                                timeline.slotIndex = slotIndex;\n                                timeline.attachment = attachment;\n                                var frameIndex = 0;\n                                for (var j = 0; j < timelineMap.length; j++) {\n                                    var valueMap = timelineMap[j];\n                                    var deform = void 0;\n                                    var verticesValue = this.getValue(valueMap, \"vertices\", null);\n                                    if (verticesValue == null) deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;else {\n                                        deform = core.Utils.newFloatArray(deformLength);\n                                        var start = this.getValue(valueMap, \"offset\", 0);\n                                        core.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                        if (scale != 1) {\n                                            for (var i = start, n = i + verticesValue.length; i < n; i++) {\n                                                deform[i] *= scale;\n                                            }\n                                        }\n                                        if (!weighted) {\n                                            for (var i = 0; i < deformLength; i++) {\n                                                deform[i] += vertices[i];\n                                            }\n                                        }\n                                    }\n                                    timeline.setFrame(frameIndex, valueMap.time, deform);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                            }\n                        }\n                    }\n                }\n                var drawOrderNode = map.drawOrder;\n                if (drawOrderNode == null) drawOrderNode = map.draworder;\n                if (drawOrderNode != null) {\n                    var timeline = new core.DrawOrderTimeline(drawOrderNode.length);\n                    var slotCount = skeletonData.slots.length;\n                    var frameIndex = 0;\n                    for (var j = 0; j < drawOrderNode.length; j++) {\n                        var drawOrderMap = drawOrderNode[j];\n                        var drawOrder = null;\n                        var offsets = this.getValue(drawOrderMap, \"offsets\", null);\n                        if (offsets != null) {\n                            drawOrder = core.Utils.newArray(slotCount, -1);\n                            var unchanged = core.Utils.newArray(slotCount - offsets.length, 0);\n                            var originalIndex = 0,\n                                unchangedIndex = 0;\n                            for (var i = 0; i < offsets.length; i++) {\n                                var offsetMap = offsets[i];\n                                var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                                if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\n                                while (originalIndex != slotIndex) {\n                                    unchanged[unchangedIndex++] = originalIndex++;\n                                }drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                            }\n                            while (originalIndex < slotCount) {\n                                unchanged[unchangedIndex++] = originalIndex++;\n                            }for (var i = slotCount - 1; i >= 0; i--) {\n                                if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                            }\n                        }\n                        timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n                if (map.events) {\n                    var timeline = new core.EventTimeline(map.events.length);\n                    var frameIndex = 0;\n                    for (var i = 0; i < map.events.length; i++) {\n                        var eventMap = map.events[i];\n                        var eventData = skeletonData.findEvent(eventMap.name);\n                        if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\n                        var event_5 = new core.Event(core.Utils.toSinglePrecision(eventMap.time), eventData);\n                        event_5.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n                        event_5.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n                        event_5.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n                        timeline.setFrame(frameIndex++, event_5);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n                if (isNaN(duration)) {\n                    throw new Error(\"Error while parsing animation, duration is NaN\");\n                }\n                skeletonData.animations.push(new core.Animation(name, timelines, duration));\n            };\n            SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\n                if (!map.curve) return;\n                if (map.curve === \"stepped\") timeline.setStepped(frameIndex);else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n                    var curve = map.curve;\n                    timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n                }\n            };\n            SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\n                return map[prop] !== undefined ? map[prop] : defaultValue;\n            };\n            SkeletonJson.blendModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"normal\") return core.BlendMode.Normal;\n                if (str == \"additive\") return core.BlendMode.Additive;\n                if (str == \"multiply\") return core.BlendMode.Multiply;\n                if (str == \"screen\") return core.BlendMode.Screen;\n                throw new Error(\"Unknown blend mode: \" + str);\n            };\n            SkeletonJson.positionModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"fixed\") return core.PositionMode.Fixed;\n                if (str == \"percent\") return core.PositionMode.Percent;\n                throw new Error(\"Unknown position mode: \" + str);\n            };\n            SkeletonJson.spacingModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"length\") return core.SpacingMode.Length;\n                if (str == \"fixed\") return core.SpacingMode.Fixed;\n                if (str == \"percent\") return core.SpacingMode.Percent;\n                throw new Error(\"Unknown position mode: \" + str);\n            };\n            SkeletonJson.rotateModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"tangent\") return core.RotateMode.Tangent;\n                if (str == \"chain\") return core.RotateMode.Chain;\n                if (str == \"chainscale\") return core.RotateMode.ChainScale;\n                throw new Error(\"Unknown rotate mode: \" + str);\n            };\n            SkeletonJson.transformModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"normal\") return core.TransformMode.Normal;\n                if (str == \"onlytranslation\") return core.TransformMode.OnlyTranslation;\n                if (str == \"norotationorreflection\") return core.TransformMode.NoRotationOrReflection;\n                if (str == \"noscale\") return core.TransformMode.NoScale;\n                if (str == \"noscaleorreflection\") return core.TransformMode.NoScaleOrReflection;\n                throw new Error(\"Unknown transform mode: \" + str);\n            };\n            return SkeletonJson;\n        }();\n        core.SkeletonJson = SkeletonJson;\n        var LinkedMesh = function () {\n            function LinkedMesh(mesh, skin, slotIndex, parent) {\n                this.mesh = mesh;\n                this.skin = skin;\n                this.slotIndex = slotIndex;\n                this.parent = parent;\n            }\n            return LinkedMesh;\n        }();\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Skin = function () {\n            function Skin(name) {\n                this.attachments = new Array();\n                if (name == null) throw new Error(\"name cannot be null.\");\n                this.name = name;\n            }\n            Skin.prototype.addAttachment = function (slotIndex, name, attachment) {\n                if (attachment == null) throw new Error(\"attachment cannot be null.\");\n                var attachments = this.attachments;\n                if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n                if (!attachments[slotIndex]) attachments[slotIndex] = {};\n                attachments[slotIndex][name] = attachment;\n            };\n            Skin.prototype.getAttachment = function (slotIndex, name) {\n                var dictionary = this.attachments[slotIndex];\n                return dictionary ? dictionary[name] : null;\n            };\n            Skin.prototype.attachAll = function (skeleton, oldSkin) {\n                var slotIndex = 0;\n                for (var i = 0; i < skeleton.slots.length; i++) {\n                    var slot = skeleton.slots[i];\n                    var slotAttachment = slot.getAttachment();\n                    if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                        var dictionary = oldSkin.attachments[slotIndex];\n                        for (var key in dictionary) {\n                            var skinAttachment = dictionary[key];\n                            if (slotAttachment == skinAttachment) {\n                                var attachment = this.getAttachment(slotIndex, name);\n                                if (attachment != null) slot.setAttachment(attachment);\n                                break;\n                            }\n                        }\n                    }\n                    slotIndex++;\n                }\n            };\n            return Skin;\n        }();\n        core.Skin = Skin;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Slot = function () {\n            function Slot(data, bone) {\n                this.attachmentVertices = new Array();\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (bone == null) throw new Error(\"bone cannot be null.\");\n                this.data = data;\n                this.bone = bone;\n                this.color = new core.Color();\n                this.darkColor = data.darkColor == null ? null : new core.Color();\n                this.setToSetupPose();\n                this.blendMode = this.data.blendMode;\n            }\n            Slot.prototype.getAttachment = function () {\n                return this.attachment;\n            };\n            Slot.prototype.setAttachment = function (attachment) {\n                if (this.attachment == attachment) return;\n                this.attachment = attachment;\n                this.attachmentTime = this.bone.skeleton.time;\n                this.attachmentVertices.length = 0;\n            };\n            Slot.prototype.setAttachmentTime = function (time) {\n                this.attachmentTime = this.bone.skeleton.time - time;\n            };\n            Slot.prototype.getAttachmentTime = function () {\n                return this.bone.skeleton.time - this.attachmentTime;\n            };\n            Slot.prototype.setToSetupPose = function () {\n                this.color.setFromColor(this.data.color);\n                if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n                if (this.data.attachmentName == null) this.attachment = null;else {\n                    this.attachment = null;\n                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n                }\n            };\n            return Slot;\n        }();\n        core.Slot = Slot;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SlotData = function () {\n            function SlotData(index, name, boneData) {\n                this.color = new core.Color(1, 1, 1, 1);\n                if (index < 0) throw new Error(\"index must be >= 0.\");\n                if (name == null) throw new Error(\"name cannot be null.\");\n                if (boneData == null) throw new Error(\"boneData cannot be null.\");\n                this.index = index;\n                this.name = name;\n                this.boneData = boneData;\n            }\n            return SlotData;\n        }();\n        core.SlotData = SlotData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Texture = function () {\n            function Texture(image) {\n                this._image = image;\n            }\n            Texture.prototype.getImage = function () {\n                return this._image;\n            };\n            Texture.filterFromString = function (text) {\n                switch (text.toLowerCase()) {\n                    case \"nearest\":\n                        return TextureFilter.Nearest;\n                    case \"linear\":\n                        return TextureFilter.Linear;\n                    case \"mipmap\":\n                        return TextureFilter.MipMap;\n                    case \"mipmapnearestnearest\":\n                        return TextureFilter.MipMapNearestNearest;\n                    case \"mipmaplinearnearest\":\n                        return TextureFilter.MipMapLinearNearest;\n                    case \"mipmapnearestlinear\":\n                        return TextureFilter.MipMapNearestLinear;\n                    case \"mipmaplinearlinear\":\n                        return TextureFilter.MipMapLinearLinear;\n                    default:\n                        throw new Error(\"Unknown texture filter \" + text);\n                }\n            };\n            Texture.wrapFromString = function (text) {\n                switch (text.toLowerCase()) {\n                    case \"mirroredtepeat\":\n                        return TextureWrap.MirroredRepeat;\n                    case \"clamptoedge\":\n                        return TextureWrap.ClampToEdge;\n                    case \"repeat\":\n                        return TextureWrap.Repeat;\n                    default:\n                        throw new Error(\"Unknown texture wrap \" + text);\n                }\n            };\n            return Texture;\n        }();\n        core.Texture = Texture;\n        var TextureFilter;\n        (function (TextureFilter) {\n            TextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\n            TextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\n            TextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\n            TextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\n            TextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\n            TextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\n            TextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\n        })(TextureFilter = core.TextureFilter || (core.TextureFilter = {}));\n        var TextureWrap;\n        (function (TextureWrap) {\n            TextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\n            TextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\n            TextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\n        })(TextureWrap = core.TextureWrap || (core.TextureWrap = {}));\n        var TextureRegion = function () {\n            function TextureRegion() {\n                this.size = null;\n            }\n            Object.defineProperty(TextureRegion.prototype, \"width\", {\n                get: function get() {\n                    var tex = this.texture;\n                    if (PIXI.VERSION[0] == '3') {\n                        return tex.crop.width;\n                    }\n                    if (tex.trim) {\n                        return tex.trim.width;\n                    }\n                    return tex.orig.width;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"height\", {\n                get: function get() {\n                    var tex = this.texture;\n                    if (PIXI.VERSION[0] == '3') {\n                        return tex.crop.height;\n                    }\n                    if (tex.trim) {\n                        return tex.trim.height;\n                    }\n                    return tex.orig.height;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"u\", {\n                get: function get() {\n                    return this.texture._uvs.x0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"v\", {\n                get: function get() {\n                    return this.texture._uvs.y0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"u2\", {\n                get: function get() {\n                    return this.texture._uvs.x2;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"v2\", {\n                get: function get() {\n                    return this.texture._uvs.y2;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"offsetX\", {\n                get: function get() {\n                    var tex = this.texture;\n                    return tex.trim ? tex.trim.x : 0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"offsetY\", {\n                get: function get() {\n                    console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n                    return this.spineOffsetY;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"pixiOffsetY\", {\n                get: function get() {\n                    var tex = this.texture;\n                    return tex.trim ? tex.trim.y : 0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"spineOffsetY\", {\n                get: function get() {\n                    var tex = this.texture;\n                    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"originalWidth\", {\n                get: function get() {\n                    var tex = this.texture;\n                    if (PIXI.VERSION[0] == '3') {\n                        if (tex.trim) {\n                            return tex.trim.width;\n                        }\n                        return tex.crop.width;\n                    }\n                    return tex.orig.width;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"originalHeight\", {\n                get: function get() {\n                    var tex = this.texture;\n                    if (PIXI.VERSION[0] == '3') {\n                        if (tex.trim) {\n                            return tex.trim.height;\n                        }\n                        return tex.crop.height;\n                    }\n                    return tex.orig.height;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"x\", {\n                get: function get() {\n                    return this.texture.frame.x;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"y\", {\n                get: function get() {\n                    return this.texture.frame.y;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"rotate\", {\n                get: function get() {\n                    return this.texture.rotate !== 0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return TextureRegion;\n        }();\n        core.TextureRegion = TextureRegion;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var TextureAtlas = function () {\n            function TextureAtlas(atlasText, textureLoader, callback) {\n                this.pages = new Array();\n                this.regions = new Array();\n                if (atlasText) {\n                    this.addSpineAtlas(atlasText, textureLoader, callback);\n                }\n            }\n            TextureAtlas.prototype.addTexture = function (name, texture) {\n                var pages = this.pages;\n                var page = null;\n                for (var i = 0; i < pages.length; i++) {\n                    if (pages[i].baseTexture === texture.baseTexture) {\n                        page = pages[i];\n                        break;\n                    }\n                }\n                if (page === null) {\n                    page = new TextureAtlasPage();\n                    page.name = 'texturePage';\n                    var baseTexture = texture.baseTexture;\n                    page.width = baseTexture.realWidth;\n                    page.height = baseTexture.realHeight;\n                    page.baseTexture = baseTexture;\n                    page.minFilter = page.magFilter = core.TextureFilter.Nearest;\n                    page.uWrap = core.TextureWrap.ClampToEdge;\n                    page.vWrap = core.TextureWrap.ClampToEdge;\n                    pages.push(page);\n                }\n                var region = new TextureAtlasRegion();\n                region.name = name;\n                region.page = page;\n                region.texture = texture;\n                region.index = -1;\n                this.regions.push(region);\n                return region;\n            };\n            TextureAtlas.prototype.addTextureHash = function (textures, stripExtension) {\n                for (var key in textures) {\n                    if (textures.hasOwnProperty(key)) {\n                        this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n                    }\n                }\n            };\n            TextureAtlas.prototype.addSpineAtlas = function (atlasText, textureLoader, callback) {\n                return this.load(atlasText, textureLoader, callback);\n            };\n            TextureAtlas.prototype.load = function (atlasText, textureLoader, callback) {\n                var _this = this;\n                if (textureLoader == null) throw new Error(\"textureLoader cannot be null.\");\n                var reader = new TextureAtlasReader(atlasText);\n                var tuple = new Array(4);\n                var page = null;\n                var iterateParser = function iterateParser() {\n                    while (true) {\n                        var line = reader.readLine();\n                        if (line == null) {\n                            return callback && callback(_this);\n                        }\n                        line = line.trim();\n                        if (line.length == 0) page = null;else if (!page) {\n                            page = new TextureAtlasPage();\n                            page.name = line;\n                            if (reader.readTuple(tuple) == 2) {\n                                page.width = parseInt(tuple[0]);\n                                page.height = parseInt(tuple[1]);\n                                reader.readTuple(tuple);\n                            }\n                            reader.readTuple(tuple);\n                            page.minFilter = core.Texture.filterFromString(tuple[0]);\n                            page.magFilter = core.Texture.filterFromString(tuple[1]);\n                            var direction = reader.readValue();\n                            page.uWrap = core.TextureWrap.ClampToEdge;\n                            page.vWrap = core.TextureWrap.ClampToEdge;\n                            if (direction == \"x\") page.uWrap = core.TextureWrap.Repeat;else if (direction == \"y\") page.vWrap = core.TextureWrap.Repeat;else if (direction == \"xy\") page.uWrap = page.vWrap = core.TextureWrap.Repeat;\n                            textureLoader(line, function (texture) {\n                                page.baseTexture = texture;\n                                if (!texture.hasLoaded) {\n                                    texture.width = page.width;\n                                    texture.height = page.height;\n                                }\n                                _this.pages.push(page);\n                                page.setFilters();\n                                if (!page.width || !page.height) {\n                                    page.width = texture.realWidth;\n                                    page.height = texture.realHeight;\n                                    if (!page.width || !page.height) {\n                                        console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                                    }\n                                }\n                                iterateParser();\n                            });\n                            _this.pages.push(page);\n                            break;\n                        } else {\n                            var region = new TextureAtlasRegion();\n                            region.name = line;\n                            region.page = page;\n                            var rotate = reader.readValue() == \"true\" ? 6 : 0;\n                            reader.readTuple(tuple);\n                            var x = parseInt(tuple[0]);\n                            var y = parseInt(tuple[1]);\n                            reader.readTuple(tuple);\n                            var width = parseInt(tuple[0]);\n                            var height = parseInt(tuple[1]);\n                            var resolution = page.baseTexture.resolution;\n                            x /= resolution;\n                            y /= resolution;\n                            width /= resolution;\n                            height /= resolution;\n                            var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n                            if (reader.readTuple(tuple) == 4) {\n                                if (reader.readTuple(tuple) == 4) {\n                                    reader.readTuple(tuple);\n                                }\n                            }\n                            var originalWidth = parseInt(tuple[0]) / resolution;\n                            var originalHeight = parseInt(tuple[1]) / resolution;\n                            reader.readTuple(tuple);\n                            var offsetX = parseInt(tuple[0]) / resolution;\n                            var offsetY = parseInt(tuple[1]) / resolution;\n                            var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n                            var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n                            if (PIXI.VERSION[0] != '3') {\n                                region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\n                            } else {\n                                var frame2 = new PIXI.Rectangle(x, y, width, height);\n                                var crop = frame2.clone();\n                                trim.width = originalWidth;\n                                trim.height = originalHeight;\n                                region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\n                            }\n                            region.index = parseInt(reader.readValue());\n                            region.texture._updateUvs();\n                            _this.regions.push(region);\n                        }\n                    }\n                };\n                iterateParser();\n            };\n            TextureAtlas.prototype.findRegion = function (name) {\n                for (var i = 0; i < this.regions.length; i++) {\n                    if (this.regions[i].name == name) {\n                        return this.regions[i];\n                    }\n                }\n                return null;\n            };\n            TextureAtlas.prototype.dispose = function () {\n                for (var i = 0; i < this.pages.length; i++) {\n                    this.pages[i].baseTexture.dispose();\n                }\n            };\n            return TextureAtlas;\n        }();\n        core.TextureAtlas = TextureAtlas;\n        var TextureAtlasReader = function () {\n            function TextureAtlasReader(text) {\n                this.index = 0;\n                this.lines = text.split(/\\r\\n|\\r|\\n/);\n            }\n            TextureAtlasReader.prototype.readLine = function () {\n                if (this.index >= this.lines.length) return null;\n                return this.lines[this.index++];\n            };\n            TextureAtlasReader.prototype.readValue = function () {\n                var line = this.readLine();\n                var colon = line.indexOf(\":\");\n                if (colon == -1) throw new Error(\"Invalid line: \" + line);\n                return line.substring(colon + 1).trim();\n            };\n            TextureAtlasReader.prototype.readTuple = function (tuple) {\n                var line = this.readLine();\n                var colon = line.indexOf(\":\");\n                if (colon == -1) throw new Error(\"Invalid line: \" + line);\n                var i = 0,\n                    lastMatch = colon + 1;\n                for (; i < 3; i++) {\n                    var comma = line.indexOf(\",\", lastMatch);\n                    if (comma == -1) break;\n                    tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n                    lastMatch = comma + 1;\n                }\n                tuple[i] = line.substring(lastMatch).trim();\n                return i + 1;\n            };\n            return TextureAtlasReader;\n        }();\n        var TextureAtlasPage = function () {\n            function TextureAtlasPage() {}\n            TextureAtlasPage.prototype.setFilters = function () {\n                var tex = this.baseTexture;\n                var filter = this.minFilter;\n                if (filter == core.TextureFilter.Linear) {\n                    tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n                } else if (this.minFilter == core.TextureFilter.Nearest) {\n                    tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n                } else {\n                    tex.mipmap = true;\n                    if (filter == core.TextureFilter.MipMapNearestNearest) {\n                        tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n                    } else {\n                        tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n                    }\n                }\n            };\n            return TextureAtlasPage;\n        }();\n        core.TextureAtlasPage = TextureAtlasPage;\n        var TextureAtlasRegion = function (_super) {\n            __extends(TextureAtlasRegion, _super);\n            function TextureAtlasRegion() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            return TextureAtlasRegion;\n        }(core.TextureRegion);\n        core.TextureAtlasRegion = TextureAtlasRegion;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var TransformConstraint = function () {\n            function TransformConstraint(data, skeleton) {\n                this.rotateMix = 0;\n                this.translateMix = 0;\n                this.scaleMix = 0;\n                this.shearMix = 0;\n                this.temp = new core.Vector2();\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                this.data = data;\n                this.rotateMix = data.rotateMix;\n                this.translateMix = data.translateMix;\n                this.scaleMix = data.scaleMix;\n                this.shearMix = data.shearMix;\n                this.bones = new Array();\n                for (var i = 0; i < data.bones.length; i++) {\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\n                }this.target = skeleton.findBone(data.target.name);\n            }\n            TransformConstraint.prototype.apply = function () {\n                this.update();\n            };\n            TransformConstraint.prototype.update = function () {\n                if (this.data.local) {\n                    if (this.data.relative) this.applyRelativeLocal();else this.applyAbsoluteLocal();\n                } else {\n                    if (this.data.relative) this.applyRelativeWorld();else this.applyAbsoluteWorld();\n                }\n            };\n            TransformConstraint.prototype.applyAbsoluteWorld = function () {\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix,\n                    scaleMix = this.scaleMix,\n                    shearMix = this.shearMix;\n                var target = this.target;\n                var targetMat = target.matrix;\n                var ta = targetMat.a,\n                    tb = targetMat.c,\n                    tc = targetMat.b,\n                    td = targetMat.d;\n                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n                var offsetRotation = this.data.offsetRotation * degRadReflect;\n                var offsetShearY = this.data.offsetShearY * degRadReflect;\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    var modified = false;\n                    var mat = bone.matrix;\n                    if (rotateMix != 0) {\n                        var a = mat.a,\n                            b = mat.c,\n                            c = mat.b,\n                            d = mat.d;\n                        var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        r *= rotateMix;\n                        var cos = Math.cos(r),\n                            sin = Math.sin(r);\n                        mat.a = cos * a - sin * c;\n                        mat.c = cos * b - sin * d;\n                        mat.b = sin * a + cos * c;\n                        mat.d = sin * b + cos * d;\n                        modified = true;\n                    }\n                    if (translateMix != 0) {\n                        var temp = this.temp;\n                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                        mat.tx += (temp.x - mat.tx) * translateMix;\n                        mat.ty += (temp.y - mat.ty) * translateMix;\n                        modified = true;\n                    }\n                    if (scaleMix > 0) {\n                        var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                        var ts = Math.sqrt(ta * ta + tc * tc);\n                        if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                        mat.a *= s;\n                        mat.b *= s;\n                        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                        ts = Math.sqrt(tb * tb + td * td);\n                        if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                        mat.c *= s;\n                        mat.d *= s;\n                        modified = true;\n                    }\n                    if (shearMix > 0) {\n                        var b = mat.c,\n                            d = mat.d;\n                        var by = Math.atan2(d, b);\n                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        r = by + (r + offsetShearY) * shearMix;\n                        var s = Math.sqrt(b * b + d * d);\n                        mat.c = Math.cos(r) * s;\n                        mat.d = Math.sin(r) * s;\n                        modified = true;\n                    }\n                    if (modified) bone.appliedValid = false;\n                }\n            };\n            TransformConstraint.prototype.applyRelativeWorld = function () {\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix,\n                    scaleMix = this.scaleMix,\n                    shearMix = this.shearMix;\n                var target = this.target;\n                var targetMat = target.matrix;\n                var ta = targetMat.a,\n                    tb = targetMat.c,\n                    tc = targetMat.b,\n                    td = targetMat.d;\n                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n                var offsetRotation = this.data.offsetRotation * degRadReflect,\n                    offsetShearY = this.data.offsetShearY * degRadReflect;\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    var modified = false;\n                    var mat = bone.matrix;\n                    if (rotateMix != 0) {\n                        var a = mat.a,\n                            b = mat.c,\n                            c = mat.b,\n                            d = mat.d;\n                        var r = Math.atan2(tc, ta) + offsetRotation;\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        r *= rotateMix;\n                        var cos = Math.cos(r),\n                            sin = Math.sin(r);\n                        mat.a = cos * a - sin * c;\n                        mat.c = cos * b - sin * d;\n                        mat.b = sin * a + cos * c;\n                        mat.d = sin * b + cos * d;\n                        modified = true;\n                    }\n                    if (translateMix != 0) {\n                        var temp = this.temp;\n                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                        mat.tx += temp.x * translateMix;\n                        mat.ty += temp.y * translateMix;\n                        modified = true;\n                    }\n                    if (scaleMix > 0) {\n                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                        mat.a *= s;\n                        mat.b *= s;\n                        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                        mat.c *= s;\n                        mat.d *= s;\n                        modified = true;\n                    }\n                    if (shearMix > 0) {\n                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        var b = mat.c,\n                            d = mat.d;\n                        r = Math.atan2(d, b) + (r - core.MathUtils.PI / 2 + offsetShearY) * shearMix;\n                        var s = Math.sqrt(b * b + d * d);\n                        mat.c = Math.cos(r) * s;\n                        mat.d = Math.sin(r) * s;\n                        modified = true;\n                    }\n                    if (modified) bone.appliedValid = false;\n                }\n            };\n            TransformConstraint.prototype.applyAbsoluteLocal = function () {\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix,\n                    scaleMix = this.scaleMix,\n                    shearMix = this.shearMix;\n                var target = this.target;\n                if (!target.appliedValid) target.updateAppliedTransform();\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (!bone.appliedValid) bone.updateAppliedTransform();\n                    var rotation = bone.arotation;\n                    if (rotateMix != 0) {\n                        var r = target.arotation - rotation + this.data.offsetRotation;\n                        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                        rotation += r * rotateMix;\n                    }\n                    var x = bone.ax,\n                        y = bone.ay;\n                    if (translateMix != 0) {\n                        x += (target.ax - x + this.data.offsetX) * translateMix;\n                        y += (target.ay - y + this.data.offsetY) * translateMix;\n                    }\n                    var scaleX = bone.ascaleX,\n                        scaleY = bone.ascaleY;\n                    if (scaleMix > 0) {\n                        if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                        if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n                    }\n                    var shearY = bone.ashearY;\n                    if (shearMix > 0) {\n                        var r = target.ashearY - shearY + this.data.offsetShearY;\n                        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                        bone.shearY += r * shearMix;\n                    }\n                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n                }\n            };\n            TransformConstraint.prototype.applyRelativeLocal = function () {\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix,\n                    scaleMix = this.scaleMix,\n                    shearMix = this.shearMix;\n                var target = this.target;\n                if (!target.appliedValid) target.updateAppliedTransform();\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (!bone.appliedValid) bone.updateAppliedTransform();\n                    var rotation = bone.arotation;\n                    if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n                    var x = bone.ax,\n                        y = bone.ay;\n                    if (translateMix != 0) {\n                        x += (target.ax + this.data.offsetX) * translateMix;\n                        y += (target.ay + this.data.offsetY) * translateMix;\n                    }\n                    var scaleX = bone.ascaleX,\n                        scaleY = bone.ascaleY;\n                    if (scaleMix > 0) {\n                        if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                        if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                    }\n                    var shearY = bone.ashearY;\n                    if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n                }\n            };\n            TransformConstraint.prototype.getOrder = function () {\n                return this.data.order;\n            };\n            return TransformConstraint;\n        }();\n        core.TransformConstraint = TransformConstraint;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var TransformConstraintData = function () {\n            function TransformConstraintData(name) {\n                this.order = 0;\n                this.bones = new Array();\n                this.rotateMix = 0;\n                this.translateMix = 0;\n                this.scaleMix = 0;\n                this.shearMix = 0;\n                this.offsetRotation = 0;\n                this.offsetX = 0;\n                this.offsetY = 0;\n                this.offsetScaleX = 0;\n                this.offsetScaleY = 0;\n                this.offsetShearY = 0;\n                this.relative = false;\n                this.local = false;\n                if (name == null) throw new Error(\"name cannot be null.\");\n                this.name = name;\n            }\n            return TransformConstraintData;\n        }();\n        core.TransformConstraintData = TransformConstraintData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Triangulator = function () {\n            function Triangulator() {\n                this.convexPolygons = new Array();\n                this.convexPolygonsIndices = new Array();\n                this.indicesArray = new Array();\n                this.isConcaveArray = new Array();\n                this.triangles = new Array();\n                this.polygonPool = new core.Pool(function () {\n                    return new Array();\n                });\n                this.polygonIndicesPool = new core.Pool(function () {\n                    return new Array();\n                });\n            }\n            Triangulator.prototype.triangulate = function (verticesArray) {\n                var vertices = verticesArray;\n                var vertexCount = verticesArray.length >> 1;\n                var indices = this.indicesArray;\n                indices.length = 0;\n                for (var i = 0; i < vertexCount; i++) {\n                    indices[i] = i;\n                }var isConcave = this.isConcaveArray;\n                isConcave.length = 0;\n                for (var i = 0, n = vertexCount; i < n; ++i) {\n                    isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n                }var triangles = this.triangles;\n                triangles.length = 0;\n                while (vertexCount > 3) {\n                    var previous = vertexCount - 1,\n                        i = 0,\n                        next = 1;\n                    while (true) {\n                        outer: if (!isConcave[i]) {\n                            var p1 = indices[previous] << 1,\n                                p2 = indices[i] << 1,\n                                p3 = indices[next] << 1;\n                            var p1x = vertices[p1],\n                                p1y = vertices[p1 + 1];\n                            var p2x = vertices[p2],\n                                p2y = vertices[p2 + 1];\n                            var p3x = vertices[p3],\n                                p3y = vertices[p3 + 1];\n                            for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n                                if (!isConcave[ii]) continue;\n                                var v = indices[ii] << 1;\n                                var vx = vertices[v],\n                                    vy = vertices[v + 1];\n                                if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n                                    if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n                                        if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                        if (next == 0) {\n                            do {\n                                if (!isConcave[i]) break;\n                                i--;\n                            } while (i > 0);\n                            break;\n                        }\n                        previous = i;\n                        i = next;\n                        next = (next + 1) % vertexCount;\n                    }\n                    triangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n                    triangles.push(indices[i]);\n                    triangles.push(indices[(i + 1) % vertexCount]);\n                    indices.splice(i, 1);\n                    isConcave.splice(i, 1);\n                    vertexCount--;\n                    var previousIndex = (vertexCount + i - 1) % vertexCount;\n                    var nextIndex = i == vertexCount ? 0 : i;\n                    isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n                    isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n                }\n                if (vertexCount == 3) {\n                    triangles.push(indices[2]);\n                    triangles.push(indices[0]);\n                    triangles.push(indices[1]);\n                }\n                return triangles;\n            };\n            Triangulator.prototype.decompose = function (verticesArray, triangles) {\n                var vertices = verticesArray;\n                var convexPolygons = this.convexPolygons;\n                this.polygonPool.freeAll(convexPolygons);\n                convexPolygons.length = 0;\n                var convexPolygonsIndices = this.convexPolygonsIndices;\n                this.polygonIndicesPool.freeAll(convexPolygonsIndices);\n                convexPolygonsIndices.length = 0;\n                var polygonIndices = this.polygonIndicesPool.obtain();\n                polygonIndices.length = 0;\n                var polygon = this.polygonPool.obtain();\n                polygon.length = 0;\n                var fanBaseIndex = -1,\n                    lastWinding = 0;\n                for (var i = 0, n = triangles.length; i < n; i += 3) {\n                    var t1 = triangles[i] << 1,\n                        t2 = triangles[i + 1] << 1,\n                        t3 = triangles[i + 2] << 1;\n                    var x1 = vertices[t1],\n                        y1 = vertices[t1 + 1];\n                    var x2 = vertices[t2],\n                        y2 = vertices[t2 + 1];\n                    var x3 = vertices[t3],\n                        y3 = vertices[t3 + 1];\n                    var merged = false;\n                    if (fanBaseIndex == t1) {\n                        var o = polygon.length - 4;\n                        var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n                        var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n                        if (winding1 == lastWinding && winding2 == lastWinding) {\n                            polygon.push(x3);\n                            polygon.push(y3);\n                            polygonIndices.push(t3);\n                            merged = true;\n                        }\n                    }\n                    if (!merged) {\n                        if (polygon.length > 0) {\n                            convexPolygons.push(polygon);\n                            convexPolygonsIndices.push(polygonIndices);\n                        } else {\n                            this.polygonPool.free(polygon);\n                            this.polygonIndicesPool.free(polygonIndices);\n                        }\n                        polygon = this.polygonPool.obtain();\n                        polygon.length = 0;\n                        polygon.push(x1);\n                        polygon.push(y1);\n                        polygon.push(x2);\n                        polygon.push(y2);\n                        polygon.push(x3);\n                        polygon.push(y3);\n                        polygonIndices = this.polygonIndicesPool.obtain();\n                        polygonIndices.length = 0;\n                        polygonIndices.push(t1);\n                        polygonIndices.push(t2);\n                        polygonIndices.push(t3);\n                        lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n                        fanBaseIndex = t1;\n                    }\n                }\n                if (polygon.length > 0) {\n                    convexPolygons.push(polygon);\n                    convexPolygonsIndices.push(polygonIndices);\n                }\n                for (var i = 0, n = convexPolygons.length; i < n; i++) {\n                    polygonIndices = convexPolygonsIndices[i];\n                    if (polygonIndices.length == 0) continue;\n                    var firstIndex = polygonIndices[0];\n                    var lastIndex = polygonIndices[polygonIndices.length - 1];\n                    polygon = convexPolygons[i];\n                    var o = polygon.length - 4;\n                    var prevPrevX = polygon[o],\n                        prevPrevY = polygon[o + 1];\n                    var prevX = polygon[o + 2],\n                        prevY = polygon[o + 3];\n                    var firstX = polygon[0],\n                        firstY = polygon[1];\n                    var secondX = polygon[2],\n                        secondY = polygon[3];\n                    var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n                    for (var ii = 0; ii < n; ii++) {\n                        if (ii == i) continue;\n                        var otherIndices = convexPolygonsIndices[ii];\n                        if (otherIndices.length != 3) continue;\n                        var otherFirstIndex = otherIndices[0];\n                        var otherSecondIndex = otherIndices[1];\n                        var otherLastIndex = otherIndices[2];\n                        var otherPoly = convexPolygons[ii];\n                        var x3 = otherPoly[otherPoly.length - 2],\n                            y3 = otherPoly[otherPoly.length - 1];\n                        if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\n                        var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n                        var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n                        if (winding1 == winding && winding2 == winding) {\n                            otherPoly.length = 0;\n                            otherIndices.length = 0;\n                            polygon.push(x3);\n                            polygon.push(y3);\n                            polygonIndices.push(otherLastIndex);\n                            prevPrevX = prevX;\n                            prevPrevY = prevY;\n                            prevX = x3;\n                            prevY = y3;\n                            ii = 0;\n                        }\n                    }\n                }\n                for (var i = convexPolygons.length - 1; i >= 0; i--) {\n                    polygon = convexPolygons[i];\n                    if (polygon.length == 0) {\n                        convexPolygons.splice(i, 1);\n                        this.polygonPool.free(polygon);\n                        polygonIndices = convexPolygonsIndices[i];\n                        convexPolygonsIndices.splice(i, 1);\n                        this.polygonIndicesPool.free(polygonIndices);\n                    }\n                }\n                return convexPolygons;\n            };\n            Triangulator.isConcave = function (index, vertexCount, vertices, indices) {\n                var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n                var current = indices[index] << 1;\n                var next = indices[(index + 1) % vertexCount] << 1;\n                return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\n            };\n            Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n                return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n            };\n            Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n                var px = p2x - p1x,\n                    py = p2y - p1y;\n                return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n            };\n            return Triangulator;\n        }();\n        core.Triangulator = Triangulator;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var IntSet = function () {\n            function IntSet() {\n                this.array = new Array();\n            }\n            IntSet.prototype.add = function (value) {\n                var contains = this.contains(value);\n                this.array[value | 0] = value | 0;\n                return !contains;\n            };\n            IntSet.prototype.contains = function (value) {\n                return this.array[value | 0] != undefined;\n            };\n            IntSet.prototype.remove = function (value) {\n                this.array[value | 0] = undefined;\n            };\n            IntSet.prototype.clear = function () {\n                this.array.length = 0;\n            };\n            return IntSet;\n        }();\n        core.IntSet = IntSet;\n        var Color = function () {\n            function Color(r, g, b, a) {\n                if (r === void 0) {\n                    r = 0;\n                }\n                if (g === void 0) {\n                    g = 0;\n                }\n                if (b === void 0) {\n                    b = 0;\n                }\n                if (a === void 0) {\n                    a = 0;\n                }\n                this.r = r;\n                this.g = g;\n                this.b = b;\n                this.a = a;\n            }\n            Color.prototype.set = function (r, g, b, a) {\n                this.r = r;\n                this.g = g;\n                this.b = b;\n                this.a = a;\n                this.clamp();\n                return this;\n            };\n            Color.prototype.setFromColor = function (c) {\n                this.r = c.r;\n                this.g = c.g;\n                this.b = c.b;\n                this.a = c.a;\n                return this;\n            };\n            Color.prototype.setFromString = function (hex) {\n                hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n                this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n                this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n                this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n                this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n                return this;\n            };\n            Color.prototype.add = function (r, g, b, a) {\n                this.r += r;\n                this.g += g;\n                this.b += b;\n                this.a += a;\n                this.clamp();\n                return this;\n            };\n            Color.prototype.clamp = function () {\n                if (this.r < 0) this.r = 0;else if (this.r > 1) this.r = 1;\n                if (this.g < 0) this.g = 0;else if (this.g > 1) this.g = 1;\n                if (this.b < 0) this.b = 0;else if (this.b > 1) this.b = 1;\n                if (this.a < 0) this.a = 0;else if (this.a > 1) this.a = 1;\n                return this;\n            };\n            return Color;\n        }();\n        Color.WHITE = new Color(1, 1, 1, 1);\n        Color.RED = new Color(1, 0, 0, 1);\n        Color.GREEN = new Color(0, 1, 0, 1);\n        Color.BLUE = new Color(0, 0, 1, 1);\n        Color.MAGENTA = new Color(1, 0, 1, 1);\n        core.Color = Color;\n        var MathUtils = function () {\n            function MathUtils() {}\n            MathUtils.clamp = function (value, min, max) {\n                if (value < min) return min;\n                if (value > max) return max;\n                return value;\n            };\n            MathUtils.cosDeg = function (degrees) {\n                return Math.cos(degrees * MathUtils.degRad);\n            };\n            MathUtils.sinDeg = function (degrees) {\n                return Math.sin(degrees * MathUtils.degRad);\n            };\n            MathUtils.signum = function (value) {\n                return value > 0 ? 1 : value < 0 ? -1 : 0;\n            };\n            MathUtils.toInt = function (x) {\n                return x > 0 ? Math.floor(x) : Math.ceil(x);\n            };\n            MathUtils.cbrt = function (x) {\n                var y = Math.pow(Math.abs(x), 1 / 3);\n                return x < 0 ? -y : y;\n            };\n            MathUtils.randomTriangular = function (min, max) {\n                return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n            };\n            MathUtils.randomTriangularWith = function (min, max, mode) {\n                var u = Math.random();\n                var d = max - min;\n                if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n                return max - Math.sqrt((1 - u) * d * (max - mode));\n            };\n            return MathUtils;\n        }();\n        MathUtils.PI = 3.1415927;\n        MathUtils.PI2 = MathUtils.PI * 2;\n        MathUtils.radiansToDegrees = 180 / MathUtils.PI;\n        MathUtils.radDeg = MathUtils.radiansToDegrees;\n        MathUtils.degreesToRadians = MathUtils.PI / 180;\n        MathUtils.degRad = MathUtils.degreesToRadians;\n        core.MathUtils = MathUtils;\n        var Interpolation = function () {\n            function Interpolation() {}\n            Interpolation.prototype.apply = function (start, end, a) {\n                return start + (end - start) * this.applyInternal(a);\n            };\n            return Interpolation;\n        }();\n        core.Interpolation = Interpolation;\n        var Pow = function (_super) {\n            __extends(Pow, _super);\n            function Pow(power) {\n                var _this = _super.call(this) || this;\n                _this.power = 2;\n                _this.power = power;\n                return _this;\n            }\n            Pow.prototype.applyInternal = function (a) {\n                if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n                return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n            };\n            return Pow;\n        }(Interpolation);\n        core.Pow = Pow;\n        var PowOut = function (_super) {\n            __extends(PowOut, _super);\n            function PowOut(power) {\n                return _super.call(this, power) || this;\n            }\n            PowOut.prototype.applyInternal = function (a) {\n                return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n            };\n            return PowOut;\n        }(Pow);\n        core.PowOut = PowOut;\n        var Utils = function () {\n            function Utils() {}\n            Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\n                for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n                    dest[j] = source[i];\n                }\n            };\n            Utils.setArraySize = function (array, size, value) {\n                if (value === void 0) {\n                    value = 0;\n                }\n                var oldSize = array.length;\n                if (oldSize == size) return array;\n                array.length = size;\n                if (oldSize < size) {\n                    for (var i = oldSize; i < size; i++) {\n                        array[i] = value;\n                    }\n                }\n                return array;\n            };\n            Utils.ensureArrayCapacity = function (array, size, value) {\n                if (value === void 0) {\n                    value = 0;\n                }\n                if (array.length >= size) return array;\n                return Utils.setArraySize(array, size, value);\n            };\n            Utils.newArray = function (size, defaultValue) {\n                var array = new Array(size);\n                for (var i = 0; i < size; i++) {\n                    array[i] = defaultValue;\n                }return array;\n            };\n            Utils.newFloatArray = function (size) {\n                if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                    return new Float32Array(size);\n                } else {\n                    var array = new Array(size);\n                    for (var i = 0; i < array.length; i++) {\n                        array[i] = 0;\n                    }return array;\n                }\n            };\n            Utils.newShortArray = function (size) {\n                if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                    return new Int16Array(size);\n                } else {\n                    var array = new Array(size);\n                    for (var i = 0; i < array.length; i++) {\n                        array[i] = 0;\n                    }return array;\n                }\n            };\n            Utils.toFloatArray = function (array) {\n                return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n            };\n            Utils.toSinglePrecision = function (value) {\n                return Utils.SUPPORTS_TYPED_ARRAYS ? (0, _fround2.default)(value) : value;\n            };\n            return Utils;\n        }();\n        Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== \"undefined\";\n        core.Utils = Utils;\n        var DebugUtils = function () {\n            function DebugUtils() {}\n            DebugUtils.logBones = function (skeleton) {\n                for (var i = 0; i < skeleton.bones.length; i++) {\n                    var bone = skeleton.bones[i];\n                    var mat = bone.matrix;\n                    console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\n                }\n            };\n            return DebugUtils;\n        }();\n        core.DebugUtils = DebugUtils;\n        var Pool = function () {\n            function Pool(instantiator) {\n                this.items = new Array();\n                this.instantiator = instantiator;\n            }\n            Pool.prototype.obtain = function () {\n                return this.items.length > 0 ? this.items.pop() : this.instantiator();\n            };\n            Pool.prototype.free = function (item) {\n                if (item.reset) item.reset();\n                this.items.push(item);\n            };\n            Pool.prototype.freeAll = function (items) {\n                for (var i = 0; i < items.length; i++) {\n                    if (items[i].reset) items[i].reset();\n                    this.items[i] = items[i];\n                }\n            };\n            Pool.prototype.clear = function () {\n                this.items.length = 0;\n            };\n            return Pool;\n        }();\n        core.Pool = Pool;\n        var Vector2 = function () {\n            function Vector2(x, y) {\n                if (x === void 0) {\n                    x = 0;\n                }\n                if (y === void 0) {\n                    y = 0;\n                }\n                this.x = x;\n                this.y = y;\n            }\n            Vector2.prototype.set = function (x, y) {\n                this.x = x;\n                this.y = y;\n                return this;\n            };\n            Vector2.prototype.length = function () {\n                var x = this.x;\n                var y = this.y;\n                return Math.sqrt(x * x + y * y);\n            };\n            Vector2.prototype.normalize = function () {\n                var len = this.length();\n                if (len != 0) {\n                    this.x /= len;\n                    this.y /= len;\n                }\n                return this;\n            };\n            return Vector2;\n        }();\n        core.Vector2 = Vector2;\n        var TimeKeeper = function () {\n            function TimeKeeper() {\n                this.maxDelta = 0.064;\n                this.framesPerSecond = 0;\n                this.delta = 0;\n                this.totalTime = 0;\n                this.lastTime = Date.now() / 1000;\n                this.frameCount = 0;\n                this.frameTime = 0;\n            }\n            TimeKeeper.prototype.update = function () {\n                var now = Date.now() / 1000;\n                this.delta = now - this.lastTime;\n                this.frameTime += this.delta;\n                this.totalTime += this.delta;\n                if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n                this.lastTime = now;\n                this.frameCount++;\n                if (this.frameTime > 1) {\n                    this.framesPerSecond = this.frameCount / this.frameTime;\n                    this.frameTime = 0;\n                    this.frameCount = 0;\n                }\n            };\n            return TimeKeeper;\n        }();\n        core.TimeKeeper = TimeKeeper;\n        var WindowedMean = function () {\n            function WindowedMean(windowSize) {\n                if (windowSize === void 0) {\n                    windowSize = 32;\n                }\n                this.addedValues = 0;\n                this.lastValue = 0;\n                this.mean = 0;\n                this.dirty = true;\n                this.values = new Array(windowSize);\n            }\n            WindowedMean.prototype.hasEnoughData = function () {\n                return this.addedValues >= this.values.length;\n            };\n            WindowedMean.prototype.addValue = function (value) {\n                if (this.addedValues < this.values.length) this.addedValues++;\n                this.values[this.lastValue++] = value;\n                if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n                this.dirty = true;\n            };\n            WindowedMean.prototype.getMean = function () {\n                if (this.hasEnoughData()) {\n                    if (this.dirty) {\n                        var mean = 0;\n                        for (var i = 0; i < this.values.length; i++) {\n                            mean += this.values[i];\n                        }\n                        this.mean = mean / this.values.length;\n                        this.dirty = false;\n                    }\n                    return this.mean;\n                } else {\n                    return 0;\n                }\n            };\n            return WindowedMean;\n        }();\n        core.WindowedMean = WindowedMean;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var JitterEffect = function () {\n            function JitterEffect(jitterX, jitterY) {\n                this.jitterX = 0;\n                this.jitterY = 0;\n                this.jitterX = jitterX;\n                this.jitterY = jitterY;\n            }\n            JitterEffect.prototype.begin = function (skeleton) {};\n            JitterEffect.prototype.transform = function (position, uv, light, dark) {\n                position.x += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n                position.y += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n            };\n            JitterEffect.prototype.end = function () {};\n            return JitterEffect;\n        }();\n        core.JitterEffect = JitterEffect;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SwirlEffect = function () {\n            function SwirlEffect(radius) {\n                this.centerX = 0;\n                this.centerY = 0;\n                this.radius = 0;\n                this.angle = 0;\n                this.worldX = 0;\n                this.worldY = 0;\n                this.radius = radius;\n            }\n            SwirlEffect.prototype.begin = function (skeleton) {\n                this.worldX = skeleton.x + this.centerX;\n                this.worldY = skeleton.y + this.centerY;\n            };\n            SwirlEffect.prototype.transform = function (position, uv, light, dark) {\n                var radAngle = this.angle * core.MathUtils.degreesToRadians;\n                var x = position.x - this.worldX;\n                var y = position.y - this.worldY;\n                var dist = Math.sqrt(x * x + y * y);\n                if (dist < this.radius) {\n                    var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n                    var cos = Math.cos(theta);\n                    var sin = Math.sin(theta);\n                    position.x = cos * x - sin * y + this.worldX;\n                    position.y = sin * x + cos * y + this.worldY;\n                }\n            };\n            SwirlEffect.prototype.end = function () {};\n            return SwirlEffect;\n        }();\n        SwirlEffect.interpolation = new core.PowOut(2);\n        core.SwirlEffect = SwirlEffect;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    function isJson(resource) {\n        var TYPE = PIXI.loaders.Resource.TYPE;\n        if (TYPE) {\n            return resource.type === TYPE.JSON;\n        }\n        return resource.isJson;\n    }\n    function atlasParser() {\n        return function (resource, next) {\n            if (!resource.data || !isJson(resource) || !resource.data.bones) {\n                return next();\n            }\n            var metadata = resource.metadata || {};\n            var metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;\n            var metadataAtlas = metadata ? resource.metadata.spineAtlas : null;\n            if (metadataAtlas === false) {\n                return next();\n            }\n            if (metadataAtlas && metadataAtlas.pages) {\n                var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(metadataAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n                resource.spineData = skeletonData;\n                resource.spineAtlas = metadataAtlas;\n                return next();\n            }\n            var metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\n            var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\n            atlasPath = atlasPath.replace(this.baseUrl, '');\n            var atlasOptions = {\n                crossOrigin: resource.crossOrigin,\n                xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n                metadata: metadata.spineMetadata || null,\n                parentResource: resource\n            };\n            var imageOptions = {\n                crossOrigin: resource.crossOrigin,\n                metadata: metadata.imageMetadata || null,\n                parentResource: resource\n            };\n            var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n            baseUrl = baseUrl.replace(this.baseUrl, '');\n            var adapter = metadata.images ? staticImageLoader(metadata.images) : metadata.image ? staticImageLoader({ 'default': metadata.image }) : metadata.imageLoader ? metadata.imageLoader(this, resource.name + '_atlas_page_', baseUrl, imageOptions) : imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n            this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {\n                new pixi_spine.core.TextureAtlas(atlasResource.xhr.responseText, adapter, function (spineAtlas) {\n                    var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(spineAtlas));\n                    if (metadataSkeletonScale) {\n                        spineJsonParser.scale = metadataSkeletonScale;\n                    }\n                    resource.spineData = spineJsonParser.readSkeletonData(resource.data);\n                    resource.spineAtlas = spineAtlas;\n                    next();\n                });\n            });\n        };\n    }\n    pixi_spine.atlasParser = atlasParser;\n    function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {\n        if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n            baseUrl += '/';\n        }\n        return function (line, callback) {\n            var name = namePrefix + line;\n            var url = baseUrl + line;\n            loader.add(name, url, imageOptions, function (resource) {\n                callback(resource.texture.baseTexture);\n            });\n        };\n    }\n    pixi_spine.imageLoaderAdapter = imageLoaderAdapter;\n    function syncImageLoaderAdapter(baseUrl, crossOrigin) {\n        if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n            baseUrl += '/';\n        }\n        return function (line, callback) {\n            callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n        };\n    }\n    pixi_spine.syncImageLoaderAdapter = syncImageLoaderAdapter;\n    function staticImageLoader(pages) {\n        return function (line, callback) {\n            var page = pages[line] || pages['default'];\n            if (page && page.baseTexture) callback(page.baseTexture);else callback(page);\n        };\n    }\n    pixi_spine.staticImageLoader = staticImageLoader;\n    PIXI.loaders.Loader.addPixiMiddleware(atlasParser);\n    PIXI.loader.use(atlasParser());\n})(pixi_spine || (pixi_spine = {}));\n(function () {\n    if (!_fround2.default) {\n        Math.fround = Math.fround = function (array) {\n            return function (x) {\n                return array[0] = x, array[0];\n            };\n        }(new Float32Array(1));\n    }\n})();\n(function (pixi_spine) {\n    pixi_spine.core.Bone.yDown = true;\n    var tempRgb = [0, 0, 0];\n    var SpineSprite = function (_super) {\n        __extends(SpineSprite, _super);\n        function SpineSprite(tex) {\n            return _super.call(this, tex) || this;\n        }\n        return SpineSprite;\n    }(PIXI.Sprite);\n    pixi_spine.SpineSprite = SpineSprite;\n    var SpineMesh = function (_super) {\n        __extends(SpineMesh, _super);\n        function SpineMesh(texture, vertices, uvs, indices, drawMode) {\n            return _super.call(this, texture, vertices, uvs, indices, drawMode) || this;\n        }\n        return SpineMesh;\n    }(PIXI.mesh.Mesh);\n    pixi_spine.SpineMesh = SpineMesh;\n    var Spine = function (_super) {\n        __extends(Spine, _super);\n        function Spine(spineData) {\n            var _this = _super.call(this) || this;\n            _this.hackTextureBySlotName = function (slotName, texture, size) {\n                if (texture === void 0) {\n                    texture = null;\n                }\n                if (size === void 0) {\n                    size = null;\n                }\n                var index = this.skeleton.findSlotIndex(slotName);\n                if (index == -1) {\n                    return false;\n                }\n                return this.hackTextureBySlotIndex(index, texture, size);\n            };\n            if (!spineData) {\n                throw new Error('The spineData param is required.');\n            }\n            if (typeof spineData === \"string\") {\n                throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n            }\n            _this.spineData = spineData;\n            _this.skeleton = new pixi_spine.core.Skeleton(spineData);\n            _this.skeleton.updateWorldTransform();\n            _this.stateData = new pixi_spine.core.AnimationStateData(spineData);\n            _this.state = new pixi_spine.core.AnimationState(_this.stateData);\n            _this.slotContainers = [];\n            _this.tempClipContainers = [];\n            for (var i = 0, n = _this.skeleton.slots.length; i < n; i++) {\n                var slot = _this.skeleton.slots[i];\n                var attachment = slot.attachment;\n                var slotContainer = new PIXI.Container();\n                _this.slotContainers.push(slotContainer);\n                _this.addChild(slotContainer);\n                _this.tempClipContainers.push(null);\n                if (attachment instanceof pixi_spine.core.RegionAttachment) {\n                    var spriteName = attachment.region.name;\n                    var sprite = _this.createSprite(slot, attachment, spriteName);\n                    slot.currentSprite = sprite;\n                    slot.currentSpriteName = spriteName;\n                    slotContainer.addChild(sprite);\n                } else if (attachment instanceof pixi_spine.core.MeshAttachment) {\n                    var mesh = _this.createMesh(slot, attachment);\n                    slot.currentMesh = mesh;\n                    slot.currentMeshName = attachment.name;\n                    slotContainer.addChild(mesh);\n                } else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\n                    _this.createGraphics(slot, attachment);\n                    slotContainer.addChild(slot.clippingContainer);\n                    slotContainer.addChild(slot.currentGraphics);\n                } else {\n                    continue;\n                }\n            }\n            _this.autoUpdate = true;\n            _this.tintRgb = new Float32Array([1, 1, 1]);\n            return _this;\n        }\n        Object.defineProperty(Spine.prototype, \"autoUpdate\", {\n            get: function get() {\n                return this.updateTransform === Spine.prototype.autoUpdateTransform;\n            },\n            set: function set(value) {\n                this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Spine.prototype, \"tint\", {\n            get: function get() {\n                return PIXI.utils.rgb2hex(this.tintRgb);\n            },\n            set: function set(value) {\n                this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Spine.prototype.update = function (dt) {\n            this.state.update(dt);\n            this.state.apply(this.skeleton);\n            this.skeleton.updateWorldTransform();\n            var slots = this.skeleton.slots;\n            var r0 = this.tintRgb[0];\n            var g0 = this.tintRgb[1];\n            var b0 = this.tintRgb[2];\n            for (var i = 0, n = slots.length; i < n; i++) {\n                var slot = slots[i];\n                var attachment = slot.attachment;\n                var slotContainer = this.slotContainers[i];\n                if (!attachment) {\n                    slotContainer.visible = false;\n                    continue;\n                }\n                var attColor = attachment.color;\n                if (attachment instanceof pixi_spine.core.RegionAttachment) {\n                    var region = attachment.region;\n                    if (region) {\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                            slot.currentMesh = null;\n                            slot.currentMeshName = undefined;\n                        }\n                        var ar = region;\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n                            var spriteName = ar.name;\n                            if (slot.currentSprite) {\n                                slot.currentSprite.visible = false;\n                            }\n                            slot.sprites = slot.sprites || {};\n                            if (slot.sprites[spriteName] !== undefined) {\n                                slot.sprites[spriteName].visible = true;\n                            } else {\n                                var sprite = this.createSprite(slot, attachment, spriteName);\n                                slotContainer.addChild(sprite);\n                            }\n                            slot.currentSprite = slot.sprites[spriteName];\n                            slot.currentSpriteName = spriteName;\n                        }\n                    }\n                    if (slotContainer.transform) {\n                        var transform = slotContainer.transform;\n                        var transAny = transform;\n                        var lt = null;\n                        if (transAny.matrix2d) {\n                            lt = transAny.matrix2d;\n                            transAny._dirtyVersion++;\n                            transAny.version = transAny._dirtyVersion;\n                            transAny.isStatic = true;\n                            transAny.operMode = 0;\n                        } else {\n                            if (PIXI.TransformBase) {\n                                if (transAny.position) {\n                                    transform = new PIXI.TransformBase();\n                                    slotContainer.transform = transform;\n                                }\n                                lt = transform.localTransform;\n                            } else {\n                                transAny.setFromMatrix(slot.bone.matrix);\n                            }\n                        }\n                        if (lt) {\n                            slot.bone.matrix.copy(lt);\n                        }\n                    } else {\n                        var lt = slotContainer.localTransform || new PIXI.Matrix();\n                        slot.bone.matrix.copy(lt);\n                        slotContainer.localTransform = lt;\n                        slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n                    }\n                    tempRgb[0] = r0 * slot.color.r * attColor.r;\n                    tempRgb[1] = g0 * slot.color.g * attColor.g;\n                    tempRgb[2] = b0 * slot.color.b * attColor.b;\n                    slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n                    slot.currentSprite.blendMode = slot.blendMode;\n                } else if (attachment instanceof pixi_spine.core.MeshAttachment) {\n                    if (slot.currentSprite) {\n                        slot.currentSprite.visible = false;\n                        slot.currentSprite = null;\n                        slot.currentSpriteName = undefined;\n                        if (slotContainer.transform) {\n                            slotContainer.transform = new PIXI.TransformStatic();\n                        } else {\n                            slotContainer.localTransform = new PIXI.Matrix();\n                            slotContainer.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;\n                        }\n                    }\n                    if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                        var meshName = attachment.name;\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                        }\n                        slot.meshes = slot.meshes || {};\n                        if (slot.meshes[meshName] !== undefined) {\n                            slot.meshes[meshName].visible = true;\n                        } else {\n                            var mesh = this.createMesh(slot, attachment);\n                            slotContainer.addChild(mesh);\n                        }\n                        slot.currentMesh = slot.meshes[meshName];\n                        slot.currentMeshName = meshName;\n                    }\n                    attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n                    if (PIXI.VERSION[0] !== '3') {\n                        var tintRgb = slot.currentMesh.tintRgb;\n                        tintRgb[0] = r0 * slot.color.r * attColor.r;\n                        tintRgb[1] = g0 * slot.color.g * attColor.g;\n                        tintRgb[2] = b0 * slot.color.b * attColor.b;\n                    }\n                    slot.currentMesh.blendMode = slot.blendMode;\n                } else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\n                    if (!slot.currentGraphics) {\n                        this.createGraphics(slot, attachment);\n                        slotContainer.addChild(slot.clippingContainer);\n                        slotContainer.addChild(slot.currentGraphics);\n                    }\n                    this.updateGraphics(slot, attachment);\n                } else {\n                    slotContainer.visible = false;\n                    continue;\n                }\n                slotContainer.visible = true;\n                slotContainer.alpha = slot.color.a;\n            }\n            var drawOrder = this.skeleton.drawOrder;\n            var clippingAttachment = null;\n            var clippingContainer = null;\n            for (var i = 0, n = drawOrder.length; i < n; i++) {\n                var slot = slots[drawOrder[i].data.index];\n                var slotContainer = this.slotContainers[drawOrder[i].data.index];\n                if (!clippingContainer) {\n                    if (slotContainer.parent !== this) {\n                        slotContainer.parent.removeChild(slotContainer);\n                        slotContainer.parent = this;\n                    }\n                }\n                if (slot.currentGraphics) {\n                    clippingContainer = slot.clippingContainer;\n                    clippingAttachment = slot.attachment;\n                    clippingContainer.children.length = 0;\n                    this.children[i] = slotContainer;\n                    if (clippingAttachment.endSlot == slot.data) {\n                        clippingContainer.renderable = false;\n                        clippingContainer = null;\n                        clippingAttachment = null;\n                    }\n                } else {\n                    if (clippingContainer) {\n                        var c = this.tempClipContainers[i];\n                        if (!c) {\n                            c = this.tempClipContainers[i] = new PIXI.Container();\n                            c.visible = false;\n                        }\n                        this.children[i] = c;\n                        slotContainer.parent = null;\n                        clippingContainer.addChild(slotContainer);\n                        if (clippingAttachment.endSlot == slot.data) {\n                            clippingContainer.renderable = true;\n                            clippingContainer = null;\n                            clippingAttachment = null;\n                        }\n                    } else {\n                        this.children[i] = slotContainer;\n                    }\n                }\n            }\n        };\n        ;\n        Spine.prototype.setSpriteRegion = function (attachment, sprite, region) {\n            sprite.region = region;\n            sprite.texture = region.texture;\n            if (!region.size) {\n                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n                sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n            } else {\n                sprite.scale.x = region.size.width / region.originalWidth;\n                sprite.scale.y = -region.size.height / region.originalHeight;\n            }\n        };\n        Spine.prototype.setMeshRegion = function (attachment, mesh, region) {\n            mesh.region = region;\n            mesh.texture = region.texture;\n            attachment.updateUVs(region, mesh.uvs);\n            mesh.dirty++;\n        };\n        Spine.prototype.autoUpdateTransform = function () {\n            if (Spine.globalAutoUpdate) {\n                this.lastTime = this.lastTime || Date.now();\n                var timeDelta = (Date.now() - this.lastTime) * 0.001;\n                this.lastTime = Date.now();\n                this.update(timeDelta);\n            } else {\n                this.lastTime = 0;\n            }\n            PIXI.Container.prototype.updateTransform.call(this);\n        };\n        ;\n        Spine.prototype.createSprite = function (slot, attachment, defName) {\n            var region = attachment.region;\n            if (slot.tempAttachment === attachment) {\n                region = slot.tempRegion;\n                slot.tempAttachment = null;\n                slot.tempRegion = null;\n            }\n            var texture = region.texture;\n            var sprite = new SpineSprite(texture);\n            sprite.rotation = attachment.rotation * pixi_spine.core.MathUtils.degRad;\n            sprite.anchor.x = 0.5;\n            sprite.anchor.y = 0.5;\n            sprite.position.x = attachment.x;\n            sprite.position.y = attachment.y;\n            sprite.alpha = attachment.color.a;\n            sprite.region = attachment.region;\n            this.setSpriteRegion(attachment, sprite, attachment.region);\n            slot.sprites = slot.sprites || {};\n            slot.sprites[defName] = sprite;\n            return sprite;\n        };\n        ;\n        Spine.prototype.createMesh = function (slot, attachment) {\n            var region = attachment.region;\n            if (slot.tempAttachment === attachment) {\n                region = slot.tempRegion;\n                slot.tempAttachment = null;\n                slot.tempRegion = null;\n            }\n            var strip = new SpineMesh(region.texture, new Float32Array(attachment.regionUVs.length), new Float32Array(attachment.regionUVs.length), new Uint16Array(attachment.triangles), PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n            strip.canvasPadding = 1.5;\n            strip.alpha = attachment.color.a;\n            strip.region = attachment.region;\n            this.setMeshRegion(attachment, strip, region);\n            slot.meshes = slot.meshes || {};\n            slot.meshes[attachment.name] = strip;\n            return strip;\n        };\n        ;\n        Spine.prototype.createGraphics = function (slot, clip) {\n            var graphics = new PIXI.Graphics();\n            var poly = new PIXI.Polygon([]);\n            graphics.clear();\n            graphics.beginFill(0xffffff, 1);\n            graphics.drawPolygon(poly);\n            graphics.renderable = false;\n            slot.currentGraphics = graphics;\n            slot.clippingContainer = new PIXI.Container();\n            slot.clippingContainer.mask = slot.currentGraphics;\n            return graphics;\n        };\n        Spine.prototype.updateGraphics = function (slot, clip) {\n            var vertices = slot.currentGraphics.graphicsData[0].shape.points;\n            var n = clip.worldVerticesLength;\n            vertices.length = n;\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n            slot.currentGraphics.dirty++;\n            slot.currentGraphics.clearDirty++;\n        };\n        Spine.prototype.hackTextureBySlotIndex = function (slotIndex, texture, size) {\n            if (texture === void 0) {\n                texture = null;\n            }\n            if (size === void 0) {\n                size = null;\n            }\n            var slot = this.skeleton.slots[slotIndex];\n            if (!slot) {\n                return false;\n            }\n            var attachment = slot.attachment;\n            var region = attachment.region;\n            if (texture) {\n                region = new pixi_spine.core.TextureRegion();\n                region.texture = texture;\n                region.size = size;\n            }\n            if (slot.currentSprite && slot.currentSprite.region != region) {\n                this.setSpriteRegion(attachment, slot.currentSprite, region);\n                slot.currentSprite.region = region;\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\n                this.setMeshRegion(attachment, slot.currentMesh, region);\n            } else {\n                slot.tempRegion = region;\n                slot.tempAttachment = attachment;\n            }\n            return true;\n        };\n        return Spine;\n    }(PIXI.Container);\n    Spine.globalAutoUpdate = true;\n    Spine.clippingPolygon = [];\n    pixi_spine.Spine = Spine;\n    function SlotContainerUpdateTransformV3() {\n        var pt = this.parent.worldTransform;\n        var wt = this.worldTransform;\n        var lt = this.localTransform;\n        wt.a = lt.a * pt.a + lt.b * pt.c;\n        wt.b = lt.a * pt.b + lt.b * pt.d;\n        wt.c = lt.c * pt.a + lt.d * pt.c;\n        wt.d = lt.c * pt.b + lt.d * pt.d;\n        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n        this._currentBounds = null;\n    }\n})(pixi_spine || (pixi_spine = {}));\nPIXI.spine = pixi_spine;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(71), __esModule: true };\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(72);\nmodule.exports = __webpack_require__(2).Math.fround;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 20.2.2.16 Math.fround(x)\nvar $export   = __webpack_require__(10)\n  , sign      = __webpack_require__(73)\n  , pow       = Math.pow\n  , EPSILON   = pow(2, -52)\n  , EPSILON32 = pow(2, -23)\n  , MAX32     = pow(2, 127) * (2 - EPSILON32)\n  , MIN32     = pow(2, -126);\n\nvar roundTiesToEven = function(n){\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\n\n$export($export.S, 'Math', {\n  fround: function fround(x){\n    var $abs  = Math.abs(x)\n      , $sign = sign(x)\n      , a, result;\n    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n    a = (1 + EPSILON32 / EPSILON) * $abs;\n    result = a - (a - $abs);\n    if(result > MAX32 || result != result)return $sign * Infinity;\n    return $sign * result;\n  }\n});\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports) {\n\n// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x){\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(75), __esModule: true };\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(76);\nvar $Object = __webpack_require__(2).Object;\nmodule.exports = function create(P, D){\n  return $Object.create(P, D);\n};\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $export = __webpack_require__(10)\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', {create: __webpack_require__(35)});\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(78), __esModule: true };\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(79);\nmodule.exports = __webpack_require__(2).Object.setPrototypeOf;\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = __webpack_require__(10);\n$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(80).set});\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __webpack_require__(6)\n  , anObject = __webpack_require__(5);\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = __webpack_require__(15)(Function.call, __webpack_require__(81).f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar pIE            = __webpack_require__(39)\n  , createDesc     = __webpack_require__(19)\n  , toIObject      = __webpack_require__(7)\n  , toPrimitive    = __webpack_require__(26)\n  , has            = __webpack_require__(8)\n  , IE8_DOM_DEFINE = __webpack_require__(25)\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(3) ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _loader = __webpack_require__(53);\n\nvar _loader2 = _interopRequireDefault(_loader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar newSpine = function newSpine(spineName) {\n    var data = _loader2.default.loadSkeleton(spineName);\n    var spine = new PIXI.spine.Spine(data);\n    var setup = ysp.Spine.SETUP[spineName];\n\n    spine.update = function (dt) {\n        // hax: Container shouldn't call this without dt\n        if (dt) {\n            PIXI.spine.Spine.prototype.update.call(this, dt);\n        }\n    };\n\n    if (setup.initAnimation.autoplay) {\n        spine.state.setAnimation(0, setup.initAnimation.name, setup.initAnimation.loop);\n    }\n    spine.skeleton.setSkinByName(setup.skin);\n\n    return spine;\n};\n\nvar playAnimation = function playAnimation(spine, animationName, loop) {\n    spine.state.setAnimation(0, animationName, loop);\n};\n\nvar setSkinByName = function setSkinByName(spine, skinName) {\n    spine.skeleton.setSkinByName(skinName);\n};\n\nexports.default = {\n    newSpine: newSpine,\n    playAnimation: playAnimation,\n    setSkinByName: setSkinByName\n};\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(84), __esModule: true };\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(85);\n__webpack_require__(49);\n__webpack_require__(41);\n__webpack_require__(86);\nmodule.exports = __webpack_require__(2).Promise;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY            = __webpack_require__(34)\n  , global             = __webpack_require__(0)\n  , ctx                = __webpack_require__(15)\n  , classof            = __webpack_require__(38)\n  , $export            = __webpack_require__(10)\n  , isObject           = __webpack_require__(6)\n  , aFunction          = __webpack_require__(20)\n  , anInstance         = __webpack_require__(87)\n  , forOf              = __webpack_require__(88)\n  , speciesConstructor = __webpack_require__(91)\n  , task               = __webpack_require__(54).set\n  , microtask          = __webpack_require__(93)()\n  , PROMISE            = 'Promise'\n  , TypeError          = global.TypeError\n  , process            = global.process\n  , $Promise           = global[PROMISE]\n  , process            = global.process\n  , isNode             = classof(process) == 'process'\n  , empty              = function(){ /* empty */ }\n  , Internal, GenericPromiseCapability, Wrapper;\n\nvar USE_NATIVE = !!function(){\n  try {\n    // correct subclassing with @@species support\n    var promise     = $Promise.resolve(1)\n      , FakePromise = (promise.constructor = {})[__webpack_require__(1)('species')] = function(exec){ exec(empty, empty); };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch(e){ /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n};\nvar isThenable = function(it){\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar newPromiseCapability = function(C){\n  return sameConstructor($Promise, C)\n    ? new PromiseCapability(C)\n    : new GenericPromiseCapability(C);\n};\nvar PromiseCapability = GenericPromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject  = aFunction(reject);\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(promise, isReject){\n  if(promise._n)return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function(){\n    var value = promise._v\n      , ok    = promise._s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , domain  = reaction.domain\n        , result, then;\n      try {\n        if(handler){\n          if(!ok){\n            if(promise._h == 2)onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if(handler === true)result = value;\n          else {\n            if(domain)domain.enter();\n            result = handler(value);\n            if(domain)domain.exit();\n          }\n          if(result === reaction.promise){\n            reject(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if(isReject && !promise._h)onUnhandled(promise);\n  });\n};\nvar onUnhandled = function(promise){\n  task.call(global, function(){\n    var value = promise._v\n      , abrupt, handler, console;\n    if(isUnhandled(promise)){\n      abrupt = perform(function(){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if(abrupt)throw abrupt.error;\n  });\n};\nvar isUnhandled = function(promise){\n  if(promise._h == 1)return false;\n  var chain = promise._a || promise._c\n    , i     = 0\n    , reaction;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar onHandleUnhandled = function(promise){\n  task.call(global, function(){\n    var handler;\n    if(isNode){\n      process.emit('rejectionHandled', promise);\n    } else if(handler = global.onrejectionhandled){\n      handler({promise: promise, reason: promise._v});\n    }\n  });\n};\nvar $reject = function(value){\n  var promise = this;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if(!promise._a)promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function(value){\n  var promise = this\n    , then;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if(promise === value)throw TypeError(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      microtask(function(){\n        var wrapper = {_w: promise, _d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch(e){\n    $reject.call({_w: promise, _d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE){\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor){\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch(err){\n      $reject.call(this, err);\n    }\n  };\n  Internal = function Promise(executor){\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = __webpack_require__(94)($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail   = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if(this._a)this._a.push(reaction);\n      if(this._s)notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n  PromiseCapability = function(){\n    var promise  = new Internal;\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject  = ctx($reject, promise, 1);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});\n__webpack_require__(29)($Promise, PROMISE);\n__webpack_require__(95)(PROMISE);\nWrapper = __webpack_require__(2)[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = newPromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n    var capability = newPromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(96)(function(iter){\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      var values    = []\n        , index     = 0\n        , remaining = 1;\n      forOf(iterable, false, function(promise){\n        var $index        = index++\n          , alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled  = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx         = __webpack_require__(15)\n  , call        = __webpack_require__(89)\n  , isArrayIter = __webpack_require__(90)\n  , anObject    = __webpack_require__(5)\n  , toLength    = __webpack_require__(28)\n  , getIterFn   = __webpack_require__(51)\n  , BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = call(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(5);\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// check on default Array iterator\nvar Iterators  = __webpack_require__(9)\n  , ITERATOR   = __webpack_require__(1)('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject  = __webpack_require__(5)\n  , aFunction = __webpack_require__(20)\n  , SPECIES   = __webpack_require__(1)('species');\nmodule.exports = function(O, D){\n  var C = anObject(O).constructor, S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports) {\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global    = __webpack_require__(0)\n  , macrotask = __webpack_require__(54).set\n  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n  , process   = global.process\n  , Promise   = global.Promise\n  , isNode    = __webpack_require__(13)(process) == 'process';\n\nmodule.exports = function(){\n  var head, last, notify;\n\n  var flush = function(){\n    var parent, fn;\n    if(isNode && (parent = process.domain))parent.exit();\n    while(head){\n      fn   = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch(e){\n        if(head)notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if(parent)parent.enter();\n  };\n\n  // Node.js\n  if(isNode){\n    notify = function(){\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if(Observer){\n    var toggle = true\n      , node   = document.createTextNode('');\n    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n    notify = function(){\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if(Promise && Promise.resolve){\n    var promise = Promise.resolve();\n    notify = function(){\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function(){\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function(fn){\n    var task = {fn: fn, next: undefined};\n    if(last)last.next = task;\n    if(!head){\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hide = __webpack_require__(4);\nmodule.exports = function(target, src, safe){\n  for(var key in src){\n    if(safe && target[key])target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global      = __webpack_require__(0)\n  , core        = __webpack_require__(2)\n  , dP          = __webpack_require__(11)\n  , DESCRIPTORS = __webpack_require__(3)\n  , SPECIES     = __webpack_require__(1)('species');\n\nmodule.exports = function(KEY){\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ITERATOR     = __webpack_require__(1)('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _loader = __webpack_require__(53);\n\nvar _loader2 = _interopRequireDefault(_loader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (Scene_Base) {\n    var _isReady = Scene_Base.prototype.isReady;\n    Scene_Base.prototype.isReady = function () {\n        return _isReady.call(this) && _loader2.default.isLoaded();\n    };\n};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// YSP_Spine.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 63);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4022c9eee673183a739e","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_global.js\n// module id = 0\n// module chunks = 0 1 2","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_wks.js\n// module id = 1\n// module chunks = 0 1","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_core.js\n// module id = 2\n// module chunks = 0 1 2","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_descriptors.js\n// module id = 3\n// module chunks = 0 1 2","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_hide.js\n// module id = 4\n// module chunks = 0 1 2","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_an-object.js\n// module id = 5\n// module chunks = 0 1 2","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_is-object.js\n// module id = 6\n// module chunks = 0 1 2","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-iobject.js\n// module id = 7\n// module chunks = 0 1 2","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_has.js\n// module id = 8\n// module chunks = 0 1 2","module.exports = {};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iterators.js\n// module id = 9\n// module chunks = 0 1","var global    = require('./_global')\n  , core      = require('./_core')\n  , ctx       = require('./_ctx')\n  , hide      = require('./_hide')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , IS_WRAP   = type & $export.W\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE]\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]\n    , key, own, out;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if(own && key in exports)continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function(C){\n      var F = function(a, b, c){\n        if(this instanceof C){\n          switch(arguments.length){\n            case 0: return new C;\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if(IS_PROTO){\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_export.js\n// module id = 10\n// module chunks = 0 1 2","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-dp.js\n// module id = 11\n// module chunks = 0 1 2","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-integer.js\n// module id = 12\n// module chunks = 0 1 2","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_cof.js\n// module id = 13\n// module chunks = 0 1 2","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_defined.js\n// module id = 14\n// module chunks = 0 1 2","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_ctx.js\n// module id = 15\n// module chunks = 0 1 2","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_fails.js\n// module id = 16\n// module chunks = 0 1 2","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_shared-key.js\n// module id = 17\n// module chunks = 0 1 2","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_dom-create.js\n// module id = 18\n// module chunks = 0 1 2","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_property-desc.js\n// module id = 19\n// module chunks = 0 1 2","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_a-function.js\n// module id = 20\n// module chunks = 0 1 2","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_shared.js\n// module id = 21\n// module chunks = 0 1 2","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_uid.js\n// module id = 22\n// module chunks = 0 1 2","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_enum-bug-keys.js\n// module id = 23\n// module chunks = 0 1 2","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iobject.js\n// module id = 24\n// module chunks = 0 1 2","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_ie8-dom-define.js\n// module id = 25\n// module chunks = 0 1 2","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-primitive.js\n// module id = 26\n// module chunks = 0 1 2","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-keys.js\n// module id = 27\n// module chunks = 0 1 2","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-length.js\n// module id = 28\n// module chunks = 0 1 2","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_set-to-string-tag.js\n// module id = 29\n// module chunks = 0 1","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-define.js\n// module id = 30\n// module chunks = 0 1","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-keys-internal.js\n// module id = 31\n// module chunks = 0 1 2","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_array-includes.js\n// module id = 32\n// module chunks = 0 1 2","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-index.js\n// module id = 33\n// module chunks = 0 1 2","module.exports = true;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_library.js\n// module id = 34\n// module chunks = 0 1","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-create.js\n// module id = 35\n// module chunks = 0 1","module.exports = require('./_global').document && document.documentElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_html.js\n// module id = 36\n// module chunks = 0 1","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-object.js\n// module id = 37\n// module chunks = 0 1","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_classof.js\n// module id = 38\n// module chunks = 0 1","exports.f = {}.propertyIsEnumerable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-pie.js\n// module id = 39\n// module chunks = 0 2","require('./es6.array.iterator');\nvar global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , TO_STRING_TAG = require('./_wks')('toStringTag');\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype;\n  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/web.dom.iterable.js\n// module id = 41\n// module chunks = 0 1","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.array.iterator.js\n// module id = 42\n// module chunks = 0 1","module.exports = function(){ /* empty */ };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_add-to-unscopables.js\n// module id = 43\n// module chunks = 0 1","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-step.js\n// module id = 44\n// module chunks = 0 1","module.exports = require('./_hide');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_redefine.js\n// module id = 45\n// module chunks = 0 1","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-create.js\n// module id = 46\n// module chunks = 0 1","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-dps.js\n// module id = 47\n// module chunks = 0 1","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-gpo.js\n// module id = 48\n// module chunks = 0 1","'use strict';\nvar $at  = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.string.iterator.js\n// module id = 49\n// module chunks = 0 1","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_string-at.js\n// module id = 50\n// module chunks = 0 1","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/core.get-iterator-method.js\n// module id = 51\n// module chunks = 0 1","let raws = {}\nlet spines = {}\nlet filesToLoad = 0\n\nconst _loadRaw = (path) => {\n    return new Promise((resolve, reject) => {\n        let xhr = new XMLHttpRequest()\n        xhr.open('GET', path)\n        xhr.onload = () => resolve(xhr.responseText)\n        xhr.onerror = () => resolve(xhr.statusText)\n        xhr.send()\n    })\n}\n\nconst _loadTexture = (path) => {\n    return new Promise((resolve, reject) => {\n        let texture = PIXI.BaseTexture.fromImage(path)\n        texture.on('loaded', (baseTexture) => resolve(baseTexture))\n        texture.on('error', (baseTexture) => reject(baseTexture))\n    })\n}\n\nconst loadAssets = (spineName) => {\n    let setup = ysp.Spine.SETUP[spineName]\n    if (raws[spineName]) {\n        return\n    }\n    raws[spineName] = {}\n    filesToLoad = filesToLoad + 3\n\n    _loadRaw(setup.json)\n        .then((res) => {\n            raws[spineName].json = JSON.parse(res)\n            filesToLoad = filesToLoad - 1\n        })\n        .catch((res) => {\n            console.log(res)\n        })\n\n    _loadRaw(setup.atlas)\n        .then((res) => {\n            raws[spineName].atlas = res\n            filesToLoad = filesToLoad - 1\n        })\n        .catch((res) => {\n            console.log(res)\n        })\n\n    _loadTexture(setup.texture)\n        .then((texture) => {\n            raws[spineName].texture = texture\n            filesToLoad = filesToLoad - 1\n        })\n        .catch((texture) => {\n            console.log(`Couldn't load: ${setup.texture}`)\n        })\n}\n\nconst loadSkeleton = (spineName) => {\n    let setup = ysp.Spine.SETUP[spineName]\n\n    if (spines[spineName]) {\n        return spines[spineName]\n    }\n\n    if (!raws[spineName]) {\n        console.log(`[Error] Spine '${spineName}' hasn't pre-loaded`)\n        return\n    }\n\n    let rawSkeletonData = raws[spineName].json\n    let rawAtlasData = raws[spineName].atlas\n\n    let spineAtlas = new PIXI.spine.core.TextureAtlas(rawAtlasData, function (line, callback) {\n        callback(raws[spineName].texture)\n    })\n\n    let spineAtlasLoader = new PIXI.spine.core.AtlasAttachmentLoader(spineAtlas)\n    let spineJsonParser = new PIXI.spine.core.SkeletonJson(spineAtlasLoader)\n\n    let spineData = spineJsonParser.readSkeletonData(rawSkeletonData)\n    spines[spineName] = spineData\n\n    return spines[spineName]\n}\n\nconst isLoaded = () => {\n    return filesToLoad === 0\n}\n\nexport default {\n    loadAssets,\n    loadSkeleton,\n    isLoaded,\n    raws,\n    spines,\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Spine/loader.js","var ctx                = require('./_ctx')\n  , invoke             = require('./_invoke')\n  , html               = require('./_html')\n  , cel                = require('./_dom-create')\n  , global             = require('./_global')\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(require('./_cof')(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_task.js\n// module id = 54\n// module chunks = 0","import './pixi-spine'\n\nimport spine from './spine'\nimport loader from './loader'\nimport sceneBase from './scene-base'\n\nwindow.ysp = window.ysp || {}\n\nsceneBase(Scene_Base)\n\nconst exports = {\n    spine,\n    loader,\n}\nwindow.ysp.Spine = Object.assign({}, window.ysp.Spine, exports)\n\n\n// WEBPACK FOOTER //\n// ./src/Spine/index.js","module.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/object/assign.js\n// module id = 64\n// module chunks = 0","require('../../modules/es6.object.assign');\nmodule.exports = require('../../modules/_core').Object.assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/object/assign.js\n// module id = 65\n// module chunks = 0","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.object.assign.js\n// module id = 66\n// module chunks = 0","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = require('./_object-keys')\n  , gOPS     = require('./_object-gops')\n  , pIE      = require('./_object-pie')\n  , toObject = require('./_to-object')\n  , IObject  = require('./_iobject')\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-assign.js\n// module id = 67\n// module chunks = 0","exports.f = Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-gops.js\n// module id = 68\n// module chunks = 0","/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Animation {\n        name: string;\n        timelines: Array<Timeline>;\n        duration: number;\n\n        constructor (name: string, timelines: Array<Timeline>, duration: number) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            if (timelines == null) throw new Error(\"timelines cannot be null.\");\n            this.name = name;\n            this.timelines = timelines;\n            this.duration = duration;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n            if (loop && this.duration != 0) {\n                time %= this.duration;\n                if (lastTime > 0) lastTime %= this.duration;\n            }\n\n            let timelines = this.timelines;\n            for (let i = 0, n = timelines.length; i < n; i++)\n                timelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction);\n        }\n\n        static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\n            let low = 0;\n            let high = values.length / step - 2;\n            if (high == 0) return step;\n            let current = high >>> 1;\n            while (true) {\n                if (values[(current + 1) * step] <= target)\n                    low = current + 1;\n                else\n                    high = current;\n                if (low == high) return (low + 1) * step;\n                current = (low + high) >>> 1;\n            }\n        }\n\n        static linearSearch (values: ArrayLike<number>, target: number, step: number) {\n            for (let i = 0, last = values.length - step; i <= last; i += step)\n                if (values[i] > target) return i;\n            return -1;\n        }\n    }\n\n    export interface Timeline {\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection): void;\n        getPropertyId (): number;\n    }\n\n    export enum MixPose {\n        setup,\n        current,\n        currentLayered\n    }\n\n    export enum MixDirection {\n        in, out\n    }\n\n    export enum TimelineType {\n        rotate, translate, scale, shear,\n        attachment, color, deform,\n        event, drawOrder,\n        ikConstraint, transformConstraint,\n        pathConstraintPosition, pathConstraintSpacing, pathConstraintMix,\n        twoColor\n    }\n\n    export abstract class CurveTimeline implements Timeline {\n        static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\n        static BEZIER_SIZE = 10 * 2 - 1;\n\n        private curves: ArrayLike<number>; // type, x, y, ...\n\n        abstract getPropertyId(): number;\n\n        constructor (frameCount: number) {\n            if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n            this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n        }\n\n        getFrameCount () {\n            return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n        }\n\n        setLinear (frameIndex: number) {\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n        }\n\n        setStepped (frameIndex: number) {\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n        }\n\n        getCurveType (frameIndex: number): number {\n            let index = frameIndex * CurveTimeline.BEZIER_SIZE;\n            if (index == this.curves.length) return CurveTimeline.LINEAR;\n            let type = this.curves[index];\n            if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n            if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n            return CurveTimeline.BEZIER;\n        }\n\n        /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n         * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n         * the difference between the keyframe's values. */\n        setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n            let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\n            let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n            let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\n            let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n            let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n            let curves = this.curves;\n            curves[i++] = CurveTimeline.BEZIER;\n\n            let x = dfx, y = dfy;\n            for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                curves[i] = x;\n                curves[i + 1] = y;\n                dfx += ddfx;\n                dfy += ddfy;\n                ddfx += dddfx;\n                ddfy += dddfy;\n                x += dfx;\n                y += dfy;\n            }\n        }\n\n        getCurvePercent (frameIndex: number, percent: number) {\n            percent = MathUtils.clamp(percent, 0, 1);\n            let curves = this.curves;\n            let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n            let type = curves[i];\n            if (type == CurveTimeline.LINEAR) return percent;\n            if (type == CurveTimeline.STEPPED) return 0;\n            i++;\n            let x = 0;\n            for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                x = curves[i];\n                if (x >= percent) {\n                    let prevX: number, prevY: number;\n                    if (i == start) {\n                        prevX = 0;\n                        prevY = 0;\n                    } else {\n                        prevX = curves[i - 2];\n                        prevY = curves[i - 1];\n                    }\n                    return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n                }\n            }\n            let y = curves[i - 1];\n            return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n        }\n\n        abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection): void;\n    }\n\n    export class RotateTimeline extends CurveTimeline {\n        static ENTRIES = 2;\n        static PREV_TIME = -2; static PREV_ROTATION = -1;\n        static ROTATION = 1;\n\n        boneIndex: number;\n        frames: ArrayLike<number>; // time, degrees, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount << 1);\n        }\n\n        getPropertyId () {\n            return (TimelineType.rotate << 24) + this.boneIndex;\n        }\n\n        /** Sets the time and angle of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, degrees: number) {\n            frameIndex <<= 1;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        bone.rotation = bone.data.rotation;\n                        return;\n                    case MixPose.current:\n                        let r = bone.data.rotation - bone.rotation;\n                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                        bone.rotation += r * alpha;\n                }\n                return;\n            }\n\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\n                if (pose == MixPose.setup)\n                    bone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;\n                else {\n                    let r = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\n                    bone.rotation += r * alpha;\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n            let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent((frame >> 1) - 1,\n                1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n            let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n            r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n            r = prevRotation + r * percent;\n            if (pose == MixPose.setup) {\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                bone.rotation = bone.data.rotation + r * alpha;\n            } else {\n                r = bone.data.rotation + r - bone.rotation;\n                r -= (16384 - ((16384.499999999996 - r / 360) |0)) * 360;\n                bone.rotation += r * alpha;\n            }\n        }\n    }\n\n    export class TranslateTimeline extends CurveTimeline {\n        static ENTRIES = 3;\n        static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\n        static X = 1; static Y = 2;\n\n        boneIndex: number;\n        frames: ArrayLike<number>; // time, x, y, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.translate << 24) + this.boneIndex;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, x: number, y: number) {\n            frameIndex *= TranslateTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TranslateTimeline.X] = x;\n            this.frames[frameIndex + TranslateTimeline.Y] = y;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        bone.x = bone.data.x;\n                        bone.y = bone.data.y;\n                        return;\n                    case MixPose.current:\n                        bone.x += (bone.data.x - bone.x) * alpha;\n                        bone.y += (bone.data.y - bone.y) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + TranslateTimeline.PREV_X];\n                y = frames[frames.length + TranslateTimeline.PREV_Y];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n                x = frames[frame + TranslateTimeline.PREV_X];\n                y = frames[frame + TranslateTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n                x += (frames[frame + TranslateTimeline.X] - x) * percent;\n                y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n            }\n            if (pose == MixPose.setup) {\n                bone.x = bone.data.x + x * alpha;\n                bone.y = bone.data.y + y * alpha;\n            } else {\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n            }\n        }\n    }\n\n    export class ScaleTimeline extends TranslateTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.scale << 24) + this.boneIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        bone.scaleX = bone.data.scaleX;\n                        bone.scaleY = bone.data.scaleY;\n                        return;\n                    case MixPose.current:\n                        bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                        bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n                y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n                x = frames[frame + ScaleTimeline.PREV_X];\n                y = frames[frame + ScaleTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n                x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n                y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n            }\n            if (alpha == 1) {\n                bone.scaleX = x;\n                bone.scaleY = y;\n            } else {\n                let bx = 0, by = 0;\n                if (pose == MixPose.setup) {\n                    bx = bone.data.scaleX;\n                    by = bone.data.scaleY;\n                } else {\n                    bx = bone.scaleX;\n                    by = bone.scaleY;\n                }\n                // Mixing out uses sign of setup or current pose, else use sign of key.\n                if (direction == MixDirection.out) {\n                    x = Math.abs(x) * MathUtils.signum(bx);\n                    y = Math.abs(y) * MathUtils.signum(by);\n                } else {\n                    bx = Math.abs(bx) * MathUtils.signum(x);\n                    by = Math.abs(by) * MathUtils.signum(y);\n                }\n                bone.scaleX = bx + (x - bx) * alpha;\n                bone.scaleY = by + (y - by) * alpha;\n            }\n        }\n    }\n\n    export class ShearTimeline extends TranslateTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.shear << 24) + this.boneIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        bone.shearX = bone.data.shearX;\n                        bone.shearY = bone.data.shearY;\n                        return;\n                    case MixPose.current:\n                        bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                        bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + ShearTimeline.PREV_X];\n                y = frames[frames.length + ShearTimeline.PREV_Y];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n                x = frames[frame + ShearTimeline.PREV_X];\n                y = frames[frame + ShearTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n                x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n                y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n            }\n            if (pose == MixPose.setup) {\n                bone.shearX = bone.data.shearX + x * alpha;\n                bone.shearY = bone.data.shearY + y * alpha;\n            } else {\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n            }\n        }\n    }\n\n    export class ColorTimeline extends CurveTimeline {\n        static ENTRIES = 5;\n        static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\n        static R = 1; static G = 2; static B = 3; static A = 4;\n\n        slotIndex: number;\n        frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.color << 24) + this.slotIndex;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n            frameIndex *= ColorTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + ColorTimeline.R] = r;\n            this.frames[frameIndex + ColorTimeline.G] = g;\n            this.frames[frameIndex + ColorTimeline.B] = b;\n            this.frames[frameIndex + ColorTimeline.A] = a;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            let frames = this.frames;\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        slot.color.setFromColor(slot.data.color);\n                        return;\n                    case MixPose.current:\n                        let color = slot.color, setup = slot.data.color;\n                        color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\n                            (setup.a - color.a) * alpha);\n                }\n                return;\n            }\n\n            let r = 0, g = 0, b = 0, a = 0;\n            if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                r = frames[i + ColorTimeline.PREV_R];\n                g = frames[i + ColorTimeline.PREV_G];\n                b = frames[i + ColorTimeline.PREV_B];\n                a = frames[i + ColorTimeline.PREV_A];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n                r = frames[frame + ColorTimeline.PREV_R];\n                g = frames[frame + ColorTimeline.PREV_G];\n                b = frames[frame + ColorTimeline.PREV_B];\n                a = frames[frame + ColorTimeline.PREV_A];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n                r += (frames[frame + ColorTimeline.R] - r) * percent;\n                g += (frames[frame + ColorTimeline.G] - g) * percent;\n                b += (frames[frame + ColorTimeline.B] - b) * percent;\n                a += (frames[frame + ColorTimeline.A] - a) * percent;\n            }\n            if (alpha == 1)\n                slot.color.set(r, g, b, a);\n            else {\n                let color = slot.color;\n                if (pose == MixPose.setup) color.setFromColor(slot.data.color);\n                color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n            }\n        }\n    }\n\n    export class TwoColorTimeline extends CurveTimeline {\n        static ENTRIES = 8;\n        static PREV_TIME = -8; static PREV_R = -7; static PREV_G = -6; static PREV_B = -5; static PREV_A = -4;\n        static PREV_R2 = -3; static PREV_G2 = -2; static PREV_B2 = -1;\n        static R = 1; static G = 2; static B = 3; static A = 4; static R2 = 5; static G2 = 6; static B2 = 7;\n\n        slotIndex: number;\n        frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.twoColor << 24) + this.slotIndex;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n            frameIndex *= TwoColorTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TwoColorTimeline.R] = r;\n            this.frames[frameIndex + TwoColorTimeline.G] = g;\n            this.frames[frameIndex + TwoColorTimeline.B] = b;\n            this.frames[frameIndex + TwoColorTimeline.A] = a;\n            this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n            this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n            this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            let frames = this.frames;\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        slot.color.setFromColor(slot.data.color);\n                        slot.darkColor.setFromColor(slot.data.darkColor);\n                        return;\n                    case MixPose.current:\n                        let light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\n                        light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\n                            (setupLight.a - light.a) * alpha);\n                        dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n                }\n                return;\n            }\n\n            let r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\n            if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                r = frames[i + TwoColorTimeline.PREV_R];\n                g = frames[i + TwoColorTimeline.PREV_G];\n                b = frames[i + TwoColorTimeline.PREV_B];\n                a = frames[i + TwoColorTimeline.PREV_A];\n                r2 = frames[i + TwoColorTimeline.PREV_R2];\n                g2 = frames[i + TwoColorTimeline.PREV_G2];\n                b2 = frames[i + TwoColorTimeline.PREV_B2];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n                r = frames[frame + TwoColorTimeline.PREV_R];\n                g = frames[frame + TwoColorTimeline.PREV_G];\n                b = frames[frame + TwoColorTimeline.PREV_B];\n                a = frames[frame + TwoColorTimeline.PREV_A];\n                r2 = frames[frame + TwoColorTimeline.PREV_R2];\n                g2 = frames[frame + TwoColorTimeline.PREV_G2];\n                b2 = frames[frame + TwoColorTimeline.PREV_B2];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n\n                r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n                g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n                b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n                a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n                r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n                g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n                b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n            }\n            if (alpha == 1) {\n                slot.color.set(r, g, b, a);\n                slot.darkColor.set(r2, g2, b2, 1);\n            } else {\n                let light = slot.color, dark = slot.darkColor;\n                if (pose == MixPose.setup) {\n                    light.setFromColor(slot.data.color);\n                    dark.setFromColor(slot.data.darkColor);\n                }\n                light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n                dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n            }\n        }\n    }\n\n    export class AttachmentTimeline implements Timeline {\n        slotIndex: number;\n        frames: ArrayLike<number> // time, ...\n        attachmentNames: Array<string>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.attachmentNames = new Array<string>(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.attachment << 24) + this.slotIndex;\n        }\n\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, attachmentName: string) {\n            this.frames[frameIndex] = time;\n            this.attachmentNames[frameIndex] = attachmentName;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            if (direction == MixDirection.out && pose == MixPose.setup) {\n                let attachmentName = slot.data.attachmentName;\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n                return;\n            }\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                if (pose == MixPose.setup) {\n                    let attachmentName = slot.data.attachmentName;\n                    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n                }\n                return;\n            }\n\n            let frameIndex = 0;\n            if (time >= frames[frames.length - 1]) // Time is after last frame.\n                frameIndex = frames.length - 1;\n            else\n                frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n            let attachmentName = this.attachmentNames[frameIndex];\n            skeleton.slots[this.slotIndex]\n                .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n        }\n    }\n\n    let zeros : ArrayLike<number> = null;\n\n    export class DeformTimeline extends CurveTimeline {\n        slotIndex: number;\n        attachment: VertexAttachment;\n        frames: ArrayLike<number>; // time, ...\n        frameVertices: Array<ArrayLike<number>>;\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount);\n            this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n            if (zeros == null) zeros = Utils.newFloatArray(64);\n        }\n\n        getPropertyId () {\n            return (TimelineType.deform << 27) + + this.attachment.id + this.slotIndex;\n        }\n\n        /** Sets the time of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\n            this.frames[frameIndex] = time;\n            this.frameVertices[frameIndex] = vertices;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let slot: Slot = skeleton.slots[this.slotIndex];\n            let slotAttachment: Attachment = slot.getAttachment();\n            if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\n\n            let verticesArray: Array<number> = slot.attachmentVertices;\n            let frameVertices = this.frameVertices;\n            let vertexCount = frameVertices[0].length;\n            let vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                let vertexAttachment = <VertexAttachment>slotAttachment;\n                switch (pose) {\n                    case MixPose.setup:\n                        let zeroVertices: ArrayLike<number>;\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions (setup pose).\n                            zeroVertices = vertexAttachment.vertices;\n                        } else {\n                            // Weighted deform offsets (zeros).\n                            zeroVertices = zeros;\n                            if (zeroVertices.length < vertexCount) zeros = zeroVertices = Utils.newFloatArray(vertexCount);\n                        }\n                        Utils.arrayCopy(zeroVertices, 0, vertices, 0, vertexCount);\n                        return;\n                    case MixPose.current:\n                        if (alpha == 1) break;\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions.\n                            let setupVertices = vertexAttachment.vertices;\n                            for (let i = 0; i < vertexCount; i++)\n                                vertices[i] += (setupVertices[i] - vertices[i]) * alpha;\n                        } else {\n                            // Weighted deform offsets.\n                            alpha = 1 - alpha;\n                            for (var i = 0; i < vertexCount; i++)\n                                vertices[i] *= alpha;\n                        }\n                }\n                return;\n            }\n\n            if (time >= frames[frames.length - 1]) { // Time is after last frame.\n                let lastVertices = frameVertices[frames.length - 1];\n                if (alpha == 1) {\n                    Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n                }else if (pose == MixPose.setup) {\n                    let vertexAttachment = slotAttachment as VertexAttachment;\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        let setupVertices = vertexAttachment.vertices;\n                        for (let i = 0; i < vertexCount; i++) {\n                            let setup = setupVertices[i];\n                            vertices[i] = setup + (lastVertices[i] - setup) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++)\n                            vertices[i] = lastVertices[i] * alpha;\n                    }\n                } else {\n                    for (let i = 0; i < vertexCount; i++)\n                        vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time);\n            let prevVertices = frameVertices[frame - 1];\n            let nextVertices = frameVertices[frame];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n            if (alpha == 1) {\n                for (let i = 0; i < vertexCount; i++) {\n                    let prev = prevVertices[i];\n                    vertices[i] = prev + (nextVertices[i] - prev) * percent;\n                }\n            } else if (pose == MixPose.setup) {\n                let vertexAttachment = slotAttachment as VertexAttachment;\n                if (vertexAttachment.bones == null) {\n                    // Unweighted vertex positions, with alpha.\n                    let setupVertices = vertexAttachment.vertices;\n                    for (let i = 0; i < vertexCount; i++) {\n                        let prev = prevVertices[i], setup = setupVertices[i];\n                        vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                    }\n                } else {\n                    // Weighted deform offsets, with alpha.\n                    for (let i = 0; i < vertexCount; i++) {\n                        let prev = prevVertices[i];\n                        vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                    }\n                }\n            } else {\n                // Vertex positions or deform offsets, with alpha.\n                for (let i = 0; i < vertexCount; i++) {\n                    let prev = prevVertices[i];\n                    vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n                }\n            }\n        }\n    }\n\n    export class EventTimeline implements Timeline {\n        frames: ArrayLike<number>; // time, ...\n        events: Array<Event>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.events = new Array<Event>(frameCount);\n        }\n\n        getPropertyId () {\n            return TimelineType.event << 24;\n        }\n\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time of the specified keyframe. */\n        setFrame (frameIndex: number, event: Event) {\n            this.frames[frameIndex] = event.time;\n            this.events[frameIndex] = event;\n        }\n\n        /** Fires events for frames > lastTime and <= time. */\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            if (firedEvents == null) return;\n            let frames = this.frames;\n            let frameCount = this.frames.length;\n\n            if (lastTime > time) { // Fire events after last time for looped animations.\n                this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);\n                lastTime = -1;\n            } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n                return;\n            if (time < frames[0]) return; // Time is before first frame.\n\n            let frame = 0;\n            if (lastTime < frames[0])\n                frame = 0;\n            else {\n                frame = Animation.binarySearch(frames, lastTime);\n                let frameTime = frames[frame];\n                while (frame > 0) { // Fire multiple events with the same frame.\n                    if (frames[frame - 1] != frameTime) break;\n                    frame--;\n                }\n            }\n            for (; frame < frameCount && time >= frames[frame]; frame++)\n                firedEvents.push(this.events[frame]);\n        }\n    }\n\n    export class DrawOrderTimeline implements Timeline {\n        frames: ArrayLike<number>; // time, ...\n        drawOrders: Array<Array<number>>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.drawOrders = new Array<Array<number>>(frameCount);\n        }\n\n        getPropertyId () {\n            return TimelineType.drawOrder << 24;\n        }\n\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time of the specified keyframe.\n         * @param drawOrder May be null to use bind pose draw order. */\n        setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\n            this.frames[frameIndex] = time;\n            this.drawOrders[frameIndex] = drawOrder;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let drawOrder: Array<Slot> = skeleton.drawOrder;\n            let slots: Array<Slot> = skeleton.slots;\n            if (direction == MixDirection.out && pose == MixPose.setup) {\n                Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                return;\n            }\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                if (pose == MixPose.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                return;\n            }\n\n            let frame = 0;\n            if (time >= frames[frames.length - 1]) // Time is after last frame.\n                frame = frames.length - 1;\n            else\n                frame = Animation.binarySearch(frames, time) - 1;\n\n            let drawOrderToSetupIndex = this.drawOrders[frame];\n            if (drawOrderToSetupIndex == null)\n                Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n            else {\n                for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n                    drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n            }\n        }\n    }\n\n    export class IkConstraintTimeline extends CurveTimeline {\n        static ENTRIES = 3;\n        static PREV_TIME = -3; static PREV_MIX = -2; static PREV_BEND_DIRECTION = -1;\n        static MIX = 1; static BEND_DIRECTION = 2;\n\n        ikConstraintIndex: number;\n        frames: ArrayLike<number>; // time, mix, bendDirection, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n        }\n\n        /** Sets the time, mix and bend direction of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, mix: number, bendDirection: number) {\n            frameIndex *= IkConstraintTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n            this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.mix = constraint.data.mix;\n                        constraint.bendDirection = constraint.data.bendDirection;\n                        return;\n                    case MixPose.current:\n                        constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                        constraint.bendDirection = constraint.data.bendDirection;\n                }\n                return;\n            }\n\n            if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\n                if (pose == MixPose.setup) {\n                    constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                    constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection\n                        : frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                } else {\n                    constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                    if (direction == MixDirection.in) constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n            let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n            if (pose == MixPose.setup) {\n                constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n                constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n            } else {\n                constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n                if (direction == MixDirection.in) constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n            }\n        }\n    }\n\n    export class TransformConstraintTimeline extends CurveTimeline {\n        static ENTRIES = 5;\n        static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\n        static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\n\n        transformConstraintIndex: number;\n        frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n        }\n\n        /** Sets the time and mixes of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n            frameIndex *= TransformConstraintTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n            this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n            this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n            this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n            if (time < frames[0]) {\n                let data = constraint.data;\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.rotateMix = data.rotateMix;\n                        constraint.translateMix = data.translateMix;\n                        constraint.scaleMix = data.scaleMix;\n                        constraint.shearMix = data.shearMix;\n                        return;\n                    case MixPose.current:\n                        constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                        constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                        constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                        constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n                }\n                return;\n            }\n\n            let rotate = 0, translate = 0, scale = 0, shear = 0;\n            if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n                translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n                scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n                shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n                rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n                translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n                scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n                shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n\n                rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n                translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n                scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n                shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n            }\n            if (pose == MixPose.setup) {\n                let data = constraint.data;\n                constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n                constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n                constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n                constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n            } else {\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\n                constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n                constraint.shearMix += (shear - constraint.shearMix) * alpha;\n            }\n        }\n    }\n\n    export class PathConstraintPositionTimeline extends CurveTimeline {\n        static ENTRIES = 2;\n        static PREV_TIME = -2; static PREV_VALUE = -1;\n        static VALUE = 1;\n\n        pathConstraintIndex: number;\n\n        frames: ArrayLike<number>; // time, position, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, value: number) {\n            frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.position = constraint.data.position;\n                        return;\n                    case MixPose.current:\n                        constraint.position += (constraint.data.position - constraint.position) * alpha;\n                }\n                return;\n            }\n\n            let position = 0;\n            if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) // Time is after last frame.\n                position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n                position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n\n                position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n            }\n            if (pose == MixPose.setup)\n                constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n            else\n                constraint.position += (position - constraint.position) * alpha;\n        }\n    }\n\n    export class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.spacing = constraint.data.spacing;\n                        return;\n                    case MixPose.current:\n                        constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n                }\n                return;\n            }\n\n            let spacing = 0;\n            if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) // Time is after last frame.\n                spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n                spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n\n                spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n            }\n\n            if (pose == MixPose.setup)\n                constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n            else\n                constraint.spacing += (spacing - constraint.spacing) * alpha;\n        }\n    }\n\n    export class PathConstraintMixTimeline extends CurveTimeline {\n        static ENTRIES = 3;\n        static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\n        static ROTATE = 1; static TRANSLATE = 2;\n\n        pathConstraintIndex: number;\n\n        frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n        }\n\n        /** Sets the time and mixes of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n            frameIndex *= PathConstraintMixTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n            this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.rotateMix = constraint.data.rotateMix;\n                        constraint.translateMix = constraint.data.translateMix;\n                        return;\n                    case MixPose.current:\n                        constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                        constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n                }\n                return;\n            }\n\n            let rotate = 0, translate = 0;\n            if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\n                rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n                translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n                rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n                translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n\n                rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n                translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n            }\n\n            if (pose == MixPose.setup) {\n                constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n                constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n            } else {\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\n            }\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class AnimationState {\n        static emptyAnimation = new Animation(\"<empty>\", [], 0);\n        static SUBSEQUENT = 0;\n        static FIRST = 1;\n        static DIP = 2;\n        static DIP_MIX = 3;\n\n        data: AnimationStateData;\n        tracks = new Array<TrackEntry>();\n        events = new Array<Event>();\n        listeners = new Array<AnimationStateListener2>();\n        queue = new EventQueue(this);\n        propertyIDs = new IntSet();\n        mixingTo = new Array<TrackEntry>();\n        animationsChanged = false;\n        timeScale = 1;\n\n        trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n        constructor (data: AnimationStateData) {\n            this.data = data;\n        }\n\n        update (delta: number) {\n            delta *= this.timeScale;\n            let tracks = this.tracks;\n            for (let i = 0, n = tracks.length; i < n; i++) {\n                let current = tracks[i];\n                if (current == null) continue;\n\n                current.animationLast = current.nextAnimationLast;\n                current.trackLast = current.nextTrackLast;\n\n                let currentDelta = delta * current.timeScale;\n\n                if (current.delay > 0) {\n                    current.delay -= currentDelta;\n                    if (current.delay > 0) continue;\n                    currentDelta = -current.delay;\n                    current.delay = 0;\n                }\n\n                let next = current.next;\n                if (next != null) {\n                    // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                    let nextTime = current.trackLast - next.delay;\n                    if (nextTime >= 0) {\n                        next.delay = 0;\n                        next.trackTime = nextTime + delta * next.timeScale;\n                        current.trackTime += currentDelta;\n                        this.setCurrent(i, next, true);\n                        while (next.mixingFrom != null) {\n                            next.mixTime += currentDelta;\n                            next = next.mixingFrom;\n                        }\n                        continue;\n                    }\n                } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                    tracks[i] = null;\n                    this.queue.end(current);\n                    this.disposeNext(current);\n                    continue;\n                }\n                if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                    // End mixing from entries once all have completed.\n                    let from = current.mixingFrom;\n                    current.mixingFrom = null;\n                    while (from != null) {\n                        this.queue.end(from);\n                        from = from.mixingFrom;\n                    }\n                }\n\n                current.trackTime += currentDelta;\n            }\n\n            this.queue.drain();\n        }\n\n        updateMixingFrom (to: TrackEntry, delta: number): boolean {\n            let from = to.mixingFrom;\n            if (from == null) return true;\n\n            let finished = this.updateMixingFrom(from, delta);\n\n            // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n            if (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {\n                if (from.totalAlpha == 0) {\n                    to.mixingFrom = from.mixingFrom;\n                    to.interruptAlpha = from.interruptAlpha;\n                    this.queue.end(from);\n                }\n                return finished;\n            }\n\n            from.animationLast = from.nextAnimationLast;\n            from.trackLast = from.nextTrackLast;\n            from.trackTime += delta * from.timeScale;\n            to.mixTime += delta * to.timeScale;\n            return false;\n        }\n\n        apply (skeleton: Skeleton) : boolean {\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            if (this.animationsChanged) this._animationsChanged();\n\n            let events = this.events;\n            let tracks = this.tracks;\n            let applied = false;\n\n            for (let i = 0, n = tracks.length; i < n; i++) {\n                let current = tracks[i];\n                if (current == null || current.delay > 0) continue;\n                applied = true;\n                let currentPose = i == 0 ? MixPose.current : MixPose.currentLayered;\n\n                // Apply mixing from entries first.\n                let mix = current.alpha;\n                if (current.mixingFrom != null)\n                    mix *= this.applyMixingFrom(current, skeleton, currentPose);\n                else if (current.trackTime >= current.trackEnd && current.next == null)\n                    mix = 0;\n\n                // Apply current entry.\n                let animationLast = current.animationLast, animationTime = current.getAnimationTime();\n                let timelineCount = current.animation.timelines.length;\n                let timelines = current.animation.timelines;\n                if (mix == 1) {\n                    for (let ii = 0; ii < timelineCount; ii++)\n                        timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, MixPose.setup, MixDirection.in);\n                } else {\n                    let timelineData = current.timelineData;\n\n                    let firstFrame = current.timelinesRotation.length == 0;\n                    if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                    let timelinesRotation = current.timelinesRotation;\n\n                    for (let ii = 0; ii < timelineCount; ii++) {\n                        let timeline = timelines[ii];\n                        let pose = timelineData[ii] >= AnimationState.FIRST ? MixPose.setup : currentPose;\n                        if (timeline instanceof RotateTimeline) {\n                            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);\n                        } else\n                            timeline.apply(skeleton, animationLast, animationTime, events, mix, pose, MixDirection.in);\n                    }\n                }\n                this.queueEvents(current, animationTime);\n                events.length = 0;\n                current.nextAnimationLast = animationTime;\n                current.nextTrackLast = current.trackTime;\n            }\n\n            this.queue.drain();\n            return applied;\n        }\n\n        applyMixingFrom (to: TrackEntry, skeleton: Skeleton, currentPose: MixPose) {\n            let from = to.mixingFrom;\n            if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, currentPose);\n\n            let mix = 0;\n            if (to.mixDuration == 0) // Single frame mix to undo mixingFrom changes.\n                mix = 1;\n            else {\n                mix = to.mixTime / to.mixDuration;\n                if (mix > 1) mix = 1;\n            }\n\n            let events = mix < from.eventThreshold ? this.events : null;\n            let attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\n            let animationLast = from.animationLast, animationTime = from.getAnimationTime();\n            let timelineCount = from.animation.timelines.length;\n            let timelines = from.animation.timelines;\n            let timelineData = from.timelineData;\n            let timelineDipMix = from.timelineDipMix;\n\n            let firstFrame = from.timelinesRotation.length == 0;\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n            let timelinesRotation = from.timelinesRotation;\n\n            let pose: MixPose;\n            let alphaDip = from.alpha * to.interruptAlpha, alphaMix = alphaDip * (1 - mix), alpha = 0;\n            from.totalAlpha = 0;\n            for (var i = 0; i < timelineCount; i++) {\n                let timeline = timelines[i];\n                switch (timelineData[i]) {\n                    case AnimationState.SUBSEQUENT:\n                        if (!attachments && timeline instanceof AttachmentTimeline) continue;\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        pose = currentPose;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.FIRST:\n                        pose = MixPose.setup\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.DIP:\n                        pose = MixPose.setup;\n                        alpha = alphaDip;\n                        break;\n                    default:\n                        pose = MixPose.setup;\n                        alpha = alphaDip;\n                        let dipMix = timelineDipMix[i];\n                        alpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n                if (timeline instanceof RotateTimeline)\n                    this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);\n                else {\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, MixDirection.out);\n                }\n            }\n\n            if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n            this.events.length = 0;\n            from.nextAnimationLast = animationTime;\n            from.nextTrackLast = from.trackTime;\n\n            return mix;\n        }\n\n        applyRotateTimeline (timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, pose: MixPose,\n                             timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\n\n            if (firstFrame) timelinesRotation[i] = 0;\n\n            if (alpha == 1) {\n                timeline.apply(skeleton, 0, time, null, 1, pose, MixDirection.in);\n                return;\n            }\n\n            let rotateTimeline = timeline as RotateTimeline;\n            let frames = rotateTimeline.frames;\n            let bone = skeleton.bones[rotateTimeline.boneIndex];\n            if (time < frames[0]) {\n                if (pose == MixPose.setup) bone.rotation = bone.data.rotation;\n                return;\n            }\n\n            let r2 = 0;\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) // Time is after last frame.\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                let frameTime = frames[frame];\n                let percent = rotateTimeline.getCurvePercent((frame >> 1) - 1,\n                    1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n            }\n\n            // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n            let r1 = pose == MixPose.setup ? bone.data.rotation : bone.rotation;\n            let total = 0, diff = r2 - r1;\n            if (diff == 0) {\n                total = timelinesRotation[i];\n            } else {\n                diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n                let lastTotal = 0, lastDiff = 0;\n                if (firstFrame) {\n                    lastTotal = 0;\n                    lastDiff = diff;\n                } else {\n                    lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                    lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n                }\n                let current = diff > 0, dir = lastTotal >= 0;\n                // Detect cross at 0 (not 180).\n                if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                    // A cross after a 360 rotation is a loop.\n                    if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                    dir = current;\n                }\n                total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\n                if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n                timelinesRotation[i] = total;\n            }\n            timelinesRotation[i + 1] = diff;\n            r1 += total * alpha;\n            bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n        }\n\n        queueEvents (entry: TrackEntry, animationTime: number) {\n            let animationStart = entry.animationStart, animationEnd = entry.animationEnd;\n            let duration = animationEnd - animationStart;\n            let trackLastWrapped = entry.trackLast % duration;\n\n            // Queue events before complete.\n            let events = this.events;\n            let i = 0, n = events.length;\n            for (; i < n; i++) {\n                let event = events[i];\n                if (event.time < trackLastWrapped) break;\n                if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n                this.queue.event(entry, event);\n            }\n\n            // Queue complete if completed a loop iteration or the animation.\n            if (entry.loop ? (trackLastWrapped > entry.trackTime % duration)\n                    : (animationTime >= animationEnd && entry.animationLast < animationEnd)) {\n                this.queue.complete(entry);\n            }\n\n            // Queue events after complete.\n            for (; i < n; i++) {\n                let event = events[i];\n                if (event.time < animationStart) continue; // Discard events outside animation start/end.\n                this.queue.event(entry, events[i]);\n            }\n        }\n\n        clearTracks () {\n            let oldDrainDisabled = this.queue.drainDisabled;\n            this.queue.drainDisabled = true;\n            for (let i = 0, n = this.tracks.length; i < n; i++)\n                this.clearTrack(i);\n            this.tracks.length = 0;\n            this.queue.drainDisabled = oldDrainDisabled;\n            this.queue.drain();\n        }\n\n        clearTrack (trackIndex: number) {\n            if (trackIndex >= this.tracks.length) return;\n            let current = this.tracks[trackIndex];\n            if (current == null) return;\n\n            this.queue.end(current);\n\n            this.disposeNext(current);\n\n            let entry = current;\n            while (true) {\n                let from = entry.mixingFrom;\n                if (from == null) break;\n                this.queue.end(from);\n                entry.mixingFrom = null;\n                entry = from;\n            }\n\n            this.tracks[current.trackIndex] = null;\n\n            this.queue.drain();\n        }\n\n        setCurrent (index: number, current: TrackEntry, interrupt: boolean) {\n            let from = this.expandToIndex(index);\n            this.tracks[index] = current;\n\n            if (from != null) {\n                if (interrupt) this.queue.interrupt(from);\n                current.mixingFrom = from;\n                current.mixTime = 0;\n\n                // Store the interrupted mix percentage.\n                if (from.mixingFrom != null && from.mixDuration > 0)\n                    current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n                from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n            }\n\n            this.queue.start(current);\n        }\n\n        setAnimation (trackIndex: number, animationName: string, loop: boolean) {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n            return this.setAnimationWith(trackIndex, animation, loop);\n        }\n\n        setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\n            if (animation == null) throw new Error(\"animation cannot be null.\");\n            let interrupt = true;\n            let current = this.expandToIndex(trackIndex);\n            if (current != null) {\n                if (current.nextTrackLast == -1) {\n                    // Don't mix from an entry that was never applied.\n                    this.tracks[trackIndex] = current.mixingFrom;\n                    this.queue.interrupt(current);\n                    this.queue.end(current);\n                    this.disposeNext(current);\n                    current = current.mixingFrom;\n                    interrupt = false;\n                } else\n                    this.disposeNext(current);\n            }\n            let entry = this.trackEntry(trackIndex, animation, loop, current);\n            this.setCurrent(trackIndex, entry, interrupt);\n            this.queue.drain();\n            return entry;\n        }\n\n        addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n            return this.addAnimationWith(trackIndex, animation, loop, delay);\n        }\n\n        addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n            if (animation == null) throw new Error(\"animation cannot be null.\");\n\n            let last = this.expandToIndex(trackIndex);\n            if (last != null) {\n                while (last.next != null)\n                    last = last.next;\n            }\n\n            let entry = this.trackEntry(trackIndex, animation, loop, last);\n\n            if (last == null) {\n                this.setCurrent(trackIndex, entry, true);\n                this.queue.drain();\n            } else {\n                last.next = entry;\n                if (delay <= 0) {\n                    let duration = last.animationEnd - last.animationStart;\n                    if (duration != 0)\n                        delay += duration * (1 + ((last.trackTime / duration) | 0)) - this.data.getMix(last.animation, animation);\n                    else\n                        delay = 0;\n                }\n            }\n\n            entry.delay = delay;\n            return entry;\n        }\n\n        setEmptyAnimation (trackIndex: number, mixDuration: number) {\n            let entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n            entry.mixDuration = mixDuration;\n            entry.trackEnd = mixDuration;\n            return entry;\n        }\n\n        addEmptyAnimation (trackIndex: number, mixDuration: number, delay: number) {\n            if (delay <= 0) delay -= mixDuration;\n            let entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n            entry.mixDuration = mixDuration;\n            entry.trackEnd = mixDuration;\n            return entry;\n        }\n\n        setEmptyAnimations (mixDuration: number) {\n            let oldDrainDisabled = this.queue.drainDisabled;\n            this.queue.drainDisabled = true;\n            for (let i = 0, n = this.tracks.length; i < n; i++) {\n                let current = this.tracks[i];\n                if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n            }\n            this.queue.drainDisabled = oldDrainDisabled;\n            this.queue.drain();\n        }\n\n        expandToIndex (index: number) {\n            if (index < this.tracks.length) return this.tracks[index];\n            Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\n            this.tracks.length = index + 1;\n            return null;\n        }\n\n        trackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\n            let entry = this.trackEntryPool.obtain();\n            entry.trackIndex = trackIndex;\n            entry.animation = animation;\n            entry.loop = loop;\n\n            entry.eventThreshold = 0;\n            entry.attachmentThreshold = 0;\n            entry.drawOrderThreshold = 0;\n\n            entry.animationStart = 0;\n            entry.animationEnd = animation.duration;\n            entry.animationLast = -1;\n            entry.nextAnimationLast = -1;\n\n            entry.delay = 0;\n            entry.trackTime = 0;\n            entry.trackLast = -1;\n            entry.nextTrackLast = -1;\n            entry.trackEnd = Number.MAX_VALUE;\n            entry.timeScale = 1;\n\n            entry.alpha = 1;\n            entry.interruptAlpha = 1;\n            entry.mixTime = 0;\n            entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n            return entry;\n        }\n\n        disposeNext (entry: TrackEntry) {\n            let next = entry.next;\n            while (next != null) {\n                this.queue.dispose(next);\n                next = next.next;\n            }\n            entry.next = null;\n        }\n\n        _animationsChanged () {\n            this.animationsChanged = false;\n\n            let propertyIDs = this.propertyIDs;\n            propertyIDs.clear();\n            let mixingTo = this.mixingTo;\n\n            let lastEntry: TrackEntry = null;\n            for (let i = 0, n = this.tracks.length; i < n; i++) {\n                let entry = this.tracks[i];\n                if (entry != null) entry.setTimelineData(null, mixingTo, propertyIDs);\n            }\n        }\n\n        getCurrent (trackIndex: number) {\n            if (trackIndex >= this.tracks.length) return null;\n            return this.tracks[trackIndex];\n        }\n\n        addListener (listener: AnimationStateListener2) {\n            if (listener == null) throw new Error(\"listener cannot be null.\");\n            this.listeners.push(listener);\n        }\n\n        /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */\n        removeListener (listener: AnimationStateListener2) {\n            let index = this.listeners.indexOf(listener);\n            if (index >= 0) this.listeners.splice(index, 1);\n        }\n\n        clearListeners () {\n            this.listeners.length = 0;\n        }\n\n        clearListenerNotifications () {\n            this.queue.clear();\n        }\n\n        //deprecated stuff\n        onComplete: (trackIndex: number, loopCount: number) => any;\n        onEvent: (trackIndex: number, event: Event) => any;\n        onStart: (trackIndex: number) => any;\n        onEnd: (trackIndex: number) => any;\n\n        private static deprecatedWarning1: boolean = false;\n\n        setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n            if (!AnimationState.deprecatedWarning1) {\n                AnimationState.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n            }\n            this.setAnimation(trackIndex, animationName, loop);\n        }\n\n        private static deprecatedWarning2: boolean = false;\n\n        addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n            if (!AnimationState.deprecatedWarning2) {\n                AnimationState.deprecatedWarning2 = true;\n                console.warn(\"Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n            }\n            this.addAnimation(trackIndex, animationName, loop, delay);\n        }\n\n        private static deprecatedWarning3: boolean = false;\n\n        hasAnimation(animationName: string): boolean {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            return animation !== null;\n        }\n\n        hasAnimationByName(animationName: string): boolean {\n            if (!AnimationState.deprecatedWarning3) {\n                AnimationState.deprecatedWarning3 = true;\n                console.warn(\"Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n            }\n            return this.hasAnimation(animationName);\n        }\n    }\n\n    export class TrackEntry {\n        animation: Animation;\n        next: TrackEntry; mixingFrom: TrackEntry;\n        listener: AnimationStateListener2;\n        trackIndex: number;\n        loop: boolean;\n        eventThreshold: number; attachmentThreshold: number; drawOrderThreshold: number;\n        animationStart: number; animationEnd: number; animationLast: number; nextAnimationLast: number;\n        delay: number; trackTime: number; trackLast: number; nextTrackLast: number; trackEnd: number; timeScale: number;\n        alpha: number; mixTime: number; mixDuration: number; interruptAlpha: number; totalAlpha: number;\n        timelineData = new Array<number>();\n        timelineDipMix = new Array<TrackEntry>();\n        timelinesRotation = new Array<number>();\n\n        reset () {\n            this.next = null;\n            this.mixingFrom = null;\n            this.animation = null;\n            this.listener = null;\n            this.timelineData.length = 0;\n            this.timelineDipMix.length = 0;\n            this.timelinesRotation.length = 0;\n        }\n\n        setTimelineData (to: TrackEntry, mixingToArray: Array<TrackEntry>, propertyIDs: IntSet) : TrackEntry {\n            if (to != null) mixingToArray.push(to);\n            let lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;\n            if (to != null) mixingToArray.pop();\n\n            let mixingTo = mixingToArray;\n            let mixingToLast = mixingToArray.length - 1;\n            let timelines = this.animation.timelines;\n            let timelinesCount = this.animation.timelines.length;\n            let timelineData = Utils.setArraySize(this.timelineData, timelinesCount);\n            this.timelineDipMix.length = 0;\n            let timelineDipMix = Utils.setArraySize(this.timelineDipMix, timelinesCount);\n\n            outer:\n                for (var i = 0; i < timelinesCount; i++) {\n                    let id = timelines[i].getPropertyId();\n                    if (!propertyIDs.add(id))\n                        timelineData[i] = AnimationState.SUBSEQUENT;\n                    else if (to == null || !to.hasTimeline(id))\n                        timelineData[i] = AnimationState.FIRST;\n                    else {\n                        for (var ii = mixingToLast; ii >= 0; ii--) {\n                            let entry = mixingTo[ii];\n                            if (!entry.hasTimeline(id)) {\n                                if (entry.mixDuration > 0) {\n                                    timelineData[i] = AnimationState.DIP_MIX;\n                                    timelineDipMix[i] = entry;\n                                    continue outer;\n                                }\n                            }\n                        }\n                        timelineData[i] = AnimationState.DIP;\n                    }\n                }\n            return lastEntry;\n        }\n\n        hasTimeline (id: number) : boolean {\n            let timelines = this.animation.timelines;\n            for (var i = 0, n = timelines.length; i < n; i++)\n                if (timelines[i].getPropertyId() == id) return true;\n            return false;\n        }\n\n        getAnimationTime () {\n            if (this.loop) {\n                let duration = this.animationEnd - this.animationStart;\n                if (duration == 0) return this.animationStart;\n                return (this.trackTime % duration) + this.animationStart;\n            }\n            return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n        }\n\n        setAnimationLast(animationLast: number) {\n            this.animationLast = animationLast;\n            this.nextAnimationLast = animationLast;\n        }\n\n        isComplete () {\n            return this.trackTime >= this.animationEnd - this.animationStart;\n        }\n\n        resetRotationDirections () {\n            this.timelinesRotation.length = 0;\n        }\n\n        //deprecated stuff\n        onComplete: (trackIndex: number, loopCount: number) => any;\n        onEvent: (trackIndex: number, event: Event) => any;\n        onStart: (trackIndex: number) => any;\n        onEnd: (trackIndex: number) => any;\n\n        private static deprecatedWarning1: Boolean = false;\n        private static deprecatedWarning2: Boolean = false;\n\n        get time() {\n            if (!TrackEntry.deprecatedWarning1) {\n                TrackEntry.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n            }\n            return this.trackTime;\n        }\n\n        set time(value: number) {\n            if (!TrackEntry.deprecatedWarning1) {\n                TrackEntry.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n            }\n            this.trackTime = value;\n        }\n\n        get endTime() {\n            if (!TrackEntry.deprecatedWarning2) {\n                TrackEntry.deprecatedWarning2 = true;\n                console.warn(\"Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n            }\n            return this.trackTime;\n        }\n\n        set endTime(value: number) {\n            if (!TrackEntry.deprecatedWarning2) {\n                TrackEntry.deprecatedWarning2 = true;\n                console.warn(\"Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n            }\n            this.trackTime = value;\n        }\n\n        loopsCount() {\n            return Math.floor(this.trackTime / this.trackEnd);\n        }\n    }\n\n    export class EventQueue {\n        objects: Array<any> = [];\n        drainDisabled = false;\n        animState: AnimationState;\n\n        constructor(animState: AnimationState) {\n            this.animState = animState;\n        }\n\n        start (entry: TrackEntry) {\n            this.objects.push(EventType.start);\n            this.objects.push(entry);\n            this.animState.animationsChanged = true;\n        }\n\n        interrupt (entry: TrackEntry) {\n            this.objects.push(EventType.interrupt);\n            this.objects.push(entry);\n        }\n\n        end (entry: TrackEntry) {\n            this.objects.push(EventType.end);\n            this.objects.push(entry);\n            this.animState.animationsChanged = true;\n        }\n\n        dispose (entry: TrackEntry) {\n            this.objects.push(EventType.dispose);\n            this.objects.push(entry);\n        }\n\n        complete (entry: TrackEntry) {\n            this.objects.push(EventType.complete);\n            this.objects.push(entry);\n        }\n\n        event (entry: TrackEntry, event: Event) {\n            this.objects.push(EventType.event);\n            this.objects.push(entry);\n            this.objects.push(event);\n        }\n\n        private static deprecatedWarning1: Boolean = false;\n\n        deprecateStuff() {\n            if (!EventQueue.deprecatedWarning1) {\n                EventQueue.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\n            }\n            return true;\n        }\n\n        drain () {\n            if (this.drainDisabled) return;\n            this.drainDisabled = true;\n\n            let objects = this.objects;\n            let listeners = this.animState.listeners;\n\n            for (let i = 0; i < objects.length; i += 2) {\n                let type = objects[i] as EventType;\n                let entry = objects[i + 1] as TrackEntry;\n                switch (type) {\n                    case EventType.start:\n                        if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].start) listeners[ii].start(entry);\n                        //deprecation\n                        entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                        this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                        break;\n                    case EventType.interrupt:\n                        if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                        break;\n                    case EventType.end:\n                        if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].end) listeners[ii].end(entry);\n                        //deprecation\n                        entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                        this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                    // Fall through.\n                    case EventType.dispose:\n                        if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                        this.animState.trackEntryPool.free(entry);\n                        break;\n                    case EventType.complete:\n                        if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].complete) listeners[ii].complete(entry);\n                        //deprecation\n\n                        let count = MathUtils.toInt(entry.loopsCount()) ;\n                        entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                        this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                        break;\n                    case EventType.event:\n                        let event = objects[i++ + 2] as Event;\n                        if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].event) listeners[ii].event(entry, event);\n                        //deprecation\n                        entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n                        this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n                        break;\n                }\n            }\n            this.clear();\n\n            this.drainDisabled = false;\n        }\n\n        clear () {\n            this.objects.length = 0;\n        }\n    }\n\n    export enum EventType {\n        start, interrupt, end, dispose, complete, event\n    }\n\n    export interface AnimationStateListener2 {\n        /** Invoked when this entry has been set as the current entry. */\n        start? (entry: TrackEntry): void;\n\n        /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n         * mixing. */\n        interrupt? (entry: TrackEntry): void;\n\n        /** Invoked when this entry is no longer the current entry and will never be applied again. */\n        end? (entry: TrackEntry): void;\n\n        /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n         * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n        dispose? (entry: TrackEntry): void;\n\n        /** Invoked every time this entry's animation completes a loop. */\n        complete? (entry: TrackEntry): void;\n\n        /** Invoked when this entry's animation triggers an event. */\n        event? (entry: TrackEntry, event: Event): void;\n    }\n\n    export abstract class AnimationStateAdapter2 implements AnimationStateListener2 {\n        start (entry: TrackEntry) {\n        }\n\n        interrupt (entry: TrackEntry) {\n        }\n\n        end (entry: TrackEntry) {\n        }\n\n        dispose (entry: TrackEntry) {\n        }\n\n        complete (entry: TrackEntry) {\n        }\n\n        event (entry: TrackEntry, event: Event) {\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class AnimationStateData {\n        skeletonData: SkeletonData;\n        animationToMixTime: Map<number> = {};\n        defaultMix = 0;\n\n        constructor(skeletonData: SkeletonData) {\n            if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n            this.skeletonData = skeletonData;\n        }\n\n        setMix(fromName: string, toName: string, duration: number) {\n            let from = this.skeletonData.findAnimation(fromName);\n            if (from == null) throw new Error(\"Animation not found: \" + fromName);\n            let to = this.skeletonData.findAnimation(toName);\n            if (to == null) throw new Error(\"Animation not found: \" + toName);\n            this.setMixWith(from, to, duration);\n        }\n\n        private static deprecatedWarning1: boolean = false;\n\n        setMixByName(fromName: string, toName: string, duration: number) {\n            if (!AnimationStateData.deprecatedWarning1) {\n                AnimationStateData.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n            }\n            this.setMix(fromName, toName, duration);\n        }\n\n        setMixWith(from: Animation, to: Animation, duration: number) {\n            if (from == null) throw new Error(\"from cannot be null.\");\n            if (to == null) throw new Error(\"to cannot be null.\");\n            let key = from.name + to.name;\n            this.animationToMixTime[key] = duration;\n        }\n\n        getMix(from: Animation, to: Animation) {\n            let key = from.name + to.name;\n            let value = this.animationToMixTime[key];\n            return value === undefined ? this.defaultMix : value;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class AtlasAttachmentLoader implements AttachmentLoader {\n        atlas: TextureAtlas;\n\n        constructor(atlas: TextureAtlas) {\n            this.atlas = atlas;\n        }\n\n        /** @return May be null to not load an attachment. */\n        newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\n            let region = this.atlas.findRegion(path);\n            if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n            let attachment = new RegionAttachment(name);\n            attachment.region = region;\n            return attachment;\n        }\n\n        /** @return May be null to not load an attachment. */\n        newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\n            let region = this.atlas.findRegion(path);\n            if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n            let attachment = new MeshAttachment(name);\n            attachment.region = region;\n            return attachment;\n        }\n\n        /** @return May be null to not load an attachment. */\n        newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n            return new BoundingBoxAttachment(name);\n        }\n\n        /** @return May be null to not load an attachment */\n        newPathAttachment(skin: Skin, name: string): PathAttachment {\n            return new PathAttachment(name);\n        }\n\n        newPointAttachment(skin: Skin, name: string): PointAttachment {\n            return new PointAttachment(name);\n        }\n\n        newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n            return new ClippingAttachment(name);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export abstract class Attachment {\n        name: string;\n\n        constructor(name: string) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n    }\n\n    export abstract class VertexAttachment extends Attachment {\n        private static nextID = 0;\n\n        id = (VertexAttachment.nextID++ & 65535) << 11;\n        bones: Array<number>;\n        vertices: ArrayLike<number>;\n        worldVerticesLength = 0;\n\n        constructor(name: string) {\n            super(name);\n        }\n\n        computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n            this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n        }\n\n        /** Transforms local vertices to world coordinates.\n         * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n         * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n         * @param worldVertices The output world vertices. Must have a length >= offset + count.\n         * @param offset The worldVertices index to begin writing values. */\n        computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n            count = offset + (count >> 1) * stride;\n            let skeleton = slot.bone.skeleton;\n            let deformArray = slot.attachmentVertices;\n            let vertices = this.vertices;\n            let bones = this.bones;\n            if (bones == null) {\n                if (deformArray.length > 0) vertices = deformArray;\n                let mat = slot.bone.matrix;\n                let x = mat.tx;\n                let y = mat.ty;\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n                for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                    let vx = vertices[v], vy = vertices[v + 1];\n                    worldVertices[w] = vx * a + vy * b + x;\n                    worldVertices[w + 1] = vx * c + vy * d + y;\n                }\n                return;\n            }\n            let v = 0, skip = 0;\n            for (let i = 0; i < start; i += 2) {\n                let n = bones[v];\n                v += n + 1;\n                skip += n;\n            }\n            let skeletonBones = skeleton.bones;\n            if (deformArray.length == 0) {\n                for (let w = offset, b = skip * 3; w < count; w += stride) {\n                    let wx = 0, wy = 0;\n                    let n = bones[v++];\n                    n += v;\n                    for (; v < n; v++, b += 3) {\n                        let mat = skeletonBones[bones[v]].matrix;\n                        let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\n                        wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                        wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                    }\n                    worldVertices[w] = wx;\n                    worldVertices[w + 1] = wy;\n                }\n            } else {\n                let deform = deformArray;\n                for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                    let wx = 0, wy = 0;\n                    let n = bones[v++];\n                    n += v;\n                    for (; v < n; v++, b += 3, f += 2) {\n                        let mat = skeletonBones[bones[v]].matrix;\n                        let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1],\n                            weight = vertices[b + 2];\n                        wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                        wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                    }\n                    worldVertices[w] = wx;\n                    worldVertices[w + 1] = wy;\n                }\n            }\n        }\n\n        /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\n        applyDeform(sourceAttachment: VertexAttachment) {\n            return this == sourceAttachment;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface AttachmentLoader {\n        /** @return May be null to not load an attachment. */\n        newRegionAttachment (skin: Skin, name: string, path: string): RegionAttachment;\n\n        /** @return May be null to not load an attachment. */\n        newMeshAttachment (skin: Skin, name: string, path: string): MeshAttachment;\n\n        /** @return May be null to not load an attachment. */\n        newBoundingBoxAttachment (skin: Skin, name: string): BoundingBoxAttachment;\n\n        /** @return May be null to not load an attachment */\n        newPathAttachment(skin: Skin, name: string): PathAttachment;\n\n        /** @return May be null to not load an attachment */\n        newPointAttachment(skin: Skin, name: string): PointAttachment;\n\n        /** @return May be null to not load an attachment */\n        newClippingAttachment(skin: Skin, name: string): ClippingAttachment;\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export enum AttachmentType {\n        Region, BoundingBox, Mesh, LinkedMesh, Path, Point\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class BoundingBoxAttachment extends VertexAttachment {\n        color = new Color(1, 1, 1, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class ClippingAttachment extends VertexAttachment {\n        endSlot: SlotData;\n\n        // Nonessential.\n        color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n        constructor(name: string) {\n            super(name);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class MeshAttachment extends VertexAttachment {\n        region: TextureRegion;\n        path: string;\n        regionUVs: ArrayLike<number>; uvs: ArrayLike<number>;\n        triangles: Array<number>;\n        color = new Color(1, 1, 1, 1);\n        hullLength: number;\n        private parentMesh: MeshAttachment;\n        inheritDeform = false;\n        tempColor = new Color(0, 0, 0, 0);\n\n        constructor (name: string) {\n            super(name);\n        }\n\n        updateUVs(region: TextureRegion, uvs: ArrayLike<number>): ArrayLike<number> {\n            let regionUVs = this.regionUVs;\n            let n = regionUVs.length;\n            if (!uvs || uvs.length != n) {\n                uvs = Utils.newFloatArray(n);\n            }\n\n            if (region == null) {\n                return;\n            }\n\n            let texture = region.texture;\n            let r = (texture as any)._uvs;\n            let w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n            let x = region.offsetX, y = region.pixiOffsetY;\n\n            for (let i = 0; i < n; i += 2) {\n                let u = this.regionUVs[i], v = this.regionUVs[i + 1];\n                u = (u * w2 - x) / w1;\n                v = (v * h2 - y) / h1;\n                uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n                uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n            }\n\n            return uvs;\n        }\n\n        applyDeform (sourceAttachment: VertexAttachment): boolean {\n            return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\n        }\n\n        getParentMesh () {\n            return this.parentMesh;\n        }\n\n        /** @param parentMesh May be null. */\n        setParentMesh (parentMesh: MeshAttachment) {\n            this.parentMesh = parentMesh;\n            if (parentMesh != null) {\n                this.bones = parentMesh.bones;\n                this.vertices = parentMesh.vertices;\n                this.worldVerticesLength = parentMesh.worldVerticesLength;\n                this.regionUVs = parentMesh.regionUVs;\n                this.triangles = parentMesh.triangles;\n                this.hullLength = parentMesh.hullLength;\n                this.worldVerticesLength = parentMesh.worldVerticesLength\n            }\n        }\n\n        //computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class PathAttachment extends VertexAttachment {\n        lengths: Array<number>;\n        closed = false;\n        constantSpeed = false;\n        color = new Color(1, 1, 1, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class PointAttachment extends VertexAttachment {\n        x: number;\n        y: number;\n        rotation: number;\n        color = new Color(0.38, 0.94, 0, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n\n        computeWorldPosition(bone: Bone, point: Vector2) {\n            const mat = bone.matrix;\n            point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n            point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n            return point;\n        }\n\n        computeWorldRotation(bone: Bone) {\n            const mat = bone.matrix;\n            let cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\n            let x = cos * mat.a + sin * mat.c;\n            let y = cos * mat.b + sin * mat.d;\n            return Math.atan2(y, x) * MathUtils.radDeg;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class RegionAttachment extends Attachment {\n        static OX1 = 0;\n        static OY1 = 1;\n        static OX2 = 2;\n        static OY2 = 3;\n        static OX3 = 4;\n        static OY3 = 5;\n        static OX4 = 6;\n        static OY4 = 7;\n\n        static X1 = 0;\n        static Y1 = 1;\n        static C1R = 2;\n        static C1G = 3;\n        static C1B = 4;\n        static C1A = 5;\n        static U1 = 6;\n        static V1 = 7;\n\n        static X2 = 8;\n        static Y2 = 9;\n        static C2R = 10;\n        static C2G = 11;\n        static C2B = 12;\n        static C2A = 13;\n        static U2 = 14;\n        static V2 = 15;\n\n        static X3 = 16;\n        static Y3 = 17;\n        static C3R = 18;\n        static C3G = 19;\n        static C3B = 20;\n        static C3A = 21;\n        static U3 = 22;\n        static V3 = 23;\n\n        static X4 = 24;\n        static Y4 = 25;\n        static C4R = 26;\n        static C4G = 27;\n        static C4B = 28;\n        static C4A = 29;\n        static U4 = 30;\n        static V4 = 31;\n\n        x = 0;\n        y = 0;\n        scaleX = 1;\n        scaleY = 1;\n        rotation = 0;\n        width = 0;\n        height = 0;\n        color = new Color(1, 1, 1, 1);\n\n        path: string;\n        rendererObject: any;\n        region: TextureRegion;\n\n        offset = Utils.newFloatArray(8);\n        uvs = Utils.newFloatArray(8);\n\n        tempColor = new Color(1, 1, 1, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n\n        updateOffset(): void {\n            let regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n            let regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n            let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n            let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n            let localX2 = localX + this.region.width * regionScaleX;\n            let localY2 = localY + this.region.height * regionScaleY;\n            let radians = this.rotation * Math.PI / 180;\n            let cos = Math.cos(radians);\n            let sin = Math.sin(radians);\n            let localXCos = localX * cos + this.x;\n            let localXSin = localX * sin;\n            let localYCos = localY * cos + this.y;\n            let localYSin = localY * sin;\n            let localX2Cos = localX2 * cos + this.x;\n            let localX2Sin = localX2 * sin;\n            let localY2Cos = localY2 * cos + this.y;\n            let localY2Sin = localY2 * sin;\n            let offset = this.offset;\n            offset[RegionAttachment.OX1] = localXCos - localYSin;\n            offset[RegionAttachment.OY1] = localYCos + localXSin;\n            offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n            offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n            offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n            offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n            offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n            offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n        }\n\n        setRegion(region: TextureRegion): void {\n            this.region = region;\n            let uvs = this.uvs;\n            if (region.rotate) {\n                uvs[2] = region.u;\n                uvs[3] = region.v2;\n                uvs[4] = region.u;\n                uvs[5] = region.v;\n                uvs[6] = region.u2;\n                uvs[7] = region.v;\n                uvs[0] = region.u2;\n                uvs[1] = region.v2;\n            } else {\n                uvs[0] = region.u;\n                uvs[1] = region.v2;\n                uvs[2] = region.u;\n                uvs[3] = region.v;\n                uvs[4] = region.u2;\n                uvs[5] = region.v;\n                uvs[6] = region.u2;\n                uvs[7] = region.v2;\n            }\n        }\n\n        computeWorldVertices(bone: Bone, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n            let vertexOffset = this.offset;\n            let mat = bone.matrix;\n            let x = mat.tx, y = mat.ty;\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n            let offsetX = 0, offsetY = 0;\n\n            offsetX = vertexOffset[RegionAttachment.OX1];\n            offsetY = vertexOffset[RegionAttachment.OY1];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX2];\n            offsetY = vertexOffset[RegionAttachment.OY2];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX3];\n            offsetY = vertexOffset[RegionAttachment.OY3];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX4];\n            offsetY = vertexOffset[RegionAttachment.OY4];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export enum BlendMode {\n        Normal = 0,\n        Additive = 1,\n        Multiply = 2,\n        Screen = 3\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Bone implements Updatable {\n        static yDown: boolean = false;\n        //be careful! Spine b,c is c,b in pixi matrix\n        matrix = new PIXI.Matrix();\n\n        get worldX(): number {\n            return this.matrix.tx;\n        }\n\n        get worldY(): number {\n            return this.matrix.ty;\n        }\n\n        data: BoneData;\n        skeleton: Skeleton;\n        parent: Bone;\n        children = new Array<Bone>();\n        x = 0;\n        y = 0;\n        rotation = 0;\n        scaleX = 0;\n        scaleY = 0;\n        shearX = 0;\n        shearY = 0;\n        ax = 0;\n        ay = 0;\n        arotation = 0;\n        ascaleX = 0;\n        ascaleY = 0;\n        ashearX = 0;\n        ashearY = 0;\n        appliedValid = false;\n\n        sorted = false;\n\n        /** @param parent May be null. */\n        constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.skeleton = skeleton;\n            this.parent = parent;\n            this.setToSetupPose();\n        }\n\n        /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n        update() {\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n        }\n\n        /** Computes the world transform using the parent bone and this bone's local transform. */\n        updateWorldTransform() {\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n        }\n\n        /** Computes the world transform using the parent bone and the specified local transform. */\n        updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n            this.ax = x;\n            this.ay = y;\n            this.arotation = rotation;\n            this.ascaleX = scaleX;\n            this.ascaleY = scaleY;\n            this.ashearX = shearX;\n            this.ashearY = shearY;\n            this.appliedValid = true;\n\n            let parent = this.parent;\n            let m = this.matrix;\n            if (parent == null) { // Root bone.\n                let rotationY = rotation + 90 + shearY;\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\n                let skeleton = this.skeleton;\n                if (skeleton.flipX) {\n                    x = -x;\n                    la = -la;\n                    lb = -lb;\n                }\n                if (skeleton.flipY !== Bone.yDown) {\n                    y = -y;\n                    lc = -lc;\n                    ld = -ld;\n                }\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n                m.tx = x + skeleton.x;\n                m.ty = y + skeleton.y;\n                return;\n            }\n\n            let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n            m.tx = pa * x + pb * y + parent.matrix.tx;\n            m.ty = pc * x + pd * y + parent.matrix.ty;\n            switch (this.data.transformMode) {\n                case TransformMode.Normal: {\n                    let rotationY = rotation + 90 + shearY;\n                    let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    let lb = MathUtils.cosDeg(rotationY) * scaleY;\n                    let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    let ld = MathUtils.sinDeg(rotationY) * scaleY;\n                    m.a = pa * la + pb * lc;\n                    m.c = pa * lb + pb * ld;\n                    m.b = pc * la + pd * lc;\n                    m.d = pc * lb + pd * ld;\n                    return;\n                }\n                case TransformMode.OnlyTranslation: {\n                    let rotationY = rotation + 90 + shearY;\n                    m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                    m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                    break;\n                }\n                case TransformMode.NoRotationOrReflection: {\n                    let s = pa * pa + pc * pc;\n                    let prx = 0;\n                    if (s > 0.0001) {\n                        s = Math.abs(pa * pd - pb * pc) / s;\n                        pb = pc * s;\n                        pd = pa * s;\n                        prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                    } else {\n                        pa = 0;\n                        pc = 0;\n                        prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                    }\n                    let rx = rotation + shearX - prx;\n                    let ry = rotation + shearY - prx + 90;\n                    let la = MathUtils.cosDeg(rx) * scaleX;\n                    let lb = MathUtils.cosDeg(ry) * scaleY;\n                    let lc = MathUtils.sinDeg(rx) * scaleX;\n                    let ld = MathUtils.sinDeg(ry) * scaleY;\n                    m.a = pa * la - pb * lc;\n                    m.c = pa * lb - pb * ld;\n                    m.b = pc * la + pd * lc;\n                    m.d = pc * lb + pd * ld;\n                    break;\n                }\n                case TransformMode.NoScale:\n                case TransformMode.NoScaleOrReflection: {\n                    let cos = MathUtils.cosDeg(rotation);\n                    let sin = MathUtils.sinDeg(rotation);\n                    let za = pa * cos + pb * sin;\n                    let zc = pc * cos + pd * sin;\n                    let s = Math.sqrt(za * za + zc * zc);\n                    if (s > 0.00001) s = 1 / s;\n                    za *= s;\n                    zc *= s;\n                    s = Math.sqrt(za * za + zc * zc);\n                    let r = Math.PI / 2 + Math.atan2(zc, za);\n                    let zb = Math.cos(r) * s;\n                    let zd = Math.sin(r) * s;\n                    let la = MathUtils.cosDeg(shearX) * scaleX;\n                    let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                    let lc = MathUtils.sinDeg(shearX) * scaleX;\n                    let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n                    m.a = za * la + zb * lc;\n                    m.c = za * lb + zb * ld;\n                    m.b = zc * la + zd * lc;\n                    m.d = zc * lb + zd * ld;\n                    if (this.data.transformMode != TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : ((this.skeleton.flipX != this.skeleton.flipY) != Bone.yDown)) {\n                        m.c = -m.c;\n                        m.d = -m.d;\n                    }\n                    return;\n                }\n            }\n            if (this.skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (this.skeleton.flipY != Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n\n        setToSetupPose() {\n            let data = this.data;\n            this.x = data.x;\n            this.y = data.y;\n            this.rotation = data.rotation;\n            this.scaleX = data.scaleX;\n            this.scaleY = data.scaleY;\n            this.shearX = data.shearX;\n            this.shearY = data.shearY;\n        }\n\n        getWorldRotationX() {\n            return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n        }\n\n        getWorldRotationY() {\n            return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n        }\n\n        getWorldScaleX() {\n            let m = this.matrix;\n            return Math.sqrt(m.a * m.a + m.c * m.c);\n        }\n\n        getWorldScaleY() {\n            let m = this.matrix;\n            return Math.sqrt(m.b * m.b + m.d * m.d);\n        }\n\n        /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n         * the applied transform after the world transform has been modified directly (eg, by a constraint).\n         * <p>\n         * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n        updateAppliedTransform() {\n            this.appliedValid = true;\n            let parent = this.parent;\n            let m = this.matrix;\n            if (parent == null) {\n                this.ax = m.tx;\n                this.ay = m.ty;\n                this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n                this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n                this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n                this.ashearX = 0;\n                this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n                return;\n            }\n            let pm = parent.matrix;\n            let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n            let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\n            this.ax = (dx * pm.d * pid - dy * pm.c * pid);\n            this.ay = (dy * pm.a * pid - dx * pm.b * pid);\n            let ia = pid * pm.d;\n            let id = pid * pm.a;\n            let ib = pid * pm.c;\n            let ic = pid * pm.b;\n            let ra = ia * m.a - ib * m.b;\n            let rb = ia * m.c - ib * m.d;\n            let rc = id * m.b - ic * m.a;\n            let rd = id * m.d - ic * m.c;\n            this.ashearX = 0;\n            this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n            if (this.ascaleX > 0.0001) {\n                let det = ra * rd - rb * rc;\n                this.ascaleY = det / this.ascaleX;\n                this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n                this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n            } else {\n                this.ascaleX = 0;\n                this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n                this.ashearY = 0;\n                this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n            }\n        }\n\n        worldToLocal(world: Vector2) {\n            let m = this.matrix;\n            let a = m.a, b = m.c, c = m.b, d = m.d;\n            let invDet = 1 / (a * d - b * c);\n            let x = world.x - m.tx, y = world.y - m.ty;\n            world.x = (x * d * invDet - y * b * invDet);\n            world.y = (y * a * invDet - x * c * invDet);\n            return world;\n        }\n\n        localToWorld(local: Vector2) {\n            let m = this.matrix;\n            let x = local.x, y = local.y;\n            local.x = x * m.a + y * m.c + m.tx;\n            local.y = x * m.b + y * m.d + m.ty;\n            return local;\n        }\n\n        worldToLocalRotation (worldRotation: number) {\n            let sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\n            let mat = this.matrix;\n            return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n        }\n\n        localToWorldRotation (localRotation: number) {\n            let sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\n            let mat = this.matrix;\n            return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n        }\n\n        rotateWorld (degrees: number) {\n            let mat = this.matrix;\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n            let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\n            mat.a = cos * a - sin * c;\n            mat.c = cos * b - sin * d;\n            mat.b = sin * a + cos * c;\n            mat.d = sin * b + cos * d;\n            this.appliedValid = false;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class BoneData {\n        index: number;\n        name: string;\n        parent: BoneData;\n        length: number;\n        x = 0;\n        y = 0;\n        rotation = 0;\n        scaleX = 1;\n        scaleY = 1;\n        shearX = 0;\n        shearY = 0;\n        transformMode = TransformMode.Normal;\n\n        constructor(index: number, name: string, parent: BoneData) {\n            if (index < 0) throw new Error(\"index must be >= 0.\");\n            if (name == null) throw new Error(\"name cannot be null.\");\n            this.index = index;\n            this.name = name;\n            this.parent = parent;\n        }\n    }\n\n    export enum TransformMode {\n        Normal, OnlyTranslation, NoRotationOrReflection, NoScale, NoScaleOrReflection\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface Constraint extends Updatable {\n        getOrder(): number;\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Event {\n        data: EventData;\n        intValue: number;\n        floatValue: number;\n        stringValue: string;\n        time: number;\n\n        constructor(time: number, data: EventData) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            this.time = time;\n            this.data = data;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class EventData {\n        name: string;\n        intValue: number;\n        floatValue: number;\n        stringValue: string;\n\n        constructor (name: string) {\n            this.name = name;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class IkConstraint implements Constraint {\n        data: IkConstraintData;\n        bones: Array<Bone>;\n        target: Bone;\n        mix = 1;\n        bendDirection = 0;\n\n        constructor (data: IkConstraintData, skeleton: Skeleton) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.mix = data.mix;\n            this.bendDirection = data.bendDirection;\n\n            this.bones = new Array<Bone>();\n            for (let i = 0; i < data.bones.length; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findBone(data.target.name);\n        }\n\n        getOrder () {\n            return this.data.order;\n        }\n\n        apply () {\n            this.update();\n        }\n\n        update () {\n            let target = this.target;\n            let bones = this.bones;\n            switch (bones.length) {\n                case 1:\n                    this.apply1(bones[0], target.worldX, target.worldY, this.mix);\n                    break;\n                case 2:\n                    this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n                    break;\n            }\n        }\n\n        /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n         * coordinate system. */\n        apply1 (bone: Bone, targetX: number, targetY: number, alpha: number) {\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n            let p = bone.parent.matrix;\n            let id = 1 / (p.a * p.d - p.b * p.c);\n            let x = targetX - p.tx, y = targetY - p.ty;\n            let tx = (x * p.d - y * p.c) * id - bone.ax, ty = (y * p.a - x * p.b) * id - bone.ay;\n            let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;\n            if (bone.ascaleX < 0) rotationIK += 180;\n            if (rotationIK > 180)\n                rotationIK -= 360;\n            else if (rotationIK < -180) rotationIK += 360;\n            bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX,\n                bone.ashearY);\n        }\n\n        /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n         * target is specified in the world coordinate system.\n         * @param child A direct descendant of the parent bone. */\n        apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, alpha: number) {\n            if (alpha == 0) {\n                child.updateWorldTransform();\n                return;\n            }\n            if (!parent.appliedValid) parent.updateAppliedTransform();\n            if (!child.appliedValid) child.updateAppliedTransform();\n            let px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;\n            let pmat = parent.matrix;\n            let os1 = 0, os2 = 0, s2 = 0;\n            if (psx < 0) {\n                psx = -psx;\n                os1 = 180;\n                s2 = -1;\n            } else {\n                os1 = 0;\n                s2 = 1;\n            }\n            if (psy < 0) {\n                psy = -psy;\n                s2 = -s2;\n            }\n            if (csx < 0) {\n                csx = -csx;\n                os2 = 180;\n            } else\n                os2 = 0;\n            let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\n            let u = Math.abs(psx - psy) <= 0.0001;\n            if (!u) {\n                cy = 0;\n                cwx = a * cx + pmat.tx;\n                cwy = c * cx + pmat.ty;\n            } else {\n                cy = child.ay;\n                cwx = a * cx + b * cy + pmat.tx;\n                cwy = c * cx + d * cy + pmat.ty;\n            }\n            let pp = parent.parent.matrix;\n            a = pp.a;\n            b = pp.c;\n            c = pp.b;\n            d = pp.d;\n            let id = 1 / (a * d - b * c), x = targetX - pp.tx, y = targetY - pp.ty;\n            let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\n            x = cwx - pp.tx;\n            y = cwy - pp.ty;\n            let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n            let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\n            outer:\n                if (u) {\n                    l2 *= psx;\n                    let cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n                    if (cos < -1)\n                        cos = -1;\n                    else if (cos > 1) cos = 1;\n                    a2 = Math.acos(cos) * bendDir;\n                    a = l1 + l2 * cos;\n                    b = l2 * Math.sin(a2);\n                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n                } else {\n                    a = psx * l2;\n                    b = psy * l2;\n                    let aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\n                    c = bb * l1 * l1 + aa * dd - aa * bb;\n                    let c1 = -2 * bb * l1, c2 = bb - aa;\n                    d = c1 * c1 - 4 * c2 * c;\n                    if (d >= 0) {\n                        let q = Math.sqrt(d);\n                        if (c1 < 0) q = -q;\n                        q = -(c1 + q) / 2;\n                        let r0 = q / c2, r1 = c / q;\n                        let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                        if (r * r <= dd) {\n                            y = Math.sqrt(dd - r * r) * bendDir;\n                            a1 = ta - Math.atan2(y, r);\n                            a2 = Math.atan2(y / psy, (r - l1) / psx);\n                            break outer;\n                        }\n                    }\n                    let minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\n                    let maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\n                    c = -a * l1 / (aa - bb);\n                    if (c >= -1 && c <= 1) {\n                        c = Math.acos(c);\n                        x = a * Math.cos(c) + l1;\n                        y = b * Math.sin(c);\n                        d = x * x + y * y;\n                        if (d < minDist) {\n                            minAngle = c;\n                            minDist = d;\n                            minX = x;\n                            minY = y;\n                        }\n                        if (d > maxDist) {\n                            maxAngle = c;\n                            maxDist = d;\n                            maxX = x;\n                            maxY = y;\n                        }\n                    }\n                    if (dd <= (minDist + maxDist) / 2) {\n                        a1 = ta - Math.atan2(minY * bendDir, minX);\n                        a2 = minAngle * bendDir;\n                    } else {\n                        a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                        a2 = maxAngle * bendDir;\n                    }\n                }\n            let os = Math.atan2(cy, cx) * s2;\n            let rotation = parent.arotation;\n            a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n            if (a1 > 180)\n                a1 -= 360;\n            else if (a1 < -180) a1 += 360;\n            parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);\n            rotation = child.arotation;\n            a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n            if (a2 > 180)\n                a2 -= 360;\n            else if (a2 < -180) a2 += 360;\n            child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class IkConstraintData {\n        name: string;\n        order = 0;\n        bones = new Array<BoneData>();\n        target: BoneData;\n        bendDirection = 1;\n        mix = 1;\n\n        constructor(name: string) {\n            this.name = name;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class PathConstraint implements Constraint {\n        static NONE = -1; static BEFORE = -2; static AFTER = -3;\n\n        data: PathConstraintData;\n        bones: Array<Bone>;\n        target: Slot;\n        position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\n\n        spaces = new Array<number>(); positions = new Array<number>();\n        world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\n        segments = new Array<number>();\n\n        constructor (data: PathConstraintData, skeleton: Skeleton) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.bones = new Array<Bone>();\n            for (let i = 0, n = data.bones.length; i < n; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findSlot(data.target.name);\n            this.position = data.position;\n            this.spacing = data.spacing;\n            this.rotateMix = data.rotateMix;\n            this.translateMix = data.translateMix;\n        }\n\n        apply () {\n            this.update();\n        }\n\n        update () {\n            let attachment = this.target.getAttachment();\n            if (!(attachment instanceof PathAttachment)) return;\n\n            let rotateMix = this.rotateMix, translateMix = this.translateMix;\n            let translate = translateMix > 0, rotate = rotateMix > 0;\n            if (!translate && !rotate) return;\n\n            let data = this.data;\n            let spacingMode = data.spacingMode;\n            let lengthSpacing = spacingMode == SpacingMode.Length;\n            let rotateMode = data.rotateMode;\n            let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\n            let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\n            let bones = this.bones;\n            let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\n            let spacing = this.spacing;\n            if (scale || lengthSpacing) {\n                if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n                for (let i = 0, n = spacesCount - 1; i < n;) {\n                    let bone = bones[i];\n                    let setupLength = bone.data.length, x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\n                    let length = Math.sqrt(x * x + y * y);\n                    if (scale) lengths[i] = length;\n                    spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n                }\n            } else {\n                for (let i = 1; i < spacesCount; i++)\n                    spaces[i] = spacing;\n            }\n\n            let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\n                data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\n            let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\n            let tip = false;\n            if (offsetRotation == 0)\n                tip = rotateMode == RotateMode.Chain;\n            else {\n                tip = false;\n                let p = this.target.bone.matrix;\n                offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n            }\n            for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n                let bone = bones[i];\n                let mat = bone.matrix;\n                mat.tx += (boneX - mat.tx) * translateMix;\n                mat.ty += (boneY - mat.ty) * translateMix;\n                let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\n                if (scale) {\n                    let length = lengths[i];\n                    if (length != 0) {\n                        let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n                        mat.a *= s;\n                        mat.b *= s;\n                    }\n                }\n                boneX = x;\n                boneY = y;\n                if (rotate) {\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\n                    if (tangents)\n                        r = positions[p - 1];\n                    else if (spaces[i + 1] == 0)\n                        r = positions[p + 2];\n                    else\n                        r = Math.atan2(dy, dx);\n                    r -= Math.atan2(c, a);\n                    if (tip) {\n                        cos = Math.cos(r);\n                        sin = Math.sin(r);\n                        let length = bone.data.length;\n                        boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                        boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                    } else {\n                        r += offsetRotation;\n                    }\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI) //\n                        r += MathUtils.PI2;\n                    r *= rotateMix;\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    mat.a = cos * a - sin * c;\n                    mat.c = cos * b - sin * d;\n                    mat.b = sin * a + cos * c;\n                    mat.d = sin * b + cos * d;\n                }\n                bone.appliedValid = false;\n            }\n        }\n\n        computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\n                               percentSpacing: boolean) {\n            let target = this.target;\n            let position = this.position;\n            let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\n            let closed = path.closed;\n            let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\n\n            if (!path.constantSpeed) {\n                let lengths = path.lengths;\n                curveCount -= closed ? 1 : 2;\n                let pathLength = lengths[curveCount];\n                if (percentPosition) position *= pathLength;\n                if (percentSpacing) {\n                    for (let i = 0; i < spacesCount; i++)\n                        spaces[i] *= pathLength;\n                }\n                world = Utils.setArraySize(this.world, 8);\n                for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                    let space = spaces[i];\n                    position += space;\n                    let p = position;\n\n                    if (closed) {\n                        p %= pathLength;\n                        if (p < 0) p += pathLength;\n                        curve = 0;\n                    } else if (p < 0) {\n                        if (prevCurve != PathConstraint.BEFORE) {\n                            prevCurve = PathConstraint.BEFORE;\n                            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                        }\n                        this.addBeforePosition(p, world, 0, out, o);\n                        continue;\n                    } else if (p > pathLength) {\n                        if (prevCurve != PathConstraint.AFTER) {\n                            prevCurve = PathConstraint.AFTER;\n                            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                        }\n                        this.addAfterPosition(p - pathLength, world, 0, out, o);\n                        continue;\n                    }\n\n                    // Determine curve containing position.\n                    for (;; curve++) {\n                        let length = lengths[curve];\n                        if (p > length) continue;\n                        if (curve == 0)\n                            p /= length;\n                        else {\n                            let prev = lengths[curve - 1];\n                            p = (p - prev) / (length - prev);\n                        }\n                        break;\n                    }\n                    if (curve != prevCurve) {\n                        prevCurve = curve;\n                        if (closed && curve == curveCount) {\n                            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                        } else\n                            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                    }\n                    this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\n                        tangents || (i > 0 && space == 0));\n                }\n                return out;\n            }\n\n            // World vertices.\n            if (closed) {\n                verticesLength += 2;\n                world = Utils.setArraySize(this.world, verticesLength);\n                path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n                path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n                world[verticesLength - 2] = world[0];\n                world[verticesLength - 1] = world[1];\n            } else {\n                curveCount--;\n                verticesLength -= 4;\n                world = Utils.setArraySize(this.world, verticesLength);\n                path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n            }\n\n            // Curve lengths.\n            let curves = Utils.setArraySize(this.curves, curveCount);\n            let pathLength = 0;\n            let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\n            let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\n            for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n                cx1 = world[w];\n                cy1 = world[w + 1];\n                cx2 = world[w + 2];\n                cy2 = world[w + 3];\n                x2 = world[w + 4];\n                y2 = world[w + 5];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx;\n                dfy += ddfy;\n                ddfx += dddfx;\n                ddfy += dddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx;\n                dfy += ddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                curves[i] = pathLength;\n                x1 = x2;\n                y1 = y2;\n            }\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++)\n                    spaces[i] *= pathLength;\n            }\n\n            let segments = this.segments;\n            let curveLength = 0;\n            for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n                let space = spaces[i];\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (;; curve++) {\n                    let length = curves[curve];\n                    if (p > length) continue;\n                    if (curve == 0)\n                        p /= length;\n                    else {\n                        let prev = curves[curve - 1];\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n\n                // Curve segment lengths.\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    let ii = curve * 6;\n                    x1 = world[ii];\n                    y1 = world[ii + 1];\n                    cx1 = world[ii + 2];\n                    cy1 = world[ii + 3];\n                    cx2 = world[ii + 4];\n                    cy2 = world[ii + 5];\n                    x2 = world[ii + 6];\n                    y2 = world[ii + 7];\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                    ddfx = tmpx * 2 + dddfx;\n                    ddfy = tmpy * 2 + dddfy;\n                    dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                    dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                    curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[0] = curveLength;\n                    for (ii = 1; ii < 8; ii++) {\n                        dfx += ddfx;\n                        dfy += ddfy;\n                        ddfx += dddfx;\n                        ddfy += dddfy;\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[ii] = curveLength;\n                    }\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[8] = curveLength;\n                    dfx += ddfx + dddfx;\n                    dfy += ddfy + dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[9] = curveLength;\n                    segment = 0;\n                }\n\n                // Weight by segment length.\n                p *= curveLength;\n                for (;; segment++) {\n                    let length = segments[segment];\n                    if (p > length) continue;\n                    if (segment == 0)\n                        p /= length;\n                    else {\n                        let prev = segments[segment - 1];\n                        p = segment + (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n            }\n            return out;\n        }\n\n        addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n            let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\n            out[o] = x1 + p * Math.cos(r);\n            out[o + 1] = y1 + p * Math.sin(r);\n            out[o + 2] = r;\n        }\n\n        addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n            let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\n            out[o] = x1 + p * Math.cos(r);\n            out[o + 1] = y1 + p * Math.sin(r);\n            out[o + 2] = r;\n        }\n\n        addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\n                          out: Array<number>, o: number, tangents: boolean) {\n            if (p == 0 || isNaN(p)) p = 0.0001;\n            let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\n            let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\n            let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n            out[o] = x;\n            out[o + 1] = y;\n            if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n        }\n\n        getOrder () {\n            return this.data.order;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class PathConstraintData {\n        name: string;\n        order = 0;\n        bones = new Array<BoneData>();\n        target: SlotData;\n        positionMode: PositionMode;\n        spacingMode: SpacingMode;\n        rotateMode: RotateMode;\n        offsetRotation: number;\n        position: number;\n        spacing: number;\n        rotateMix: number;\n        translateMix: number;\n\n        constructor(name: string) {\n            this.name = name;\n        }\n    }\n\n    export enum PositionMode {\n        Fixed, Percent\n    }\n\n    export enum SpacingMode {\n        Length, Fixed, Percent\n    }\n\n    export enum RotateMode {\n        Tangent, Chain, ChainScale\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Skeleton {\n        data: SkeletonData;\n        bones: Array<Bone>;\n        slots: Array<Slot>;\n        drawOrder: Array<Slot>;\n        ikConstraints: Array<IkConstraint>;\n        transformConstraints: Array<TransformConstraint>;\n        pathConstraints: Array<PathConstraint>;\n        _updateCache = new Array<Updatable>();\n        updateCacheReset = new Array<Updatable>();\n        skin: Skin;\n        color: Color;\n        time = 0;\n        flipX = false; flipY = false;\n        x = 0; y = 0;\n\n        constructor (data: SkeletonData) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            this.data = data;\n\n            this.bones = new Array<Bone>();\n            for (let i = 0; i < data.bones.length; i++) {\n                let boneData = data.bones[i];\n                let bone: Bone;\n                if (boneData.parent == null)\n                    bone = new Bone(boneData, this, null);\n                else {\n                    let parent = this.bones[boneData.parent.index];\n                    bone = new Bone(boneData, this, parent);\n                    parent.children.push(bone);\n                }\n                this.bones.push(bone);\n            }\n\n            this.slots = new Array<Slot>();\n            this.drawOrder = new Array<Slot>();\n            for (let i = 0; i < data.slots.length; i++) {\n                let slotData = data.slots[i];\n                let bone = this.bones[slotData.boneData.index];\n                let slot = new Slot(slotData, bone);\n                this.slots.push(slot);\n                this.drawOrder.push(slot);\n            }\n\n            this.ikConstraints = new Array<IkConstraint>();\n            for (let i = 0; i < data.ikConstraints.length; i++) {\n                let ikConstraintData = data.ikConstraints[i];\n                this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n            }\n\n            this.transformConstraints = new Array<TransformConstraint>();\n            for (let i = 0; i < data.transformConstraints.length; i++) {\n                let transformConstraintData = data.transformConstraints[i];\n                this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n            }\n\n            this.pathConstraints = new Array<PathConstraint>();\n            for (let i = 0; i < data.pathConstraints.length; i++) {\n                let pathConstraintData = data.pathConstraints[i];\n                this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n            }\n\n            this.color = new Color(1, 1, 1, 1);\n            this.updateCache();\n        }\n\n        updateCache () {\n            let updateCache = this._updateCache;\n            updateCache.length = 0;\n            this.updateCacheReset.length = 0;\n\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++)\n                bones[i].sorted = false;\n\n            // IK first, lowest hierarchy depth first.\n            let ikConstraints = this.ikConstraints;\n            let transformConstraints = this.transformConstraints;\n            let pathConstraints = this.pathConstraints;\n            let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\n            let constraintCount = ikCount + transformCount + pathCount;\n\n            outer:\n                for (let i = 0; i < constraintCount; i++) {\n                    for (let ii = 0; ii < ikCount; ii++) {\n                        let constraint = ikConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortIkConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                    for (let ii = 0; ii < transformCount; ii++) {\n                        let constraint = transformConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortTransformConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                    for (let ii = 0; ii < pathCount; ii++) {\n                        let constraint = pathConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortPathConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                }\n\n            for (let i = 0, n = bones.length; i < n; i++)\n                this.sortBone(bones[i]);\n        }\n\n        sortIkConstraint (constraint: IkConstraint) {\n            let target = constraint.target;\n            this.sortBone(target);\n\n            let constrained = constraint.bones;\n            let parent = constrained[0];\n            this.sortBone(parent);\n\n            if (constrained.length > 1) {\n                let child = constrained[constrained.length - 1];\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n            }\n\n            this._updateCache.push(constraint);\n\n            this.sortReset(parent.children);\n            constrained[constrained.length - 1].sorted = true;\n        }\n\n        sortPathConstraint (constraint: PathConstraint) {\n            let slot = constraint.target;\n            let slotIndex = slot.data.index;\n            let slotBone = slot.bone;\n            if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n            if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n                this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n            for (let i = 0, n = this.data.skins.length; i < n; i++)\n                this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n            let attachment = slot.getAttachment();\n            if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n            let constrained = constraint.bones;\n            let boneCount = constrained.length;\n            for (let i = 0; i < boneCount; i++)\n                this.sortBone(constrained[i]);\n\n            this._updateCache.push(constraint);\n\n            for (let i = 0; i < boneCount; i++)\n                this.sortReset(constrained[i].children);\n            for (let i = 0; i < boneCount; i++)\n                constrained[i].sorted = true;\n        }\n\n        sortTransformConstraint (constraint: TransformConstraint) {\n            this.sortBone(constraint.target);\n\n            let constrained = constraint.bones;\n            let boneCount = constrained.length;\n            if (constraint.data.local) {\n                for (let i = 0; i < boneCount; i++) {\n                    let child = constrained[i];\n                    this.sortBone(child.parent);\n                    if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n                }\n            } else {\n                for (let i = 0; i < boneCount; i++) {\n                    this.sortBone(constrained[i]);\n                }\n            }\n\n            this._updateCache.push(constraint);\n\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortReset(constrained[ii].children);\n            for (let ii = 0; ii < boneCount; ii++)\n                constrained[ii].sorted = true;\n        }\n\n        sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\n            let attachments = skin.attachments[slotIndex];\n            if (!attachments) return;\n            for (let key in attachments) {\n                this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n            }\n        }\n\n        sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\n            if (!(attachment instanceof PathAttachment)) return;\n            let pathBones = (<PathAttachment>attachment).bones;\n            if (pathBones == null)\n                this.sortBone(slotBone);\n            else {\n                let bones = this.bones;\n                let i = 0;\n                while (i < pathBones.length) {\n                    let boneCount = pathBones[i++];\n                    for (let n = i + boneCount; i < n; i++) {\n                        let boneIndex = pathBones[i];\n                        this.sortBone(bones[boneIndex]);\n                    }\n                }\n            }\n        }\n\n        sortBone (bone: Bone) {\n            if (bone.sorted) return;\n            let parent = bone.parent;\n            if (parent != null) this.sortBone(parent);\n            bone.sorted = true;\n            this._updateCache.push(bone);\n        }\n\n        sortReset (bones: Array<Bone>) {\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (bone.sorted) this.sortReset(bone.children);\n                bone.sorted = false;\n            }\n        }\n\n        /** Updates the world transform for each bone and applies constraints. */\n        updateWorldTransform () {\n            let updateCacheReset = this.updateCacheReset;\n            for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n                let bone = updateCacheReset[i] as Bone;\n                bone.ax = bone.x;\n                bone.ay = bone.y;\n                bone.arotation = bone.rotation;\n                bone.ascaleX = bone.scaleX;\n                bone.ascaleY = bone.scaleY;\n                bone.ashearX = bone.shearX;\n                bone.ashearY = bone.shearY;\n                bone.appliedValid = true;\n            }\n            let updateCache = this._updateCache;\n            for (let i = 0, n = updateCache.length; i < n; i++)\n                updateCache[i].update();\n        }\n\n        /** Sets the bones, constraints, and slots to their setup pose values. */\n        setToSetupPose () {\n            this.setBonesToSetupPose();\n            this.setSlotsToSetupPose();\n        }\n\n        /** Sets the bones and constraints to their setup pose values. */\n        setBonesToSetupPose () {\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++)\n                bones[i].setToSetupPose();\n\n            let ikConstraints = this.ikConstraints;\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\n                let constraint = ikConstraints[i];\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.mix = constraint.data.mix;\n            }\n\n            let transformConstraints = this.transformConstraints;\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\n                let constraint = transformConstraints[i];\n                let data = constraint.data;\n                constraint.rotateMix = data.rotateMix;\n                constraint.translateMix = data.translateMix;\n                constraint.scaleMix = data.scaleMix;\n                constraint.shearMix = data.shearMix;\n            }\n\n            let pathConstraints = this.pathConstraints;\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\n                let constraint = pathConstraints[i];\n                let data = constraint.data;\n                constraint.position = data.position;\n                constraint.spacing = data.spacing;\n                constraint.rotateMix = data.rotateMix;\n                constraint.translateMix = data.translateMix;\n            }\n        }\n\n        setSlotsToSetupPose () {\n            let slots = this.slots;\n            Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n            for (let i = 0, n = slots.length; i < n; i++)\n                slots[i].setToSetupPose();\n        }\n\n        /** @return May return null. */\n        getRootBone () {\n            if (this.bones.length == 0) return null;\n            return this.bones[0];\n        }\n\n        /** @return May be null. */\n        findBone (boneName: string) {\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (bone.data.name == boneName) return bone;\n            }\n            return null;\n        }\n\n        /** @return -1 if the bone was not found. */\n        findBoneIndex (boneName: string) {\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++)\n                if (bones[i].data.name == boneName) return i;\n            return -1;\n        }\n\n        /** @return May be null. */\n        findSlot (slotName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++) {\n                let slot = slots[i];\n                if (slot.data.name == slotName) return slot;\n            }\n            return null;\n        }\n\n        /** @return -1 if the bone was not found. */\n        findSlotIndex (slotName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++)\n                if (slots[i].data.name == slotName) return i;\n            return -1;\n        }\n\n        /** Sets a skin by name.\n         * @see #setSkin(Skin) */\n        setSkinByName (skinName: string) {\n            let skin = this.data.findSkin(skinName);\n            if (skin == null) throw new Error(\"Skin not found: \" + skinName);\n            this.setSkin(skin);\n        }\n\n        /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n         * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n         * old skin, each slot's setup mode attachment is attached from the new skin.\n         * @param newSkin May be null. */\n        setSkin (newSkin: Skin) {\n            if (newSkin != null) {\n                if (this.skin != null)\n                    newSkin.attachAll(this, this.skin);\n                else {\n                    let slots = this.slots;\n                    for (let i = 0, n = slots.length; i < n; i++) {\n                        let slot = slots[i];\n                        let name = slot.data.attachmentName;\n                        if (name != null) {\n                            let attachment: Attachment = newSkin.getAttachment(i, name);\n                            if (attachment != null) slot.setAttachment(attachment);\n                        }\n                    }\n                }\n            }\n            this.skin = newSkin;\n        }\n\n        /** @return May be null. */\n        getAttachmentByName (slotName: string, attachmentName: string): Attachment {\n            return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n        }\n\n        /** @return May be null. */\n        getAttachment (slotIndex: number, attachmentName: string): Attachment {\n            if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\n            if (this.skin != null) {\n                let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n                if (attachment != null) return attachment;\n            }\n            if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n            return null;\n        }\n\n        /** @param attachmentName May be null. */\n        setAttachment (slotName: string, attachmentName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++) {\n                let slot = slots[i];\n                if (slot.data.name == slotName) {\n                    let attachment: Attachment = null;\n                    if (attachmentName != null) {\n                        attachment = this.getAttachment(i, attachmentName);\n                        if (attachment == null)\n                            throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                    }\n                    slot.setAttachment(attachment);\n                    return;\n                }\n            }\n            throw new Error(\"Slot not found: \" + slotName);\n        }\n\n        /** @return May be null. */\n        findIkConstraint (constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let ikConstraints = this.ikConstraints;\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\n                let ikConstraint = ikConstraints[i];\n                if (ikConstraint.data.name == constraintName) return ikConstraint;\n            }\n            return null;\n        }\n\n        /** @return May be null. */\n        findTransformConstraint (constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let transformConstraints = this.transformConstraints;\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\n                let constraint = transformConstraints[i];\n                if (constraint.data.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        /** @return May be null. */\n        findPathConstraint (constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let pathConstraints = this.pathConstraints;\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\n                let constraint = pathConstraints[i];\n                if (constraint.data.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n         * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n         * @param size The width and height of the AABB.\n         * @param temp Working memory */\n        getBounds (offset: Vector2, size: Vector2, temp: Array<number>) {\n            if (offset == null) throw new Error(\"offset cannot be null.\");\n            if (size == null) throw new Error(\"size cannot be null.\");\n            let drawOrder = this.drawOrder;\n            let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n            for (let i = 0, n = drawOrder.length; i < n; i++) {\n                let slot = drawOrder[i];\n                let verticesLength = 0;\n                let vertices: ArrayLike<number> = null;\n                let attachment = slot.getAttachment();\n                if (attachment instanceof RegionAttachment) {\n                    verticesLength = 8;\n                    vertices = Utils.setArraySize(temp, verticesLength, 0);\n                    (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\n                }else if (attachment instanceof MeshAttachment) {\n                    let mesh = (<MeshAttachment>attachment);\n                    verticesLength = mesh.worldVerticesLength;\n                    vertices = Utils.setArraySize(temp, verticesLength, 0);\n                    mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n                }\n                if (vertices != null) {\n                    for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                        let x = vertices[ii], y = vertices[ii + 1];\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            }\n            offset.set(minX, minY);\n            size.set(maxX - minX, maxY - minY);\n        }\n\n        update (delta: number) {\n            this.time += delta;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class SkeletonBounds {\n        minX = 0; minY = 0; maxX = 0; maxY = 0;\n        boundingBoxes = new Array<BoundingBoxAttachment>();\n        polygons = new Array<ArrayLike<number>>();\n        private polygonPool = new Pool<ArrayLike<number>>(() => {\n            return Utils.newFloatArray(16);\n        });\n\n        update (skeleton: Skeleton, updateAabb: boolean) {\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            let boundingBoxes = this.boundingBoxes;\n            let polygons = this.polygons;\n            let polygonPool = this.polygonPool;\n            let slots = skeleton.slots;\n            let slotCount = slots.length;\n\n            boundingBoxes.length = 0;\n            polygonPool.freeAll(polygons);\n            polygons.length = 0;\n\n            for (let i = 0; i < slotCount; i++) {\n                let slot = slots[i];\n                let attachment = slot.getAttachment();\n                if (attachment instanceof BoundingBoxAttachment) {\n                    let boundingBox = attachment as BoundingBoxAttachment;\n                    boundingBoxes.push(boundingBox);\n\n                    let polygon = polygonPool.obtain();\n                    if (polygon.length != boundingBox.worldVerticesLength) {\n                        polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n                    }\n                    polygons.push(polygon);\n                    boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n                }\n            }\n\n            if (updateAabb) {\n                this.aabbCompute();\n            } else {\n                this.minX = Number.POSITIVE_INFINITY;\n                this.minY = Number.POSITIVE_INFINITY;\n                this.maxX = Number.NEGATIVE_INFINITY;\n                this.maxY = Number.NEGATIVE_INFINITY;\n            }\n        }\n\n        aabbCompute () {\n            let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n            let polygons = this.polygons;\n            for (let i = 0, n = polygons.length; i < n; i++) {\n                let polygon = polygons[i];\n                let vertices = polygon;\n                for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                    let x = vertices[ii];\n                    let y = vertices[ii + 1];\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n            this.minX = minX;\n            this.minY = minY;\n            this.maxX = maxX;\n            this.maxY = maxY;\n        }\n\n        /** Returns true if the axis aligned bounding box contains the point. */\n        aabbContainsPoint (x: number, y: number) {\n            return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n        }\n\n        /** Returns true if the axis aligned bounding box intersects the line segment. */\n        aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n            let minX = this.minX;\n            let minY = this.minY;\n            let maxX = this.maxX;\n            let maxY = this.maxY;\n            if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n                return false;\n            let m = (y2 - y1) / (x2 - x1);\n            let y = m * (minX - x1) + y1;\n            if (y > minY && y < maxY) return true;\n            y = m * (maxX - x1) + y1;\n            if (y > minY && y < maxY) return true;\n            let x = (minY - y1) / m + x1;\n            if (x > minX && x < maxX) return true;\n            x = (maxY - y1) / m + x1;\n            if (x > minX && x < maxX) return true;\n            return false;\n        }\n\n        /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n        aabbIntersectsSkeleton (bounds: SkeletonBounds) {\n            return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n        }\n\n        /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n         * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n        containsPoint (x: number, y: number): BoundingBoxAttachment {\n            let polygons = this.polygons;\n            for (let i = 0, n = polygons.length; i < n; i++)\n                if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n            return null;\n        }\n\n        /** Returns true if the polygon contains the point. */\n        containsPointPolygon (polygon: ArrayLike<number>, x: number, y: number) {\n            let vertices = polygon;\n            let nn = polygon.length;\n\n            let prevIndex = nn - 2;\n            let inside = false;\n            for (let ii = 0; ii < nn; ii += 2) {\n                let vertexY = vertices[ii + 1];\n                let prevY = vertices[prevIndex + 1];\n                if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n                    let vertexX = vertices[ii];\n                    if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n                }\n                prevIndex = ii;\n            }\n            return inside;\n        }\n\n        /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n         * is usually more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns\n         * true. */\n        intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n            let polygons = this.polygons;\n            for (let i = 0, n = polygons.length; i < n; i++)\n                if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n            return null;\n        }\n\n        /** Returns true if the polygon contains any part of the line segment. */\n        intersectsSegmentPolygon (polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number) {\n            let vertices = polygon;\n            let nn = polygon.length;\n\n            let width12 = x1 - x2, height12 = y1 - y2;\n            let det1 = x1 * y2 - y1 * x2;\n            let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\n            for (let ii = 0; ii < nn; ii += 2) {\n                let x4 = vertices[ii], y4 = vertices[ii + 1];\n                let det2 = x3 * y4 - y3 * x4;\n                let width34 = x3 - x4, height34 = y3 - y4;\n                let det3 = width12 * height34 - height12 * width34;\n                let x = (det1 * width34 - width12 * det2) / det3;\n                if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n                    let y = (det1 * height34 - height12 * det2) / det3;\n                    if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n                }\n                x3 = x4;\n                y3 = y4;\n            }\n            return false;\n        }\n\n        /** Returns the polygon for the specified bounding box, or null. */\n        getPolygon (boundingBox: BoundingBoxAttachment) {\n            if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\n            let index = this.boundingBoxes.indexOf(boundingBox);\n            return index == -1 ? null : this.polygons[index];\n        }\n\n        getWidth () {\n            return this.maxX - this.minX;\n        }\n\n        getHeight () {\n            return this.maxY - this.minY;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport class SkeletonClipping {\n\t\tprivate triangulator = new Triangulator();\n\t\tprivate clippingPolygon = new Array<number>();\n\t\tprivate clipOutput = new Array<number>();\n\t\tclippedVertices = new Array<number>();\n\t\tclippedTriangles = new Array<number>();\n\t\tprivate scratch = new Array<number>();\n\n\t\tprivate clipAttachment: ClippingAttachment;\n\t\tprivate clippingPolygons: Array<Array<number>>;\n\n\t\tclipStart (slot: Slot, clip: ClippingAttachment): number {\n\t\t\tif (this.clipAttachment != null) return 0;\n\t\t\tthis.clipAttachment = clip;\n\n\t\t\tlet n = clip.worldVerticesLength;\n\t\t\tlet vertices = Utils.setArraySize(this.clippingPolygon, n);\n\t\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n\t\t\tlet clippingPolygon = this.clippingPolygon;\n\t\t\tSkeletonClipping.makeClockwise(clippingPolygon);\n\t\t\tlet clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n\t\t\tfor (let i = 0, n = clippingPolygons.length; i < n; i++) {\n\t\t\t\tlet polygon = clippingPolygons[i];\n\t\t\t\tSkeletonClipping.makeClockwise(polygon);\n\t\t\t\tpolygon.push(polygon[0]);\n\t\t\t\tpolygon.push(polygon[1]);\n\t\t\t}\n\n\t\t\treturn clippingPolygons.length;\n\t\t}\n\n\t\tclipEndWithSlot (slot: Slot) {\n\t\t\tif (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd();\n\t\t}\n\n\t\tclipEnd () {\n\t\t\tif (this.clipAttachment == null) return;\n\t\t\tthis.clipAttachment = null;\n\t\t\tthis.clippingPolygons = null;\n\t\t\tthis.clippedVertices.length = 0;\n\t\t\tthis.clippedTriangles.length = 0;\n\t\t\tthis.clippingPolygon.length = 0;\n\t\t}\n\n\t\tisClipping (): boolean {\n\t\t\treturn this.clipAttachment != null;\n\t\t}\n\n\t\tclipTriangles (vertices: ArrayLike<number>, verticesLength: number, triangles: ArrayLike<number>, trianglesLength: number, uvs: ArrayLike<number>,\n\t\t\tlight: Color, dark: Color, twoColor: boolean) {\n\n\t\t\tlet clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\n\t\t\tlet clippedTriangles = this.clippedTriangles;\n\t\t\tlet polygons = this.clippingPolygons;\n\t\t\tlet polygonsCount = this.clippingPolygons.length;\n\t\t\tlet vertexSize = twoColor ? 12 : 8;\n\n\t\t\tlet index = 0;\n\t\t\tclippedVertices.length = 0;\n\t\t\tclippedTriangles.length = 0;\n\t\t\touter:\n\t\t\tfor (let i = 0; i < trianglesLength; i += 3) {\n\t\t\t\tlet vertexOffset = triangles[i] << 1;\n\t\t\t\tlet x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\n\t\t\t\tlet u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\n\n\t\t\t\tvertexOffset = triangles[i + 1] << 1;\n\t\t\t\tlet x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\n\t\t\t\tlet u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\n\n\t\t\t\tvertexOffset = triangles[i + 2] << 1;\n\t\t\t\tlet x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\n\t\t\t\tlet u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\n\n\t\t\t\tfor (let p = 0; p < polygonsCount; p++) {\n\t\t\t\t\tlet s = clippedVertices.length;\n\t\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n\t\t\t\t\t\tlet clipOutputLength = clipOutput.length;\n\t\t\t\t\t\tif (clipOutputLength == 0) continue;\n\t\t\t\t\t\tlet d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\n\t\t\t\t\t\tlet d = 1 / (d0 * d2 + d1 * (y1 - y3));\n\n\t\t\t\t\t\tlet clipOutputCount = clipOutputLength >> 1;\n\t\t\t\t\t\tlet clipOutputItems = this.clipOutput;\n\t\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n\t\t\t\t\t\tfor (let ii = 0; ii < clipOutputLength; ii += 2) {\n\t\t\t\t\t\t\tlet x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\n\t\t\t\t\t\t\tclippedVerticesItems[s] = x;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\t\t\tlet c0 = x - x3, c1 = y - y3;\n\t\t\t\t\t\t\tlet a = (d0 * c0 + d1 * c1) * d;\n\t\t\t\t\t\t\tlet b = (d4 * c0 + d2 * c1) * d;\n\t\t\t\t\t\t\tlet c = 1 - a - b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n\t\t\t\t\t\t\tif (twoColor) {\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts += vertexSize;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n\t\t\t\t\t\tclipOutputCount--;\n\t\t\t\t\t\tfor (let ii = 1; ii < clipOutputCount; ii++) {\n\t\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\n\t\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex += clipOutputCount + 1;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n\t\t\t\t\t\tclippedVerticesItems[s] = x1;\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\t\tif (!twoColor) {\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\n\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\n\n\t\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3);\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\n\t\t\t\t\t\tindex += 3;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping\n\t\t * area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list. */\n\t\tclip (x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, clippingArea: Array<number>, output: Array<number>) {\n\t\t\tlet originalOutput = output;\n\t\t\tlet clipped = false;\n\n\t\t\t// Avoid copy at the end.\n\t\t\tlet input: Array<number> = null;\n\t\t\tif (clippingArea.length % 4 >= 2) {\n\t\t\t\tinput = output;\n\t\t\t\toutput = this.scratch;\n\t\t\t} else\n\t\t\t\tinput = this.scratch;\n\n\t\t\tinput.length = 0;\n\t\t\tinput.push(x1);\n\t\t\tinput.push(y1);\n\t\t\tinput.push(x2);\n\t\t\tinput.push(y2);\n\t\t\tinput.push(x3);\n\t\t\tinput.push(y3);\n\t\t\tinput.push(x1);\n\t\t\tinput.push(y1);\n\t\t\toutput.length = 0;\n\n\t\t\tlet clippingVertices = clippingArea;\n\t\t\tlet clippingVerticesLast = clippingArea.length - 4;\n\t\t\tfor (let i = 0;; i += 2) {\n\t\t\t\tlet edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\n\t\t\t\tlet edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\n\t\t\t\tlet deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\n\n\t\t\t\tlet inputVertices = input;\n\t\t\t\tlet inputVerticesLength = input.length - 2, outputStart = output.length;\n\t\t\t\tfor (let ii = 0; ii < inputVerticesLength; ii += 2) {\n\t\t\t\t\tlet inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\n\t\t\t\t\tlet inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\n\t\t\t\t\tlet side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n\t\t\t\t\tif (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n\t\t\t\t\t\tif (side2) { // v1 inside, v2 inside\n\t\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// v1 inside, v2 outside\n\t\t\t\t\t\tlet c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n\t\t\t\t\t\tlet ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\n\t\t\t\t\t} else if (side2) { // v1 outside, v2 inside\n\t\t\t\t\t\tlet c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n\t\t\t\t\t\tlet ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\n\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t}\n\t\t\t\t\tclipped = true;\n\t\t\t\t}\n\n\t\t\t\tif (outputStart == output.length) { // All edges outside.\n\t\t\t\t\toriginalOutput.length = 0;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\toutput.push(output[0]);\n\t\t\t\toutput.push(output[1]);\n\n\t\t\t\tif (i == clippingVerticesLast) break;\n\t\t\t\tlet temp = output;\n\t\t\t\toutput = input;\n\t\t\t\toutput.length = 0;\n\t\t\t\tinput = temp;\n\t\t\t}\n\n\t\t\tif (originalOutput != output) {\n\t\t\t\toriginalOutput.length = 0;\n\t\t\t\tfor (let i = 0, n = output.length - 2; i < n; i++)\n\t\t\t\t\toriginalOutput[i] = output[i];\n\t\t\t} else\n\t\t\t\toriginalOutput.length = originalOutput.length - 2;\n\n\t\t\treturn clipped;\n\t\t}\n\n\t\tpublic static makeClockwise (polygon: ArrayLike<number>) {\n\t\t\tlet vertices = polygon;\n\t\t\tlet verticeslength = polygon.length;\n\n\t\t\tlet area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\n\t\t\tfor (let i = 0, n = verticeslength - 3; i < n; i += 2) {\n\t\t\t\tp1x = vertices[i];\n\t\t\t\tp1y = vertices[i + 1];\n\t\t\t\tp2x = vertices[i + 2];\n\t\t\t\tp2y = vertices[i + 3];\n\t\t\t\tarea += p1x * p2y - p2x * p1y;\n\t\t\t}\n\t\t\tif (area < 0) return;\n\n\t\t\tfor (let i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n\t\t\t\tlet x = vertices[i], y = vertices[i + 1];\n\t\t\t\tlet other = lastX - i;\n\t\t\t\tvertices[i] = vertices[other];\n\t\t\t\tvertices[i + 1] = vertices[other + 1];\n\t\t\t\tvertices[other] = x;\n\t\t\t\tvertices[other + 1] = y;\n\t\t\t}\n\t\t}\n\t}\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class SkeletonData {\n        name: string;\n        bones = new Array<BoneData>(); // Ordered parents first.\n        slots = new Array<SlotData>(); // Setup pose draw order.\n        skins = new Array<Skin>();\n        defaultSkin: Skin;\n        events = new Array<EventData>();\n        animations = new Array<Animation>();\n        ikConstraints = new Array<IkConstraintData>();\n        transformConstraints = new Array<TransformConstraintData>();\n        pathConstraints = new Array<PathConstraintData>();\n        width: number;\n        height: number;\n        version: string;\n        hash: string;\n\n        // Nonessential\n        fps = 0;\n        imagesPath: string;\n\n        findBone(boneName: string) {\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (bone.name == boneName) return bone;\n            }\n            return null;\n        }\n\n        findBoneIndex(boneName: string) {\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++)\n                if (bones[i].name == boneName) return i;\n            return -1;\n        }\n\n        findSlot(slotName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++) {\n                let slot = slots[i];\n                if (slot.name == slotName) return slot;\n            }\n            return null;\n        }\n\n        findSlotIndex(slotName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++)\n                if (slots[i].name == slotName) return i;\n            return -1;\n        }\n\n        findSkin(skinName: string) {\n            if (skinName == null) throw new Error(\"skinName cannot be null.\");\n            let skins = this.skins;\n            for (let i = 0, n = skins.length; i < n; i++) {\n                let skin = skins[i];\n                if (skin.name == skinName) return skin;\n            }\n            return null;\n        }\n\n        findEvent(eventDataName: string) {\n            if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\n            let events = this.events;\n            for (let i = 0, n = events.length; i < n; i++) {\n                let event = events[i];\n                if (event.name == eventDataName) return event;\n            }\n            return null;\n        }\n\n        findAnimation(animationName: string) {\n            if (animationName == null) throw new Error(\"animationName cannot be null.\");\n            let animations = this.animations;\n            for (let i = 0, n = animations.length; i < n; i++) {\n                let animation = animations[i];\n                if (animation.name == animationName) return animation;\n            }\n            return null;\n        }\n\n        findIkConstraint(constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let ikConstraints = this.ikConstraints;\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\n                let constraint = ikConstraints[i];\n                if (constraint.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        findTransformConstraint(constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let transformConstraints = this.transformConstraints;\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\n                let constraint = transformConstraints[i];\n                if (constraint.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        findPathConstraint(constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let pathConstraints = this.pathConstraints;\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\n                let constraint = pathConstraints[i];\n                if (constraint.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        findPathConstraintIndex(pathConstraintName: string) {\n            if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n            let pathConstraints = this.pathConstraints;\n            for (let i = 0, n = pathConstraints.length; i < n; i++)\n                if (pathConstraints[i].name == pathConstraintName) return i;\n            return -1;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class SkeletonJson {\n        attachmentLoader: AttachmentLoader;\n        scale = 1;\n        private linkedMeshes = new Array<LinkedMesh>();\n\n        constructor (attachmentLoader: AttachmentLoader) {\n            this.attachmentLoader = attachmentLoader;\n        }\n\n        readSkeletonData (json: string | any): SkeletonData {\n            let scale = this.scale;\n            let skeletonData = new SkeletonData();\n            let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\n\n            // Skeleton\n            let skeletonMap = root.skeleton;\n            if (skeletonMap != null) {\n                skeletonData.hash = skeletonMap.hash;\n                skeletonData.version = skeletonMap.spine;\n                skeletonData.width = skeletonMap.width;\n                skeletonData.height = skeletonMap.height;\n                skeletonData.fps = skeletonMap.fps;\n                skeletonData.imagesPath = skeletonMap.images;\n            }\n\n            // Bones\n            if (root.bones) {\n                for (let i = 0; i < root.bones.length; i++) {\n                    let boneMap = root.bones[i];\n\n                    let parent: BoneData = null;\n                    let parentName: string = this.getValue(boneMap, \"parent\", null);\n                    if (parentName != null) {\n                        parent = skeletonData.findBone(parentName);\n                        if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\n                    }\n                    let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n                    data.length = this.getValue(boneMap, \"length\", 0) * scale;\n                    data.x = this.getValue(boneMap, \"x\", 0) * scale;\n                    data.y = this.getValue(boneMap, \"y\", 0) * scale;\n                    data.rotation = this.getValue(boneMap, \"rotation\", 0);\n                    data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n                    data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n                    data.shearX = this.getValue(boneMap, \"shearX\", 0);\n                    data.shearY = this.getValue(boneMap, \"shearY\", 0);\n                    data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n\n                    skeletonData.bones.push(data);\n                }\n            }\n\n            // Slots.\n            if (root.slots) {\n                for (let i = 0; i < root.slots.length; i++) {\n                    let slotMap = root.slots[i];\n                    let slotName: string = slotMap.name;\n                    let boneName: string = slotMap.bone;\n                    let boneData = skeletonData.findBone(boneName);\n                    if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n                    let data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                    let color: string = this.getValue(slotMap, \"color\", null);\n                    if (color != null) data.color.setFromString(color);\n\n                    let dark: string = this.getValue(slotMap, \"dark\", null);\n                    if (dark != null) {\n                        data.darkColor = new Color(1, 1, 1, 1);\n                        data.darkColor.setFromString(dark);\n                    }\n\n                    data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n                    data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n                    skeletonData.slots.push(data);\n                }\n            }\n\n            // IK constraints\n            if (root.ik) {\n                for (let i = 0; i < root.ik.length; i++) {\n                    let constraintMap = root.ik[i];\n                    let data = new IkConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\n                        let boneName = constraintMap.bones[j];\n                        let bone = skeletonData.findBone(boneName);\n                        if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n\n                    let targetName: string = constraintMap.target;\n                    data.target = skeletonData.findBone(targetName);\n                    if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\n\n                    data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n                    data.mix = this.getValue(constraintMap, \"mix\", 1);\n\n                    skeletonData.ikConstraints.push(data);\n                }\n            }\n\n            // Transform constraints.\n            if (root.transform) {\n                for (let i = 0; i < root.transform.length; i++) {\n                    let constraintMap = root.transform[i];\n                    let data = new TransformConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\n                        let boneName = constraintMap.bones[j];\n                        let bone = skeletonData.findBone(boneName);\n                        if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n\n                    let targetName: string = constraintMap.target;\n                    data.target = skeletonData.findBone(targetName);\n                    if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n\n                    data.local = this.getValue(constraintMap, \"local\", false);\n                    data.relative = this.getValue(constraintMap, \"relative\", false);\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                    data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n                    data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n                    data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n                    data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n                    data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                    data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n                    data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n\n                    skeletonData.transformConstraints.push(data);\n                }\n            }\n\n            // Path constraints.\n            if (root.path) {\n                for (let i = 0; i < root.path.length; i++) {\n                    let constraintMap = root.path[i];\n                    let data = new PathConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\n                        let boneName = constraintMap.bones[j];\n                        let bone = skeletonData.findBone(boneName);\n                        if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n\n                    let targetName: string = constraintMap.target;\n                    data.target = skeletonData.findSlot(targetName);\n                    if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n\n                    data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n                    data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n                    data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                    data.position = this.getValue(constraintMap, \"position\", 0);\n                    if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                    data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n                    if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n\n                    skeletonData.pathConstraints.push(data);\n                }\n            }\n\n            // Skins.\n            if (root.skins) {\n                for (let skinName in root.skins) {\n                    let skinMap = root.skins[skinName]\n                    let skin = new Skin(skinName);\n                    for (let slotName in skinMap) {\n                        let slotIndex = skeletonData.findSlotIndex(slotName);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                        let slotMap = skinMap[slotName];\n                        for (let entryName in slotMap) {\n                            let attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n                            if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                        }\n                    }\n                    skeletonData.skins.push(skin);\n                    if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n                }\n            }\n\n            // Linked meshes.\n            for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n                let linkedMesh = this.linkedMeshes[i];\n                let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n                if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n                let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n                if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n                linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\n                //linkedMesh.mesh.updateUVs();\n            }\n            this.linkedMeshes.length = 0;\n\n            // Events.\n            if (root.events) {\n                for (let eventName in root.events) {\n                    let eventMap = root.events[eventName];\n                    let data = new EventData(eventName);\n                    data.intValue = this.getValue(eventMap, \"int\", 0);\n                    data.floatValue = this.getValue(eventMap, \"float\", 0);\n                    data.stringValue = this.getValue(eventMap, \"string\", \"\");\n                    skeletonData.events.push(data);\n                }\n            }\n\n            // Animations.\n            if (root.animations) {\n                for (let animationName in root.animations) {\n                    let animationMap = root.animations[animationName];\n                    this.readAnimation(animationMap, animationName, skeletonData);\n                }\n            }\n\n            return skeletonData;\n        }\n\n        readAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\n            let scale = this.scale;\n            name = this.getValue(map, \"name\", name);\n\n            let type = this.getValue(map, \"type\", \"region\");\n\n            switch (type) {\n                case \"region\": {\n                    let path = this.getValue(map, \"path\", name);\n                    let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n                    if (region == null) return null;\n                    region.path = path;\n                    region.x = this.getValue(map, \"x\", 0) * scale;\n                    region.y = this.getValue(map, \"y\", 0) * scale;\n                    region.scaleX = this.getValue(map, \"scaleX\", 1);\n                    region.scaleY = this.getValue(map, \"scaleY\", 1);\n                    region.rotation = this.getValue(map, \"rotation\", 0);\n                    region.width = map.width * scale;\n                    region.height = map.height * scale;\n\n                    let color: string = this.getValue(map, \"color\", null);\n                    if (color != null) region.color.setFromString(color);\n\n                    //region.updateOffset();\n                    return region;\n                }\n                case \"boundingbox\": {\n                    let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n                    if (box == null) return null;\n                    this.readVertices(map, box, map.vertexCount << 1);\n                    let color: string = this.getValue(map, \"color\", null);\n                    if (color != null) box.color.setFromString(color);\n                    return box;\n                }\n                case \"mesh\":\n                case \"linkedmesh\": {\n                    let path = this.getValue(map, \"path\", name);\n                    let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                    if (mesh == null) return null;\n                    mesh.path = path;\n\n                    let color = this.getValue(map, \"color\", null);\n                    if (color != null) mesh.color.setFromString(color);\n\n                    let parent: string = this.getValue(map, \"parent\", null);\n                    if (parent != null) {\n                        mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                        this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent));\n                        return mesh;\n                    }\n\n                    let uvs: Array<number> = map.uvs;\n                    this.readVertices(map, mesh, uvs.length);\n                    mesh.triangles = map.triangles;\n                    mesh.regionUVs = uvs;\n                    //mesh.updateUVs();\n\n                    mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n                    return mesh;\n                }\n                case \"path\": {\n                    let path = this.attachmentLoader.newPathAttachment(skin, name);\n                    if (path == null) return null;\n                    path.closed = this.getValue(map, \"closed\", false);\n                    path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n\n                    let vertexCount = map.vertexCount;\n                    this.readVertices(map, path, vertexCount << 1);\n\n                    let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n                    for (let i = 0; i < map.lengths.length; i++)\n                        lengths[i] = map.lengths[i] * scale;\n                    path.lengths = lengths;\n\n                    let color: string = this.getValue(map, \"color\", null);\n                    if (color != null) path.color.setFromString(color);\n                    return path;\n                }\n                case \"point\": {\n                    let point = this.attachmentLoader.newPointAttachment(skin, name);\n                    if (point == null) return null;\n                    point.x = this.getValue(map, \"x\", 0) * scale;\n                    point.y = this.getValue(map, \"y\", 0) * scale;\n                    point.rotation = this.getValue(map, \"rotation\", 0);\n\n                    let color = this.getValue(map, \"color\", null);\n                    if (color != null) point.color.setFromString(color);\n                    return point;\n                }\n                case \"clipping\": {\n                    let clip = this.attachmentLoader.newClippingAttachment(skin, name);\n                    if (clip == null) return null;\n\n                    let end = this.getValue(map, \"end\", null);\n                    if (end != null) {\n                        let slot = skeletonData.findSlot(end);\n                        if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\n                        clip.endSlot = slot;\n                    }\n\n                    let vertexCount = map.vertexCount;\n                    this.readVertices(map, clip, vertexCount << 1);\n\n                    let color: string = this.getValue(map, \"color\", null);\n                    if (color != null) clip.color.setFromString(color);\n                    return clip;\n                }\n            }\n            return null;\n        }\n\n        readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\n            let scale = this.scale;\n            attachment.worldVerticesLength = verticesLength;\n            let vertices: Array<number> = map.vertices;\n            if (verticesLength == vertices.length) {\n                let scaledVertices = Utils.toFloatArray(vertices);\n                if (scale != 1) {\n                    for (let i = 0, n = vertices.length; i < n; i++)\n                        scaledVertices[i] *= scale;\n                }\n                attachment.vertices = scaledVertices;\n                return;\n            }\n            let weights = new Array<number>();\n            let bones = new Array<number>();\n            for (let i = 0, n = vertices.length; i < n;) {\n                let boneCount = vertices[i++];\n                bones.push(boneCount);\n                for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                    bones.push(vertices[i]);\n                    weights.push(vertices[i + 1] * scale);\n                    weights.push(vertices[i + 2] * scale);\n                    weights.push(vertices[i + 3]);\n                }\n            }\n            attachment.bones = bones;\n            attachment.vertices = Utils.toFloatArray(weights);\n        }\n\n        readAnimation (map: any, name: string, skeletonData: SkeletonData) {\n            let scale = this.scale;\n            let timelines = new Array<Timeline>();\n            let duration = 0;\n\n            // Slot timelines.\n            if (map.slots) {\n                for (let slotName in map.slots) {\n                    let slotMap = map.slots[slotName];\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                    for (let timelineName in slotMap) {\n                        let timelineMap = slotMap[timelineName];\n                        if (timelineName == \"attachment\") {\n                            let timeline = new AttachmentTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                        } else if (timelineName == \"color\") {\n                            let timeline = new ColorTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                let color = new Color();\n                                color.setFromString(valueMap.color);\n                                timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n\n                        } else if (timelineName == \"twoColor\") {\n                            let timeline = new TwoColorTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                let light = new Color();\n                                let dark = new Color();\n                                light.setFromString(valueMap.light);\n                                dark.setFromString(valueMap.dark);\n                                timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n\n                        } else\n                            throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n                    }\n                }\n            }\n\n            // Bone timelines.\n            if (map.bones) {\n                for (let boneName in map.bones) {\n                    let boneMap = map.bones[boneName];\n                    let boneIndex = skeletonData.findBoneIndex(boneName);\n                    if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n                    for (let timelineName in boneMap) {\n                        let timelineMap = boneMap[timelineName];\n                        if (timelineName === \"rotate\") {\n                            let timeline = new RotateTimeline(timelineMap.length);\n                            timeline.boneIndex = boneIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n\n                        } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                            let timeline: TranslateTimeline = null;\n                            let timelineScale = 1;\n                            if (timelineName === \"scale\")\n                                timeline = new ScaleTimeline(timelineMap.length);\n                            else if (timelineName === \"shear\")\n                                timeline = new ShearTimeline(timelineMap.length);\n                            else {\n                                timeline = new TranslateTimeline(timelineMap.length);\n                                timelineScale = scale;\n                            }\n                            timeline.boneIndex = boneIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                let x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\n                                timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n\n                        } else\n                            throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n                    }\n                }\n            }\n\n            // IK constraint timelines.\n            if (map.ik) {\n                for (let constraintName in map.ik) {\n                    let constraintMap = map.ik[constraintName];\n                    let constraint = skeletonData.findIkConstraint(constraintName);\n                    let timeline = new IkConstraintTimeline(constraintMap.length);\n                    timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                    let frameIndex = 0;\n                    for (let i = 0; i < constraintMap.length; i++) {\n                        let valueMap = constraintMap[i];\n                        timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1),\n                            this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\n                        this.readCurve(valueMap, timeline, frameIndex);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n                }\n            }\n\n            // Transform constraint timelines.\n            if (map.transform) {\n                for (let constraintName in map.transform) {\n                    let constraintMap = map.transform[constraintName];\n                    let constraint = skeletonData.findTransformConstraint(constraintName);\n                    let timeline = new TransformConstraintTimeline(constraintMap.length);\n                    timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                    let frameIndex = 0;\n                    for (let i = 0; i < constraintMap.length; i++) {\n                        let valueMap = constraintMap[i];\n                        timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                            this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n                        this.readCurve(valueMap, timeline, frameIndex);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration,\n                        timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n                }\n            }\n\n            // Path constraint timelines.\n            if (map.paths) {\n                for (let constraintName in map.paths) {\n                    let constraintMap = map.paths[constraintName];\n                    let index = skeletonData.findPathConstraintIndex(constraintName);\n                    if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n                    let data = skeletonData.pathConstraints[index];\n                    for (let timelineName in constraintMap) {\n                        let timelineMap = constraintMap[timelineName];\n                        if (timelineName === \"position\" || timelineName === \"spacing\") {\n                            let timeline: PathConstraintPositionTimeline = null;\n                            let timelineScale = 1;\n                            if (timelineName === \"spacing\") {\n                                timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                            } else {\n                                timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                                if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                            }\n                            timeline.pathConstraintIndex = index;\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration,\n                                timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                        } else if (timelineName === \"mix\") {\n                            let timeline = new PathConstraintMixTimeline(timelineMap.length);\n                            timeline.pathConstraintIndex = index;\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                                    this.getValue(valueMap, \"translateMix\", 1));\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration,\n                                timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                        }\n                    }\n                }\n            }\n\n            // Deform timelines.\n            if (map.deform) {\n                for (let deformName in map.deform) {\n                    let deformMap = map.deform[deformName];\n                    let skin = skeletonData.findSkin(deformName);\n                    if (skin == null) throw new Error(\"Skin not found: \" + deformName);\n                    for (let slotName in deformMap) {\n                        let slotMap = deformMap[slotName];\n                        let slotIndex = skeletonData.findSlotIndex(slotName);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n                        for (let timelineName in slotMap) {\n                            let timelineMap = slotMap[timelineName];\n                            let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n                            if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                            let weighted = attachment.bones != null;\n                            let vertices = attachment.vertices;\n                            let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\n                            let timeline = new DeformTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n                            timeline.attachment = attachment;\n\n                            let frameIndex = 0;\n                            for (let j = 0; j < timelineMap.length; j++) {\n                                let valueMap = timelineMap[j];\n                                let deform: ArrayLike<number>;\n                                let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\n                                if (verticesValue == null)\n                                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                                else {\n                                    deform = Utils.newFloatArray(deformLength);\n                                    let start = <number>this.getValue(valueMap, \"offset\", 0);\n                                    Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                    if (scale != 1) {\n                                        for (let i = start, n = i + verticesValue.length; i < n; i++)\n                                            deform[i] *= scale;\n                                    }\n                                    if (!weighted) {\n                                        for (let i = 0; i < deformLength; i++)\n                                            deform[i] += vertices[i];\n                                    }\n                                }\n\n                                timeline.setFrame(frameIndex, valueMap.time, deform);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                        }\n                    }\n                }\n            }\n\n            // Draw order timeline.\n            let drawOrderNode = map.drawOrder;\n            if (drawOrderNode == null) drawOrderNode = map.draworder;\n            if (drawOrderNode != null) {\n                let timeline = new DrawOrderTimeline(drawOrderNode.length);\n                let slotCount = skeletonData.slots.length;\n                let frameIndex = 0;\n                for (let j = 0; j < drawOrderNode.length; j++) {\n                    let drawOrderMap = drawOrderNode[j];\n                    let drawOrder: Array<number> = null;\n                    let offsets = this.getValue(drawOrderMap, \"offsets\", null);\n                    if (offsets != null) {\n                        drawOrder = Utils.newArray<number>(slotCount, -1);\n                        let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                        let originalIndex = 0, unchangedIndex = 0;\n                        for (let i = 0; i < offsets.length; i++) {\n                            let offsetMap = offsets[i];\n                            let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                            if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\n                            // Collect unchanged items.\n                            while (originalIndex != slotIndex)\n                                unchanged[unchangedIndex++] = originalIndex++;\n                            // Set changed items.\n                            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                        }\n                        // Collect remaining unchanged items.\n                        while (originalIndex < slotCount)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Fill in unchanged items.\n                        for (let i = slotCount - 1; i >= 0; i--)\n                            if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                    }\n                    timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n            }\n\n            // Event timeline.\n            if (map.events) {\n                let timeline = new EventTimeline(map.events.length);\n                let frameIndex = 0;\n                for (let i = 0; i < map.events.length; i++) {\n                    let eventMap = map.events[i];\n                    let eventData = skeletonData.findEvent(eventMap.name);\n                    if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\n                    let event = new Event(Utils.toSinglePrecision(eventMap.time), eventData);\n                    event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n                    event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n                    event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n                    timeline.setFrame(frameIndex++, event);\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n            }\n\n            if (isNaN(duration)) {\n                throw new Error(\"Error while parsing animation, duration is NaN\");\n            }\n\n            skeletonData.animations.push(new Animation(name, timelines, duration));\n        }\n\n        readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\n            if (!map.curve) return;\n            if (map.curve === \"stepped\")\n                timeline.setStepped(frameIndex);\n            else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n                let curve: Array<number> = map.curve;\n                timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n            }\n        }\n\n        getValue (map: any, prop: string, defaultValue: any) {\n            return map[prop] !== undefined ? map[prop] : defaultValue;\n        }\n\n        static blendModeFromString (str: string) {\n            str = str.toLowerCase();\n            if (str == \"normal\") return BlendMode.Normal;\n            if (str == \"additive\") return BlendMode.Additive;\n            if (str == \"multiply\") return BlendMode.Multiply;\n            if (str == \"screen\") return BlendMode.Screen;\n            throw new Error(`Unknown blend mode: ${str}`);\n        }\n\n        static positionModeFromString (str: string) {\n            str = str.toLowerCase();\n            if (str == \"fixed\") return PositionMode.Fixed;\n            if (str == \"percent\") return PositionMode.Percent;\n            throw new Error(`Unknown position mode: ${str}`);\n        }\n\n        static spacingModeFromString (str: string) {\n            str = str.toLowerCase();\n            if (str == \"length\") return SpacingMode.Length;\n            if (str == \"fixed\") return SpacingMode.Fixed;\n            if (str == \"percent\") return SpacingMode.Percent;\n            throw new Error(`Unknown position mode: ${str}`);\n        }\n\n        static rotateModeFromString (str: string) {\n            str = str.toLowerCase();\n            if (str == \"tangent\") return RotateMode.Tangent;\n            if (str == \"chain\") return RotateMode.Chain;\n            if (str == \"chainscale\") return RotateMode.ChainScale;\n            throw new Error(`Unknown rotate mode: ${str}`);\n        }\n\n        static transformModeFromString(str: string) {\n            str = str.toLowerCase();\n            if (str == \"normal\") return TransformMode.Normal;\n            if (str == \"onlytranslation\") return TransformMode.OnlyTranslation;\n            if (str == \"norotationorreflection\") return TransformMode.NoRotationOrReflection;\n            if (str == \"noscale\") return TransformMode.NoScale;\n            if (str == \"noscaleorreflection\") return TransformMode.NoScaleOrReflection;\n            throw new Error(`Unknown transform mode: ${str}`);\n        }\n    }\n\n    class LinkedMesh {\n        parent: string; skin: string;\n        slotIndex: number;\n        mesh: MeshAttachment;\n\n        constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\n            this.mesh = mesh;\n            this.skin = skin;\n            this.slotIndex = slotIndex;\n            this.parent = parent;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Skin {\n        name: string;\n        attachments = new Array<Map<Attachment>>();\n\n        constructor(name: string) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n\n        addAttachment(slotIndex: number, name: string, attachment: Attachment) {\n            if (attachment == null) throw new Error(\"attachment cannot be null.\");\n            let attachments = this.attachments;\n            if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n            if (!attachments[slotIndex]) attachments[slotIndex] = {};\n            attachments[slotIndex][name] = attachment;\n        }\n\n        /** @return May be null. */\n        getAttachment(slotIndex: number, name: string): Attachment {\n            let dictionary = this.attachments[slotIndex];\n            return dictionary ? dictionary[name] : null;\n        }\n\n        /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n        attachAll(skeleton: Skeleton, oldSkin: Skin) {\n            let slotIndex = 0;\n            for (let i = 0; i < skeleton.slots.length; i++) {\n                let slot = skeleton.slots[i];\n                let slotAttachment = slot.getAttachment();\n                if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                    let dictionary = oldSkin.attachments[slotIndex];\n                    for (let key in dictionary) {\n                        let skinAttachment: Attachment = dictionary[key];\n                        if (slotAttachment == skinAttachment) {\n                            let attachment = this.getAttachment(slotIndex, name);\n                            if (attachment != null) slot.setAttachment(attachment);\n                            break;\n                        }\n                    }\n                }\n                slotIndex++;\n            }\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Slot {\n        //this is for PIXI\n        currentMesh: any;\n        currentSprite: any;\n        currentGraphics: any;\n        clippingContainer: any;\n\n        meshes: any;\n        currentMeshName: string;\n        sprites: any;\n        currentSpriteName: string;\n\n        blendMode: number;\n        //assign hack region a bit later\n        tempRegion: TextureRegion;\n        tempAttachment: Attachment;\n\n        //this is canon\n        data: SlotData;\n        bone: Bone;\n        color: Color;\n        darkColor: Color;\n        attachment: Attachment;\n        private attachmentTime: number;\n        attachmentVertices = new Array<number>();\n\n        constructor (data: SlotData, bone: Bone) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (bone == null) throw new Error(\"bone cannot be null.\");\n            this.data = data;\n            this.bone = bone;\n            this.color = new Color();\n            this.darkColor = data.darkColor == null ? null : new Color();\n            this.setToSetupPose();\n\n            this.blendMode = this.data.blendMode;\n        }\n\n        /** @return May be null. */\n        getAttachment (): Attachment {\n            return this.attachment;\n        }\n\n        /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n         * @param attachment May be null. */\n        setAttachment (attachment: Attachment) {\n            if (this.attachment == attachment) return;\n            this.attachment = attachment;\n            this.attachmentTime = this.bone.skeleton.time;\n            this.attachmentVertices.length = 0;\n        }\n\n        setAttachmentTime (time: number) {\n            this.attachmentTime = this.bone.skeleton.time - time;\n        }\n\n        /** Returns the time since the attachment was set. */\n        getAttachmentTime (): number {\n            return this.bone.skeleton.time - this.attachmentTime;\n        }\n\n        setToSetupPose () {\n            this.color.setFromColor(this.data.color);\n            if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n            if (this.data.attachmentName == null)\n                this.attachment = null;\n            else {\n                this.attachment = null;\n                this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n            }\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class SlotData {\n        index: number;\n        name: string;\n        boneData: BoneData;\n        color = new Color(1, 1, 1, 1);\n        darkColor: Color;\n        attachmentName: string;\n        blendMode: BlendMode;\n\n        constructor (index: number, name: string, boneData: BoneData) {\n            if (index < 0) throw new Error(\"index must be >= 0.\");\n            if (name == null) throw new Error(\"name cannot be null.\");\n            if (boneData == null) throw new Error(\"boneData cannot be null.\");\n            this.index = index;\n            this.name = name;\n            this.boneData = boneData;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export abstract class Texture {\n        protected _image: HTMLImageElement;\n\n        constructor (image: HTMLImageElement) {\n            this._image = image;\n        }\n\n        getImage (): HTMLImageElement {\n            return this._image;\n        }\n\n        abstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\n        abstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\n        abstract dispose (): void;\n\n\n        public static filterFromString (text: string): TextureFilter {\n            switch (text.toLowerCase()) {\n                case \"nearest\": return TextureFilter.Nearest;\n                case \"linear\": return TextureFilter.Linear;\n                case \"mipmap\": return TextureFilter.MipMap;\n                case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\n                case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\n                case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\n                case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\n                default: throw new Error(`Unknown texture filter ${text}`);\n            }\n        }\n\n        public static wrapFromString (text: string): TextureWrap {\n            switch (text.toLowerCase()) {\n                case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\n                case \"clamptoedge\": return TextureWrap.ClampToEdge;\n                case \"repeat\": return TextureWrap.Repeat;\n                default: throw new Error(`Unknown texture wrap ${text}`);\n            }\n        }\n    }\n\n    export enum TextureFilter {\n        Nearest = 9728, // WebGLRenderingContext.NEAREST\n        Linear = 9729, // WebGLRenderingContext.LINEAR\n        MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n        MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n        MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n        MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n        MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n    }\n\n    export enum TextureWrap {\n        MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\n        ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\n        Repeat = 10497 // WebGLRenderingContext.REPEAT\n    }\n\n    export class TextureRegion {\n        texture: PIXI.Texture;\n\n        //thats for overrides\n        size: PIXI.Rectangle = null;\n\n        get width(): number {\n            const tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return (tex as any).crop.width;\n            }\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.orig.width;\n        }\n\n        get height(): number {\n            const tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return (tex as any).crop.height;\n            }\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.orig.height;\n        }\n\n        get u(): number {\n            return (this.texture as any)._uvs.x0;\n        }\n\n        get v(): number {\n            return (this.texture as any)._uvs.y0;\n        }\n\n        get u2(): number {\n            return (this.texture as any)._uvs.x2;\n        }\n\n        get v2(): number {\n            return (this.texture as any)._uvs.y2;\n        }\n\n        get offsetX(): number {\n            const tex = this.texture;\n            return tex.trim ? tex.trim.x : 0;\n        }\n\n        get offsetY(): number {\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n            return this.spineOffsetY;\n        }\n\n        get pixiOffsetY(): number {\n            const tex = this.texture;\n            return tex.trim ? tex.trim.y : 0;\n        }\n\n        get spineOffsetY(): number {\n            var tex = this.texture;\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n        }\n\n        get originalWidth(): number {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.width;\n                }\n                return (tex as any).crop.width;\n            }\n            return tex.orig.width;\n        }\n\n        get originalHeight(): number {\n            const tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.height;\n                }\n                return (tex as any).crop.height;\n            }\n            return tex.orig.height;\n        }\n\n        get x(): number {\n            return this.texture.frame.x;\n        }\n\n        get y(): number {\n            return this.texture.frame.y;\n        }\n\n        get rotate(): boolean {\n            return this.texture.rotate !== 0;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class TextureAtlas implements Disposable {\n        pages = new Array<TextureAtlasPage>();\n        regions = new Array<TextureAtlasRegion>();\n\n        constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\n            if (atlasText) {\n                this.addSpineAtlas(atlasText, textureLoader, callback);\n            }\n        }\n\n        addTexture(name: string, texture: PIXI.Texture) {\n            let pages = this.pages;\n            let page: TextureAtlasPage = null;\n            for (var i = 0; i < pages.length; i++) {\n                if (pages[i].baseTexture === texture.baseTexture) {\n                    page = pages[i];\n                    break;\n                }\n            }\n            if (page === null) {\n                page = new TextureAtlasPage();\n                page.name = 'texturePage';\n                var baseTexture = texture.baseTexture;\n                page.width = baseTexture.realWidth;\n                page.height = baseTexture.realHeight;\n                page.baseTexture = baseTexture;\n                //those fields are not relevant in Pixi\n                page.minFilter = page.magFilter = TextureFilter.Nearest;\n                page.uWrap = TextureWrap.ClampToEdge;\n                page.vWrap = TextureWrap.ClampToEdge;\n                pages.push(page);\n            }\n            var region = new TextureAtlasRegion();\n            region.name = name;\n            region.page = page;\n            region.texture = texture;\n            region.index = -1;\n            this.regions.push(region);\n            return region;\n        }\n\n        addTextureHash(textures: Map<PIXI.Texture>, stripExtension: boolean) {\n            for (var key in textures) {\n                if (textures.hasOwnProperty(key)) {\n                    this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n                }\n            }\n        }\n\n        public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture)  => any) => any, callback: (obj: TextureAtlas) => any) {\n            return this.load(atlasText, textureLoader, callback);\n        }\n\n        private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n            if (textureLoader == null)\n                throw new Error(\"textureLoader cannot be null.\");\n\n            let reader = new TextureAtlasReader(atlasText);\n            let tuple = new Array<string>(4);\n            let page: TextureAtlasPage = null;\n\n            let iterateParser = () => {\n                while (true) {\n                    let line = reader.readLine();\n                    if (line == null) {\n                        return callback && callback(this);\n                    }\n                    line = line.trim();\n                    if (line.length == 0)\n                        page = null;\n                    else if (!page) {\n                        page = new TextureAtlasPage();\n                        page.name = line;\n\n                        if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\n                            page.width = parseInt(tuple[0]);\n                            page.height = parseInt(tuple[1]);\n                            reader.readTuple(tuple);\n                        }\n                        // page.format = Format[tuple[0]]; we don't need format in WebGL\n\n                        reader.readTuple(tuple);\n                        page.minFilter = Texture.filterFromString(tuple[0]);\n                        page.magFilter = Texture.filterFromString(tuple[1]);\n\n                        let direction = reader.readValue();\n                        page.uWrap = TextureWrap.ClampToEdge;\n                        page.vWrap = TextureWrap.ClampToEdge;\n                        if (direction == \"x\")\n                            page.uWrap = TextureWrap.Repeat;\n                        else if (direction == \"y\")\n                            page.vWrap = TextureWrap.Repeat;\n                        else if (direction == \"xy\")\n                            page.uWrap = page.vWrap = TextureWrap.Repeat;\n\n                        textureLoader(line, (texture: PIXI.BaseTexture) => {\n                            page.baseTexture = texture;\n                            if (!texture.hasLoaded) {\n                                texture.width = page.width;\n                                texture.height = page.height;\n                            }\n                            this.pages.push(page);\n                            page.setFilters();\n\n                            if (!page.width || !page.height) {\n                                page.width = texture.realWidth;\n                                page.height = texture.realHeight;\n                                if (!page.width || !page.height) {\n                                    console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                                }\n                            }\n                            iterateParser();\n                        });\n                        this.pages.push(page);\n                        break;\n                    } else {\n                        let region: TextureAtlasRegion = new TextureAtlasRegion();\n                        region.name = line;\n                        region.page = page;\n\n                        let rotate: number = reader.readValue() == \"true\" ? 6 : 0;\n\n                        reader.readTuple(tuple);\n                        let x = parseInt(tuple[0]);\n                        let y = parseInt(tuple[1]);\n\n                        reader.readTuple(tuple);\n                        let width = parseInt(tuple[0]);\n                        let height = parseInt(tuple[1]);\n\n                        let resolution = page.baseTexture.resolution;\n                        x /= resolution;\n                        y /= resolution;\n                        width /= resolution;\n                        height /= resolution;\n\n                        let frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n\n                        if (reader.readTuple(tuple) == 4) { // split is optional\n                            // region.splits = new Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\n\n                            if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n                                //region.pads = Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\n\n                                reader.readTuple(tuple);\n                            }\n                        }\n\n                        let originalWidth = parseInt(tuple[0]) / resolution;\n                        let originalHeight = parseInt(tuple[1]) / resolution;\n                        reader.readTuple(tuple);\n                        let offsetX = parseInt(tuple[0]) / resolution;\n                        let offsetY = parseInt(tuple[1]) / resolution;\n\n                        let orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n                        let trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n\n                        //TODO: pixiv3 uses different frame/crop/trim\n\n                        if (PIXI.VERSION[0] != '3') {\n                            // pixi v4 or v5\n                            region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\n                        } else {\n                            // pixi v3.0.11\n                            var frame2 = new PIXI.Rectangle(x, y, width, height);\n                            var crop = frame2.clone();\n                            trim.width = originalWidth;\n                            trim.height = originalHeight;\n                            region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\n                        }\n\n                        region.index = parseInt(reader.readValue());\n                        (region.texture as any)._updateUvs();\n\n                        this.regions.push(region);\n                    }\n                }\n            }\n\n            iterateParser();\n        }\n\n        findRegion(name: string): TextureAtlasRegion {\n            for (let i = 0; i < this.regions.length; i++) {\n                if (this.regions[i].name == name) {\n                    return this.regions[i];\n                }\n            }\n            return null;\n        }\n\n        dispose() {\n            for (let i = 0; i < this.pages.length; i++) {\n                this.pages[i].baseTexture.dispose();\n            }\n        }\n    }\n\n    class TextureAtlasReader {\n        lines: Array<string>;\n        index: number = 0;\n\n        constructor(text: string) {\n            this.lines = text.split(/\\r\\n|\\r|\\n/);\n        }\n\n        readLine(): string {\n            if (this.index >= this.lines.length)\n                return null;\n            return this.lines[this.index++];\n        }\n\n        readValue(): string {\n            let line = this.readLine();\n            let colon = line.indexOf(\":\");\n            if (colon == -1)\n                throw new Error(\"Invalid line: \" + line);\n            return line.substring(colon + 1).trim();\n        }\n\n        readTuple(tuple: Array<string>): number {\n            let line = this.readLine();\n            let colon = line.indexOf(\":\");\n            if (colon == -1)\n                throw new Error(\"Invalid line: \" + line);\n            let i = 0, lastMatch = colon + 1;\n            for (; i < 3; i++) {\n                let comma = line.indexOf(\",\", lastMatch);\n                if (comma == -1) break;\n                tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n                lastMatch = comma + 1;\n            }\n            tuple[i] = line.substring(lastMatch).trim();\n            return i + 1;\n        }\n    }\n\n    export class TextureAtlasPage {\n        name: string;\n        minFilter: TextureFilter;\n        magFilter: TextureFilter;\n        uWrap: TextureWrap;\n        vWrap: TextureWrap;\n        baseTexture: PIXI.BaseTexture;\n        width: number;\n        height: number;\n\n        public setFilters() {\n            let tex = this.baseTexture;\n            let filter = this.minFilter;\n            if (filter == TextureFilter.Linear) {\n                tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n            } else if (this.minFilter == TextureFilter.Nearest) {\n                tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n            } else {\n                tex.mipmap = true;\n                if (filter == TextureFilter.MipMapNearestNearest) {\n                    tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n                } else {\n                    tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n                }\n            }\n        }\n    }\n\n    export class TextureAtlasRegion extends TextureRegion {\n        page: TextureAtlasPage;\n        name: string;\n        index: number;\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class TransformConstraint implements Constraint {\n        data: TransformConstraintData;\n        bones: Array<Bone>;\n        target: Bone;\n        rotateMix = 0;\n        translateMix = 0;\n        scaleMix = 0;\n        shearMix = 0;\n        temp = new Vector2();\n\n        constructor(data: TransformConstraintData, skeleton: Skeleton) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.rotateMix = data.rotateMix;\n            this.translateMix = data.translateMix;\n            this.scaleMix = data.scaleMix;\n            this.shearMix = data.shearMix;\n            this.bones = new Array<Bone>();\n            for (let i = 0; i < data.bones.length; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findBone(data.target.name);\n        }\n\n        apply() {\n            this.update();\n        }\n\n        update() {\n            if (this.data.local) {\n                if (this.data.relative)\n                    this.applyRelativeLocal();\n                else\n                    this.applyAbsoluteLocal();\n\n            } else {\n                if (this.data.relative)\n                    this.applyRelativeWorld();\n                else\n                    this.applyAbsoluteWorld();\n            }\n        }\n\n        applyAbsoluteWorld() {\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\n                shearMix = this.shearMix;\n            let target = this.target;\n            let targetMat = target.matrix;\n            let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\n            let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n            let offsetRotation = this.data.offsetRotation * degRadReflect;\n            let offsetShearY = this.data.offsetShearY * degRadReflect;\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                let modified = false;\n                let mat = bone.matrix;\n\n                if (rotateMix != 0) {\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n                    let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI)\n                        r += MathUtils.PI2;\n                    r *= rotateMix;\n                    let cos = Math.cos(r), sin = Math.sin(r);\n                    mat.a = cos * a - sin * c;\n                    mat.c = cos * b - sin * d;\n                    mat.b = sin * a + cos * c;\n                    mat.d = sin * b + cos * d;\n                    modified = true;\n                }\n\n                if (translateMix != 0) {\n                    let temp = this.temp;\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                    mat.tx += (temp.x - mat.tx) * translateMix;\n                    mat.ty += (temp.y - mat.ty) * translateMix;\n                    modified = true;\n                }\n\n                if (scaleMix > 0) {\n                    let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                    let ts = Math.sqrt(ta * ta + tc * tc);\n                    if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                    mat.a *= s;\n                    mat.b *= s;\n                    s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                    ts = Math.sqrt(tb * tb + td * td);\n                    if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                    mat.c *= s;\n                    mat.d *= s;\n                    modified = true;\n                }\n\n                if (shearMix > 0) {\n                    let b = mat.c, d = mat.d;\n                    let by = Math.atan2(d, b);\n                    let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI)\n                        r += MathUtils.PI2;\n                    r = by + (r + offsetShearY) * shearMix;\n                    let s = Math.sqrt(b * b + d * d);\n                    mat.c = Math.cos(r) * s;\n                    mat.d = Math.sin(r) * s;\n                    modified = true;\n                }\n\n                if (modified) bone.appliedValid = false;\n            }\n        }\n\n        applyRelativeWorld() {\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\n                shearMix = this.shearMix;\n            let target = this.target;\n            let targetMat = target.matrix;\n            let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\n            let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n            let offsetRotation = this.data.offsetRotation * degRadReflect,\n                offsetShearY = this.data.offsetShearY * degRadReflect;\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                let modified = false;\n                let mat = bone.matrix;\n\n                if (rotateMix != 0) {\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n                    let r = Math.atan2(tc, ta) + offsetRotation;\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                    r *= rotateMix;\n                    let cos = Math.cos(r), sin = Math.sin(r);\n                    mat.a = cos * a - sin * c;\n                    mat.c = cos * b - sin * d;\n                    mat.b = sin * a + cos * c;\n                    mat.d = sin * b + cos * d;\n                    modified = true;\n                }\n\n                if (translateMix != 0) {\n                    let temp = this.temp;\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                    mat.tx += temp.x * translateMix;\n                    mat.ty += temp.y * translateMix;\n                    modified = true;\n                }\n\n                if (scaleMix > 0) {\n                    let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                    mat.a *= s;\n                    mat.b *= s;\n                    s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                    mat.c *= s;\n                    mat.d *= s;\n                    modified = true;\n                }\n\n                if (shearMix > 0) {\n                    let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                    let b = mat.c, d = mat.d;\n                    r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n                    let s = Math.sqrt(b * b + d * d);\n                    mat.c = Math.cos(r) * s;\n                    mat.d = Math.sin(r) * s;\n                    modified = true;\n                }\n\n                if (modified) bone.appliedValid = false;\n            }\n        }\n\n        applyAbsoluteLocal() {\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\n                shearMix = this.shearMix;\n            let target = this.target;\n            if (!target.appliedValid) target.updateAppliedTransform();\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (!bone.appliedValid) bone.updateAppliedTransform();\n\n                let rotation = bone.arotation;\n                if (rotateMix != 0) {\n                    let r = target.arotation - rotation + this.data.offsetRotation;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                    rotation += r * rotateMix;\n                }\n\n                let x = bone.ax, y = bone.ay;\n                if (translateMix != 0) {\n                    x += (target.ax - x + this.data.offsetX) * translateMix;\n                    y += (target.ay - y + this.data.offsetY) * translateMix;\n                }\n\n                let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n                if (scaleMix > 0) {\n                    if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                    if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n                }\n\n                let shearY = bone.ashearY;\n                if (shearMix > 0) {\n                    let r = target.ashearY - shearY + this.data.offsetShearY;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                    bone.shearY += r * shearMix;\n                }\n\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n            }\n        }\n\n        applyRelativeLocal() {\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\n                shearMix = this.shearMix;\n            let target = this.target;\n            if (!target.appliedValid) target.updateAppliedTransform();\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (!bone.appliedValid) bone.updateAppliedTransform();\n\n                let rotation = bone.arotation;\n                if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n\n                let x = bone.ax, y = bone.ay;\n                if (translateMix != 0) {\n                    x += (target.ax + this.data.offsetX) * translateMix;\n                    y += (target.ay + this.data.offsetY) * translateMix;\n                }\n\n                let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n                if (scaleMix > 0) {\n                    if (scaleX > 0.00001) scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\n                    if (scaleY > 0.00001) scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\n                }\n\n                let shearY = bone.ashearY;\n                if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n            }\n        }\n\n        getOrder() {\n            return this.data.order;\n        }\n    }\n\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class TransformConstraintData {\n        name: string;\n        order = 0;\n        bones = new Array<BoneData>();\n        target: BoneData;\n        rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\n        offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\n        relative = false;\n        local = false;\n\n        constructor (name: string) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport class Triangulator {\n\t\tprivate convexPolygons = new Array<Array<number>>();\n\t\tprivate convexPolygonsIndices = new Array<Array<number>>();\n\n\t\tprivate indicesArray = new Array<number>();\n\t\tprivate isConcaveArray = new Array<boolean>();\n\t\tprivate triangles = new Array<number>();\n\n\t\tprivate polygonPool = new Pool<Array<number>>(() => {\n\t\t\treturn new Array<number>();\n\t\t});\n\n\t\tprivate polygonIndicesPool = new Pool<Array<number>>(() => {\n\t\t\treturn new Array<number>();\n\t\t});\n\n\t\tpublic triangulate (verticesArray: ArrayLike<number>): Array<number> {\n\t\t\tlet vertices = verticesArray;\n\t\t\tlet vertexCount = verticesArray.length >> 1;\n\n\t\t\tlet indices = this.indicesArray;\n\t\t\tindices.length = 0;\n\t\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\t\tindices[i] = i;\n\n\t\t\tlet isConcave = this.isConcaveArray;\n\t\t\tisConcave.length = 0;\n\t\t\tfor (let i = 0, n = vertexCount; i < n; ++i)\n\t\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n\n\t\t\tlet triangles = this.triangles;\n\t\t\ttriangles.length = 0;\n\n\t\t\twhile (vertexCount > 3) {\n\t\t\t\t// Find ear tip.\n\t\t\t\tlet previous = vertexCount - 1, i = 0, next = 1;\n\t\t\t\twhile (true) {\n\t\t\t\t\touter:\n\t\t\t\t\tif (!isConcave[i]) {\n\t\t\t\t\t\tlet p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\n\t\t\t\t\t\tlet p1x = vertices[p1], p1y = vertices[p1 + 1];\n\t\t\t\t\t\tlet p2x = vertices[p2], p2y = vertices[p2 + 1];\n\t\t\t\t\t\tlet p3x = vertices[p3], p3y = vertices[p3 + 1];\n\t\t\t\t\t\tfor (let ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n\t\t\t\t\t\t\tif (!isConcave[ii]) continue;\n\t\t\t\t\t\t\tlet v = indices[ii] << 1;\n\t\t\t\t\t\t\tlet vx = vertices[v], vy = vertices[v + 1];\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n\t\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (next == 0) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (!isConcave[i]) break;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t} while (i > 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tprevious = i;\n\t\t\t\t\ti = next;\n\t\t\t\t\tnext = (next + 1) % vertexCount;\n\t\t\t\t}\n\n\t\t\t\t// Cut ear tip.\n\t\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n\t\t\t\ttriangles.push(indices[i]);\n\t\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\n\t\t\t\tindices.splice(i, 1);\n\t\t\t\tisConcave.splice(i, 1);\n\t\t\t\tvertexCount--;\n\n\t\t\t\tlet previousIndex = (vertexCount + i - 1) % vertexCount;\n\t\t\t\tlet nextIndex = i == vertexCount ? 0 : i;\n\t\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n\t\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n\t\t\t}\n\n\t\t\tif (vertexCount == 3) {\n\t\t\t\ttriangles.push(indices[2]);\n\t\t\t\ttriangles.push(indices[0]);\n\t\t\t\ttriangles.push(indices[1]);\n\t\t\t}\n\n\t\t\treturn triangles;\n\t\t}\n\n\t\tdecompose (verticesArray: Array<number>, triangles: Array<number>) : Array<Array<number>> {\n\t\t\tlet vertices = verticesArray;\n\t\t\tlet convexPolygons = this.convexPolygons;\n\t\t\tthis.polygonPool.freeAll(convexPolygons);\n\t\t\tconvexPolygons.length = 0;\n\n\t\t\tlet convexPolygonsIndices = this.convexPolygonsIndices;\n\t\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\n\t\t\tconvexPolygonsIndices.length = 0;\n\n\t\t\tlet polygonIndices = this.polygonIndicesPool.obtain();\n\t\t\tpolygonIndices.length = 0;\n\n\t\t\tlet polygon = this.polygonPool.obtain();\n\t\t\tpolygon.length = 0;\n\n\t\t\t// Merge subsequent triangles if they form a triangle fan.\n\t\t\tlet fanBaseIndex = -1, lastWinding = 0;\n\t\t\tfor (let i = 0, n = triangles.length; i < n; i += 3) {\n\t\t\t\tlet t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\n\t\t\t\tlet x1 = vertices[t1], y1 = vertices[t1 + 1];\n\t\t\t\tlet x2 = vertices[t2], y2 = vertices[t2 + 1];\n\t\t\t\tlet x3 = vertices[t3], y3 = vertices[t3 + 1];\n\n\t\t\t\t// If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).\n\t\t\t\tlet merged = false;\n\t\t\t\tif (fanBaseIndex == t1) {\n\t\t\t\t\tlet o = polygon.length - 4;\n\t\t\t\t\tlet winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n\t\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n\t\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\n\t\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\t\t\tmerged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise make this triangle the new base.\n\t\t\t\tif (!merged) {\n\t\t\t\t\tif (polygon.length > 0) {\n\t\t\t\t\t\tconvexPolygons.push(polygon);\n\t\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.polygonPool.free(polygon)\n\t\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t\t\t}\n\t\t\t\t\tpolygon = this.polygonPool.obtain();\n\t\t\t\t\tpolygon.length = 0;\n\t\t\t\t\tpolygon.push(x1);\n\t\t\t\t\tpolygon.push(y1);\n\t\t\t\t\tpolygon.push(x2);\n\t\t\t\t\tpolygon.push(y2);\n\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\n\t\t\t\t\tpolygonIndices.length = 0;\n\t\t\t\t\tpolygonIndices.push(t1);\n\t\t\t\t\tpolygonIndices.push(t2);\n\t\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n\t\t\t\t\tfanBaseIndex = t1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (polygon.length > 0) {\n\t\t\t\tconvexPolygons.push(polygon);\n\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t\t}\n\n\t\t\t// Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.\n\t\t\tfor (let i = 0, n = convexPolygons.length; i < n; i++) {\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\n\t\t\t\tif (polygonIndices.length == 0) continue;\n\t\t\t\tlet firstIndex = polygonIndices[0];\n\t\t\t\tlet lastIndex = polygonIndices[polygonIndices.length - 1];\n\n\t\t\t\tpolygon = convexPolygons[i];\n\t\t\t\tlet o = polygon.length - 4;\n\t\t\t\tlet prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\n\t\t\t\tlet prevX = polygon[o + 2], prevY = polygon[o + 3];\n\t\t\t\tlet firstX = polygon[0], firstY = polygon[1];\n\t\t\t\tlet secondX = polygon[2], secondY = polygon[3];\n\t\t\t\tlet winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n\n\t\t\t\tfor (let ii = 0; ii < n; ii++) {\n\t\t\t\t\tif (ii == i) continue;\n\t\t\t\t\tlet otherIndices = convexPolygonsIndices[ii];\n\t\t\t\t\tif (otherIndices.length != 3) continue;\n\t\t\t\t\tlet otherFirstIndex = otherIndices[0];\n\t\t\t\t\tlet otherSecondIndex = otherIndices[1];\n\t\t\t\t\tlet otherLastIndex = otherIndices[2];\n\n\t\t\t\t\tlet otherPoly = convexPolygons[ii];\n\t\t\t\t\tlet x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\n\n\t\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\n\t\t\t\t\tlet winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n\t\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n\t\t\t\t\tif (winding1 == winding && winding2 == winding) {\n\t\t\t\t\t\totherPoly.length = 0;\n\t\t\t\t\t\totherIndices.length = 0;\n\t\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\t\tpolygonIndices.push(otherLastIndex);\n\t\t\t\t\t\tprevPrevX = prevX;\n\t\t\t\t\t\tprevPrevY = prevY;\n\t\t\t\t\t\tprevX = x3;\n\t\t\t\t\t\tprevY = y3;\n\t\t\t\t\t\tii = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove empty polygons that resulted from the merge step above.\n\t\t\tfor (let i = convexPolygons.length - 1; i >= 0; i--) {\n\t\t\t\tpolygon = convexPolygons[i];\n\t\t\t\tif (polygon.length == 0) {\n\t\t\t\t\tconvexPolygons.splice(i, 1);\n\t\t\t\t\tthis.polygonPool.free(polygon);\n\t\t\t\t\tpolygonIndices = convexPolygonsIndices[i]\n\t\t\t\t\tconvexPolygonsIndices.splice(i, 1)\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn convexPolygons;\n\t\t}\n\n\t\tprivate static isConcave (index: number, vertexCount: number, vertices: ArrayLike<number>, indices: ArrayLike<number>): boolean {\n\t\t\tlet previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n\t\t\tlet current = indices[index] << 1;\n\t\t\tlet next = indices[(index + 1) % vertexCount] << 1;\n\t\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next],\n\t\t\t\tvertices[next + 1]);\n\t\t}\n\n\t\tprivate static positiveArea (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): boolean {\n\t\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n\t\t}\n\n\t\tprivate static winding (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): number {\n\t\t\tlet px = p2x - p1x, py = p2y - p1y;\n\t\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n\t\t}\n\t}\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface Updatable {\n        update(): void;\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface Map<T> {\n        [key: string]: T;\n    }\n\n    export class IntSet {\n        array = new Array<number>();\n\n        add (value: number): boolean {\n            let contains = this.contains(value);\n            this.array[value | 0] = value | 0;\n            return !contains;\n        }\n\n        contains (value: number) {\n            return this.array[value | 0] != undefined;\n        }\n\n        remove (value: number) {\n            this.array[value | 0] = undefined;\n        }\n\n        clear () {\n            this.array.length = 0;\n        }\n    }\n\n    export interface Disposable {\n        dispose (): void;\n    }\n\n    export interface Restorable {\n        restore (): void;\n    }\n\n    export class Color {\n        public static WHITE = new Color(1, 1, 1, 1);\n        public static RED = new Color(1, 0, 0, 1);\n        public static GREEN = new Color(0, 1, 0, 1);\n        public static BLUE = new Color(0, 0, 1, 1);\n        public static MAGENTA = new Color(1, 0, 1, 1);\n\n        constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\n        }\n\n        set (r: number, g: number, b: number, a: number) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a;\n            this.clamp();\n            return this;\n        }\n\n        setFromColor (c: Color) {\n            this.r = c.r;\n            this.g = c.g;\n            this.b = c.b;\n            this.a = c.a;\n            return this;\n        }\n\n        setFromString (hex: string) {\n            hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n            this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n            this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n            this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n            this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n            return this;\n        }\n\n        add (r: number, g: number, b: number, a: number) {\n            this.r += r;\n            this.g += g;\n            this.b += b;\n            this.a += a;\n            this.clamp();\n            return this;\n        }\n\n        clamp () {\n            if (this.r < 0) this.r = 0;\n            else if (this.r > 1) this.r = 1;\n\n            if (this.g < 0) this.g = 0;\n            else if (this.g > 1) this.g = 1;\n\n            if (this.b < 0) this.b = 0;\n            else if (this.b > 1) this.b = 1;\n\n            if (this.a < 0) this.a = 0;\n            else if (this.a > 1) this.a = 1;\n            return this;\n        }\n    }\n\n    export class MathUtils {\n        static PI = 3.1415927;\n        static PI2 = MathUtils.PI * 2;\n        static radiansToDegrees = 180 / MathUtils.PI;\n        static radDeg = MathUtils.radiansToDegrees;\n        static degreesToRadians = MathUtils.PI / 180;\n        static degRad = MathUtils.degreesToRadians;\n\n        static clamp (value: number, min: number, max: number) {\n            if (value < min) return min;\n            if (value > max) return max;\n            return value;\n        }\n\n        static cosDeg (degrees: number) {\n            return Math.cos(degrees * MathUtils.degRad);\n        }\n\n        static sinDeg (degrees: number) {\n            return Math.sin(degrees * MathUtils.degRad);\n        }\n\n        static signum (value: number): number {\n            return value > 0 ? 1 : value < 0 ? -1 : 0;\n        }\n\n        static toInt (x: number) {\n            return x > 0 ? Math.floor(x) : Math.ceil(x);\n        }\n\n        static cbrt (x: number) {\n            let y = Math.pow(Math.abs(x), 1/3);\n            return x < 0 ? -y : y;\n        }\n\n        static randomTriangular (min: number, max: number): number {\n            return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n        }\n\n        static randomTriangularWith (min: number, max: number, mode: number): number {\n            let u = Math.random();\n            let d = max - min;\n            if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n            return max - Math.sqrt((1 - u) * d * (max - mode));\n        }\n    }\n\n    export abstract class Interpolation {\n        protected abstract applyInternal (a: number): number;\n        apply(start: number, end: number, a: number): number {\n            return start + (end - start) * this.applyInternal(a);\n        }\n    }\n\n    export class Pow extends Interpolation {\n        protected power = 2;\n\n        constructor (power: number) {\n            super();\n            this.power = power;\n        }\n\n        applyInternal (a: number): number {\n            if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n            return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n        }\n    }\n\n    export class PowOut extends Pow {\n        constructor (power: number) {\n            super(power);\n        }\n\n        applyInternal (a: number) : number {\n            return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n        }\n    }\n\n    export class Utils {\n        static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\n\n        static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n            for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n                dest[j] = source[i];\n            }\n        }\n\n        static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n            let oldSize = array.length;\n            if (oldSize == size) return array;\n            array.length = size;\n            if (oldSize < size) {\n                for (let i = oldSize; i < size; i++) array[i] = value;\n            }\n            return array;\n        }\n\n        static ensureArrayCapacity<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n            if (array.length >= size) return array;\n            return Utils.setArraySize(array, size, value);\n        }\n\n        static newArray<T> (size: number, defaultValue: T): Array<T> {\n            let array = new Array<T>(size);\n            for (let i = 0; i < size; i++) array[i] = defaultValue;\n            return array;\n        }\n\n        static newFloatArray (size: number): ArrayLike<number> {\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                return new Float32Array(size)\n            } else {\n                let array = new Array<number>(size);\n                for (let i = 0; i < array.length; i++) array[i] = 0;\n                return array;\n            }\n        }\n\n        static newShortArray (size: number): ArrayLike<number> {\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                return new Int16Array(size)\n            } else {\n                let array = new Array<number>(size);\n                for (let i = 0; i < array.length; i++) array[i] = 0;\n                return array;\n            }\n        }\n\n        static toFloatArray (array: Array<number>) {\n            return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n        }\n\n        static toSinglePrecision (value: number) {\n            return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n        }\n    }\n\n    export class DebugUtils {\n        static logBones(skeleton: Skeleton) {\n            for (let i = 0; i < skeleton.bones.length; i++) {\n                let bone = skeleton.bones[i];\n                let mat = bone.matrix;\n                console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\n            }\n        }\n    }\n\n    export class Pool<T> {\n        private items = new Array<T>();\n        private instantiator: () => T;\n\n        constructor (instantiator: () => T) {\n            this.instantiator = instantiator;\n        }\n\n        obtain () {\n            return this.items.length > 0 ? this.items.pop() : this.instantiator();\n        }\n\n        free (item: T) {\n            if ((item as any).reset) (item as any).reset();\n            this.items.push(item);\n        }\n\n        freeAll (items: ArrayLike<T>) {\n            for (let i = 0; i < items.length; i++) {\n                if ((items[i] as any).reset) (items[i] as any).reset();\n                this.items[i] = items[i];\n            }\n        }\n\n        clear () {\n            this.items.length = 0;\n        }\n    }\n\n    export class Vector2 {\n        constructor (public x = 0, public y = 0) {\n        }\n\n        set (x: number, y: number): Vector2 {\n            this.x = x;\n            this.y = y;\n            return this;\n        }\n\n        length () {\n            let x = this.x;\n            let y = this.y;\n            return Math.sqrt(x * x + y * y);\n        }\n\n        normalize () {\n            let len = this.length();\n            if (len != 0) {\n                this.x /= len;\n                this.y /= len;\n            }\n            return this;\n        }\n    }\n\n    export class TimeKeeper {\n        maxDelta = 0.064;\n        framesPerSecond = 0;\n        delta = 0;\n        totalTime = 0;\n\n        private lastTime = Date.now() / 1000;\n        private frameCount = 0;\n        private frameTime = 0;\n\n        update () {\n            var now = Date.now() / 1000;\n            this.delta = now - this.lastTime;\n            this.frameTime += this.delta;\n            this.totalTime += this.delta;\n            if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n            this.lastTime = now;\n\n            this.frameCount++;\n            if (this.frameTime > 1) {\n                this.framesPerSecond = this.frameCount / this.frameTime;\n                this.frameTime = 0;\n                this.frameCount = 0;\n            }\n        }\n    }\n\n    export interface ArrayLike<T> {\n        length: number;\n        [n: number]: T;\n    }\n\n    export class WindowedMean {\n        values: Array<number>;\n        addedValues = 0;\n        lastValue = 0;\n        mean = 0;\n        dirty = true;\n\n        constructor (windowSize: number = 32) {\n            this.values = new Array<number>(windowSize);\n        }\n\n        hasEnoughData () {\n            return this.addedValues >= this.values.length;\n        }\n\n        addValue (value: number) {\n            if (this.addedValues < this.values.length)\n                this.addedValues++;\n            this.values[this.lastValue++] = value;\n            if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n            this.dirty = true;\n        }\n\n        getMean () {\n            if (this.hasEnoughData()) {\n                if (this.dirty) {\n                    let mean = 0;\n                    for (let i = 0; i < this.values.length; i++) {\n                        mean += this.values[i];\n                    }\n                    this.mean = mean / this.values.length;\n                    this.dirty = false;\n                }\n                return this.mean;\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport interface VertexEffect {\n\t\tbegin(skeleton: Skeleton): void;\n\t\ttransform(position: Vector2, uv: Vector2, light: Color, dark: Color): void;\n\t\tend(): void;\n\t}\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport class JitterEffect implements VertexEffect {\n\t\tjitterX = 0;\n\t\tjitterY = 0;\n\n\t\tconstructor (jitterX: number, jitterY: number) {\n\t\t\tthis.jitterX = jitterX;\n\t\t\tthis.jitterY = jitterY;\n\t\t}\n\n\t\tbegin(skeleton: Skeleton): void {\n\t\t}\n\n\t\ttransform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n\t\t\tposition.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n\t\t\tposition.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n\t\t}\n\n\t\tend(): void {\n\t\t}\n\t}\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport class SwirlEffect implements VertexEffect {\n\t\tstatic interpolation = new PowOut(2);\n\t\tcenterX = 0;\n\t\tcenterY = 0;\n\t\tradius = 0;\n\t\tangle = 0;\n\t\tprivate worldX = 0;\n\t\tprivate worldY = 0;\n\n\t\tconstructor (radius: number) {\n\t\t\tthis.radius = radius;\n\t\t}\n\n\t\tbegin(skeleton: Skeleton): void {\n\t\t\tthis.worldX = skeleton.x + this.centerX;\n\t\t\tthis.worldY = skeleton.y + this.centerY;\n\t\t}\n\n\t\ttransform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n\t\t\tlet radAngle = this.angle * MathUtils.degreesToRadians;\n\t\t\tlet x = position.x - this.worldX;\n\t\t\tlet y = position.y - this.worldY;\n\t\t\tlet dist = Math.sqrt(x * x + y * y);\n\t\t\tif (dist < this.radius) {\n\t\t\t\tlet theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n\t\t\t\tlet cos = Math.cos(theta);\n\t\t\t\tlet sin = Math.sin(theta);\n\t\t\t\tposition.x = cos * x - sin * y + this.worldX;\n\t\t\t\tposition.y = sin * x + cos * y + this.worldY;\n\t\t\t}\n\t\t}\n\n\t\tend(): void {\n\t\t}\n\t}\n}\nnamespace pixi_spine {\n    function isJson(resource: PIXI.loaders.Resource) {\n        var TYPE = (PIXI.loaders.Resource as any).TYPE;\n        if (TYPE) {\n            return (resource as any).type === TYPE.JSON\n        }\n        return resource.isJson;\n    }\n\n    export function atlasParser() {\n        return function (resource: PIXI.loaders.Resource, next: () => any) {\n            // skip if no data, its not json, or it isn't atlas data\n            if (!resource.data ||\n                !isJson(resource) ||\n                !resource.data.bones) {\n                return next();\n            }\n            const metadata = resource.metadata || {};\n            const metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;\n\n            const metadataAtlas = metadata ? resource.metadata.spineAtlas : null;\n            if (metadataAtlas === false) {\n                return next();\n            }\n            if (metadataAtlas && metadataAtlas.pages) {\n                //its an atlas!\n                var spineJsonParser = new core.SkeletonJson(new core.AtlasAttachmentLoader(metadataAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n                resource.spineData = skeletonData;\n                resource.spineAtlas = metadataAtlas;\n\n                return next();\n            }\n\n            const metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\n\n            /**\n             * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n             * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n             * have the same name\n             */\n            let atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\n            //remove the baseUrl\n            atlasPath = atlasPath.replace(this.baseUrl, '');\n\n            const atlasOptions = {\n                crossOrigin: resource.crossOrigin,\n                xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n                metadata: metadata.spineMetadata || null,\n                parentResource: resource\n            };\n            const imageOptions = {\n                crossOrigin: resource.crossOrigin,\n                metadata: metadata.imageMetadata || null,\n                parentResource: resource\n            };\n            let baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n            //remove the baseUrl\n            baseUrl = baseUrl.replace(this.baseUrl, '');\n\n            const adapter = metadata.images ? staticImageLoader(metadata.images)\n                : metadata.image ? staticImageLoader({'default': metadata.image})\n                : metadata.imageLoader ? metadata.imageLoader(this, resource.name + '_atlas_page_', baseUrl, imageOptions)\n                    : imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n\n            this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource: PIXI.loaders.Resource) {\n                new core.TextureAtlas(atlasResource.xhr.responseText, adapter, function (spineAtlas) {\n                    let spineJsonParser = new core.SkeletonJson(new core.AtlasAttachmentLoader(spineAtlas));\n                    if (metadataSkeletonScale) {\n                        spineJsonParser.scale = metadataSkeletonScale;\n                    }\n                    resource.spineData = spineJsonParser.readSkeletonData(resource.data);\n                    resource.spineAtlas = spineAtlas;\n\n                    next();\n                });\n            });\n        };\n    }\n\n    export function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\n            baseUrl += '/';\n        }\n        return function (line: string, callback: (baseTexture: PIXI.BaseTexture) => any) {\n            const name = namePrefix + line;\n            const url = baseUrl + line;\n            loader.add(name, url, imageOptions, (resource: PIXI.loaders.Resource) => {\n                callback(resource.texture.baseTexture);\n            });\n        }\n    }\n\n    export function syncImageLoaderAdapter(baseUrl: any, crossOrigin: any) {\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\n            baseUrl += '/';\n        }\n        return function (line: any, callback: any) {\n            callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n        }\n    }\n\n    export function staticImageLoader(pages: { [key: string]: (PIXI.BaseTexture | PIXI.Texture) }) {\n        return function (line: any, callback: any) {\n            let page = pages[line] || pages['default'] as any;\n            if (page && page.baseTexture)\n                callback(page.baseTexture);\n            else\n                callback(page);\n        }\n    }\n\n    PIXI.loaders.Loader.addPixiMiddleware(atlasParser);\n    PIXI.loader.use(atlasParser());\n}\ninterface Math {\n    fround(n: number): number;\n}\n\n(() => {\n    if (!Math.fround) {\n        Math.fround = Math.fround = (function(array) {\n            return function(x: number) {\n                return array[0] = x, array[0];\n            };\n        })(new Float32Array(1));\n    }\n})();\n/// <reference types=\"pixi.js\" />\n/// <reference path=\"polyfills.ts\" />\nnamespace pixi_spine {\n    /* Esoteric Software SPINE wrapper for pixi.js */\n    core.Bone.yDown = true;\n\n    let tempRgb = [0, 0, 0];\n\n    export class SpineSprite extends PIXI.Sprite {\n        region: core.TextureRegion;\n\n        constructor(tex: PIXI.Texture) {\n            super(tex);\n        }\n    }\n\n    export class SpineMesh extends PIXI.mesh.Mesh {\n        region: core.TextureRegion;\n\n        constructor(texture: PIXI.Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\n            super(texture, vertices, uvs, indices, drawMode);\n        }\n    }\n\n    /**\n     * A class that enables the you to import and run your spine animations in pixi.\n     * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n     * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n     *\n     * ```js\n     * let spineAnimation = new spine(spineData);\n     * ```\n     *\n     * @class\n     * @extends Container\n     * @memberof spine\n     * @param spineData {object} The spine data loaded from a spine atlas.\n     */\n    export class Spine extends PIXI.Container {\n        static globalAutoUpdate: boolean = true;\n\n        tintRgb: ArrayLike<number>;\n        spineData: core.SkeletonData;\n        skeleton: core.Skeleton;\n        stateData: core.AnimationStateData;\n        state: core.AnimationState;\n        slotContainers: Array<PIXI.Container>;\n        tempClipContainers: Array<PIXI.Container>;\n\n        constructor(spineData: core.SkeletonData) {\n            super();\n\n            if (!spineData) {\n                throw new Error('The spineData param is required.');\n            }\n\n            if ((typeof spineData) === \"string\") {\n                throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n            }\n\n            /**\n             * The spineData object\n             *\n             * @member {object}\n             */\n            this.spineData = spineData;\n\n            /**\n             * A spine Skeleton object\n             *\n             * @member {object}\n             */\n            this.skeleton = new core.Skeleton(spineData);\n            this.skeleton.updateWorldTransform();\n\n            /**\n             * A spine AnimationStateData object created from the spine data passed in the constructor\n             *\n             * @member {object}\n             */\n            this.stateData = new core.AnimationStateData(spineData);\n\n            /**\n             * A spine AnimationState object created from the spine AnimationStateData object\n             *\n             * @member {object}\n             */\n            this.state = new core.AnimationState(this.stateData);\n\n            /**\n             * An array of containers\n             *\n             * @member {Container[]}\n             */\n            this.slotContainers = [];\n\n            this.tempClipContainers = [];\n\n            for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n                let slot = this.skeleton.slots[i];\n                let attachment: any = slot.attachment;\n                let slotContainer = new PIXI.Container();\n                this.slotContainers.push(slotContainer);\n                this.addChild(slotContainer);\n                this.tempClipContainers.push(null);\n\n                if (attachment instanceof core.RegionAttachment) {\n                    let spriteName = (attachment.region as core.TextureAtlasRegion).name;\n                    let sprite = this.createSprite(slot, attachment, spriteName);\n                    slot.currentSprite = sprite;\n                    slot.currentSpriteName = spriteName;\n                    slotContainer.addChild(sprite);\n                }\n                else if (attachment instanceof core.MeshAttachment) {\n                    let mesh = this.createMesh(slot, attachment);\n                    slot.currentMesh = mesh;\n                    slot.currentMeshName = attachment.name;\n                    slotContainer.addChild(mesh);\n                }\n                else if (attachment instanceof core.ClippingAttachment) {\n                    this.createGraphics(slot, attachment);\n                    slotContainer.addChild(slot.clippingContainer);\n                    slotContainer.addChild(slot.currentGraphics);\n                }\n                else {\n                    continue;\n                }\n\n            }\n\n            /**\n             * Should the Spine object update its transforms\n             *\n             * @member {boolean}\n             */\n            this.autoUpdate = true;\n\n            /**\n             * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n             *\n             * @member {number}\n             * @memberof spine.Spine#\n             */\n            this.tintRgb = new Float32Array([1, 1, 1]);\n        }\n\n        /**\n         * If this flag is set to true, the spine animation will be autoupdated every time\n         * the object id drawn. The down side of this approach is that the delta time is\n         * automatically calculated and you could miss out on cool effects like slow motion,\n         * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n         * autoupdate enabled but are harder to achieve.\n         *\n         * @member {boolean}\n         * @memberof spine.Spine#\n         * @default true\n         */\n        get autoUpdate(): boolean {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        }\n\n        set autoUpdate(value: boolean) {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n\n        /**\n         * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof spine.Spine#\n         * @default 0xFFFFFF\n         */\n        get tint(): number {\n            return PIXI.utils.rgb2hex(this.tintRgb as any);\n        }\n\n        set tint(value: number) {\n            this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb as any);\n        }\n\n        /**\n         * Update the spine skeleton and its animations by delta time (dt)\n         *\n         * @param dt {number} Delta time. Time by which the animation should be updated\n         */\n        update(dt: number) {\n            this.state.update(dt);\n            this.state.apply(this.skeleton);\n            this.skeleton.updateWorldTransform();\n\n            let slots = this.skeleton.slots;\n\n            let r0 = this.tintRgb[0];\n            let g0 = this.tintRgb[1];\n            let b0 = this.tintRgb[2];\n\n            for (let i = 0, n = slots.length; i < n; i++) {\n                let slot = slots[i];\n                let attachment = slot.attachment;\n                let slotContainer = this.slotContainers[i];\n\n                if (!attachment) {\n                    slotContainer.visible = false;\n                    continue;\n                }\n\n                let attColor = (attachment as any).color;\n                if (attachment instanceof core.RegionAttachment) {\n                    let region = (attachment as core.RegionAttachment).region;\n                    if (region) {\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                            slot.currentMesh = null;\n                            slot.currentMeshName = undefined;\n                        }\n                        let ar = region as core.TextureAtlasRegion;\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n                            let spriteName = ar.name;\n                            if (slot.currentSprite) {\n                                slot.currentSprite.visible = false;\n                            }\n                            slot.sprites = slot.sprites || {};\n                            if (slot.sprites[spriteName] !== undefined) {\n                                slot.sprites[spriteName].visible = true;\n                            }\n                            else {\n                                let sprite = this.createSprite(slot, attachment, spriteName);\n                                slotContainer.addChild(sprite);\n                            }\n                            slot.currentSprite = slot.sprites[spriteName];\n                            slot.currentSpriteName = spriteName;\n                        }\n                    }\n\n                    if (slotContainer.transform) {\n                        //TODO: refactor this thing, switch it on and off for container\n                        let transform = slotContainer.transform;\n                        let transAny: any = transform;\n                        let lt: PIXI.Matrix = null;\n                        if (transAny.matrix2d) {\n                            //gameofbombs pixi fork, sorry for that, we really use it :)\n                            lt = transAny.matrix2d;\n                            transAny._dirtyVersion++;\n                            transAny.version = transAny._dirtyVersion;\n                            transAny.isStatic = true;\n                            transAny.operMode = 0;\n                        } else {\n                            if (PIXI.TransformBase) {\n                                if (transAny.position) {\n                                    transform = new PIXI.TransformBase();\n                                    slotContainer.transform = transform;\n                                }\n                                lt = transform.localTransform;\n                            } else {\n                                // if (transAny.autoUpdateLocal) {\n                                //     transAny.autoUpdateLocal = false;\n                                // }\n                                transAny.setFromMatrix(slot.bone.matrix);\n                            }\n                        }\n                        if (lt) {\n                            slot.bone.matrix.copy(lt);\n                        }\n                    } else {\n                        //PIXI v3\n                        let lt = slotContainer.localTransform || new PIXI.Matrix();\n                        slot.bone.matrix.copy(lt);\n                        slotContainer.localTransform = lt;\n                        (slotContainer as any).displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n                    }\n                    tempRgb[0] = r0 * slot.color.r * attColor.r;\n                    tempRgb[1] = g0 * slot.color.g * attColor.g;\n                    tempRgb[2] = b0 * slot.color.b * attColor.b;\n                    slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n                    slot.currentSprite.blendMode = slot.blendMode;\n                }\n                else if (attachment instanceof core.MeshAttachment) {\n                    if (slot.currentSprite) {\n                        //TODO: refactor this thing, switch it on and off for container\n                        slot.currentSprite.visible = false;\n                        slot.currentSprite = null;\n                        slot.currentSpriteName = undefined;\n\n                        if (slotContainer.transform) {\n                            slotContainer.transform = new PIXI.TransformStatic();\n                        }\n                        else {\n                            slotContainer.localTransform = new PIXI.Matrix();\n                            (slotContainer as any).displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;\n                        }\n                    }\n                    if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                        let meshName = attachment.name;\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                        }\n\n                        slot.meshes = slot.meshes || {};\n\n                        if (slot.meshes[meshName] !== undefined) {\n                            slot.meshes[meshName].visible = true;\n                        }\n                        else {\n                            let mesh = this.createMesh(slot, attachment);\n                            slotContainer.addChild(mesh);\n                        }\n\n                        slot.currentMesh = slot.meshes[meshName];\n                        slot.currentMeshName = meshName;\n                    }\n                    (attachment as core.VertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n                    if (PIXI.VERSION[0] !== '3') {\n                        // PIXI version 4\n                        // slot.currentMesh.dirty++;\n                        //only for PIXI v4\n                        let tintRgb = slot.currentMesh.tintRgb;\n                        tintRgb[0] = r0 * slot.color.r * attColor.r;\n                        tintRgb[1] = g0 * slot.color.g * attColor.g;\n                        tintRgb[2] = b0 * slot.color.b * attColor.b;\n                    }\n                    slot.currentMesh.blendMode = slot.blendMode;\n                }\n                else if (attachment instanceof core.ClippingAttachment) {\n                    if (!slot.currentGraphics) {\n                        this.createGraphics(slot, attachment);\n                        slotContainer.addChild(slot.clippingContainer);\n                        slotContainer.addChild(slot.currentGraphics);\n                    }\n                    this.updateGraphics(slot, attachment);\n                }\n                else {\n                    slotContainer.visible = false;\n                    continue;\n                }\n                slotContainer.visible = true;\n\n                slotContainer.alpha = slot.color.a;\n            }\n\n\n            //== this is clipping implementation ===\n            //TODO: remove parent hacks when pixi masks allow it\n            let drawOrder = this.skeleton.drawOrder;\n            let clippingAttachment: core.ClippingAttachment = null;\n            let clippingContainer: PIXI.Container = null;\n\n            for (let i = 0, n = drawOrder.length; i < n; i++) {\n                let slot = slots[drawOrder[i].data.index];\n                let slotContainer = this.slotContainers[drawOrder[i].data.index];\n\n                if (!clippingContainer) {\n                    if (slotContainer.parent !== this) {\n                        slotContainer.parent.removeChild(slotContainer);\n                        //silend add hack\n                        slotContainer.parent = this;\n                    }\n                }\n                if (slot.currentGraphics) {\n                    clippingContainer = slot.clippingContainer;\n                    clippingAttachment = slot.attachment as core.ClippingAttachment;\n                    clippingContainer.children.length = 0;\n                    this.children[i] = slotContainer;\n\n                    if (clippingAttachment.endSlot == slot.data) {\n                        clippingContainer.renderable = false;\n                        clippingContainer = null;\n                        clippingAttachment = null;\n                    }\n\n                } else {\n                    if (clippingContainer) {\n                        let c = this.tempClipContainers[i];\n                        if (!c) {\n                            c = this.tempClipContainers[i] = new PIXI.Container();\n                            c.visible = false;\n                        }\n                        this.children[i] = c;\n\n                        //silent remove hack\n                        slotContainer.parent = null;\n                        clippingContainer.addChild(slotContainer);\n                        if (clippingAttachment.endSlot == slot.data) {\n                            clippingContainer.renderable = true;\n                            clippingContainer = null;\n                            clippingAttachment = null;\n                        }\n                    } else {\n                        this.children[i] = slotContainer;\n                    }\n                }\n            }\n        };\n\n        private setSpriteRegion(attachment: core.RegionAttachment, sprite: SpineSprite, region: core.TextureRegion) {\n            sprite.region = region;\n            sprite.texture = region.texture;\n            if (!region.size) {\n                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n                sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n            } else {\n                //hacked!\n                sprite.scale.x = region.size.width / region.originalWidth;\n                sprite.scale.y = -region.size.height / region.originalHeight;\n            }\n        }\n\n        private setMeshRegion(attachment: core.MeshAttachment, mesh: SpineMesh, region: core.TextureRegion) {\n            mesh.region = region;\n            mesh.texture = region.texture;\n            attachment.updateUVs(region, mesh.uvs);\n            // if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            // mesh.indexDirty++;\n            // } else {\n            // PIXI version 3\n            mesh.dirty++;\n            // }\n        }\n\n        protected lastTime: number;\n\n        /**\n         * When autoupdate is set to yes this function is used as pixi's updateTransform function\n         *\n         * @private\n         */\n        autoUpdateTransform() {\n            if (Spine.globalAutoUpdate) {\n                this.lastTime = this.lastTime || Date.now();\n                let timeDelta = (Date.now() - this.lastTime) * 0.001;\n                this.lastTime = Date.now();\n                this.update(timeDelta);\n            } else {\n                this.lastTime = 0;\n            }\n\n            PIXI.Container.prototype.updateTransform.call(this);\n        };\n\n        /**\n         * Create a new sprite to be used with core.RegionAttachment\n         *\n         * @param slot {spine.Slot} The slot to which the attachment is parented\n         * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n         * @private\n         */\n        createSprite(slot: core.Slot, attachment: core.RegionAttachment, defName: string) {\n            let region = attachment.region;\n            if (slot.tempAttachment === attachment) {\n                region = slot.tempRegion;\n                slot.tempAttachment = null;\n                slot.tempRegion = null;\n            }\n            let texture = region.texture;\n            let sprite = new SpineSprite(texture);\n            sprite.rotation = attachment.rotation * core.MathUtils.degRad;\n            sprite.anchor.x = 0.5;\n            sprite.anchor.y = 0.5;\n            sprite.position.x = attachment.x;\n            sprite.position.y = attachment.y;\n            sprite.alpha = attachment.color.a;\n\n            sprite.region = attachment.region;\n            this.setSpriteRegion(attachment, sprite, attachment.region);\n\n            slot.sprites = slot.sprites || {};\n            slot.sprites[defName] = sprite;\n            return sprite;\n        };\n\n        /**\n         * Creates a Strip from the spine data\n         * @param slot {spine.Slot} The slot to which the attachment is parented\n         * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n         * @private\n         */\n        createMesh(slot: core.Slot, attachment: core.MeshAttachment) {\n            let region = attachment.region;\n            if (slot.tempAttachment === attachment) {\n                region = slot.tempRegion;\n                slot.tempAttachment = null;\n                slot.tempRegion = null;\n            }\n            let strip = new SpineMesh(\n                region.texture,\n                new Float32Array(attachment.regionUVs.length),\n                new Float32Array(attachment.regionUVs.length),\n                new Uint16Array(attachment.triangles),\n                PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n            strip.canvasPadding = 1.5;\n\n            strip.alpha = attachment.color.a;\n\n            strip.region = attachment.region;\n            this.setMeshRegion(attachment, strip, region);\n\n            slot.meshes = slot.meshes || {};\n            slot.meshes[attachment.name] = strip;\n            return strip;\n        };\n\n        static clippingPolygon: Array<number> = [];\n\n        createGraphics(slot: core.Slot, clip: core.ClippingAttachment) {\n            let graphics = new PIXI.Graphics();\n            let poly = new PIXI.Polygon([]);\n            graphics.clear();\n            graphics.beginFill(0xffffff, 1);\n            graphics.drawPolygon(poly as any);\n            graphics.renderable = false;\n            slot.currentGraphics = graphics;\n            slot.clippingContainer = new PIXI.Container();\n            slot.clippingContainer.mask = slot.currentGraphics;\n\n            return graphics;\n        }\n\n        updateGraphics(slot: core.Slot, clip: core.ClippingAttachment) {\n            let vertices = (slot.currentGraphics.graphicsData[0].shape as PIXI.Polygon).points;\n            let n = clip.worldVerticesLength;\n            vertices.length = n;\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n            slot.currentGraphics.dirty++;\n            slot.currentGraphics.clearDirty++;\n        }\n\n        /**\n         * Changes texture in attachment in specific slot.\n         *\n         * PIXI runtime feature, it was made to satisfy our users.\n         *\n         * @param slotIndex {number}\n         * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n         * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n         * @returns {boolean} Success flag\n         */\n        hackTextureBySlotIndex(slotIndex: number, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n            let slot = this.skeleton.slots[slotIndex];\n            if (!slot) {\n                return false;\n            }\n            let attachment: any = slot.attachment;\n            let region: core.TextureRegion = attachment.region;\n            if (texture) {\n                region = new core.TextureRegion();\n                region.texture = texture;\n                region.size = size;\n            }\n            if (slot.currentSprite && slot.currentSprite.region != region) {\n                this.setSpriteRegion(attachment, slot.currentSprite, region);\n                slot.currentSprite.region = region;\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\n                this.setMeshRegion(attachment, slot.currentMesh, region);\n            } else {\n                slot.tempRegion = region;\n                slot.tempAttachment = attachment;\n            }\n            return true;\n        }\n\n        /**\n         * Changes texture in attachment in specific slot.\n         *\n         * PIXI runtime feature, it was made to satisfy our users.\n         *\n         * @param slotName {string}\n         * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n         * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n         * @returns {boolean} Success flag\n         */\n        hackTextureBySlotName = function (slotName: string, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n            let index = this.skeleton.findSlotIndex(slotName);\n            if (index == -1) {\n                return false;\n            }\n            return this.hackTextureBySlotIndex(index, texture, size);\n        }\n    }\n\n    function SlotContainerUpdateTransformV3() {\n        let pt = this.parent.worldTransform;\n        let wt = this.worldTransform;\n        let lt = this.localTransform;\n        wt.a = lt.a * pt.a + lt.b * pt.c;\n        wt.b = lt.a * pt.b + lt.b * pt.d;\n        wt.c = lt.c * pt.a + lt.d * pt.c;\n        wt.d = lt.c * pt.b + lt.d * pt.d;\n        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n        this._currentBounds = null;\n    }\n}\n(PIXI as any).spine = pixi_spine;\n\n\n\n// WEBPACK FOOTER //\n// ../compilation.ts","module.exports = { \"default\": require(\"core-js/library/fn/math/fround\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/math/fround.js\n// module id = 70\n// module chunks = 0","require('../../modules/es6.math.fround');\nmodule.exports = require('../../modules/_core').Math.fround;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/math/fround.js\n// module id = 71\n// module chunks = 0","// 20.2.2.16 Math.fround(x)\nvar $export   = require('./_export')\n  , sign      = require('./_math-sign')\n  , pow       = Math.pow\n  , EPSILON   = pow(2, -52)\n  , EPSILON32 = pow(2, -23)\n  , MAX32     = pow(2, 127) * (2 - EPSILON32)\n  , MIN32     = pow(2, -126);\n\nvar roundTiesToEven = function(n){\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\n\n$export($export.S, 'Math', {\n  fround: function fround(x){\n    var $abs  = Math.abs(x)\n      , $sign = sign(x)\n      , a, result;\n    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n    a = (1 + EPSILON32 / EPSILON) * $abs;\n    result = a - (a - $abs);\n    if(result > MAX32 || result != result)return $sign * Infinity;\n    return $sign * result;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.math.fround.js\n// module id = 72\n// module chunks = 0","// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x){\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_math-sign.js\n// module id = 73\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/object/create\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/object/create.js\n// module id = 74\n// module chunks = 0","require('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D){\n  return $Object.create(P, D);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/object/create.js\n// module id = 75\n// module chunks = 0","var $export = require('./_export')\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', {create: require('./_object-create')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.object.create.js\n// module id = 76\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/object/set-prototype-of\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/object/set-prototype-of.js\n// module id = 77\n// module chunks = 0","require('../../modules/es6.object.set-prototype-of');\nmodule.exports = require('../../modules/_core').Object.setPrototypeOf;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/object/set-prototype-of.js\n// module id = 78\n// module chunks = 0","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.object.set-prototype-of.js\n// module id = 79\n// module chunks = 0","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object')\n  , anObject = require('./_an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_set-proto.js\n// module id = 80\n// module chunks = 0","var pIE            = require('./_object-pie')\n  , createDesc     = require('./_property-desc')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , has            = require('./_has')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-gopd.js\n// module id = 81\n// module chunks = 0","import loader from './loader'\n\nconst newSpine = (spineName) => {\n    let data = loader.loadSkeleton(spineName)\n    let spine = new PIXI.spine.Spine(data)\n    let setup = ysp.Spine.SETUP[spineName]\n\n    spine.update = function (dt) {\n        // hax: Container shouldn't call this without dt\n        if (dt) {\n            PIXI.spine.Spine.prototype.update.call(this, dt)\n        }\n    }\n\n    if (setup.initAnimation.autoplay) {\n        spine.state.setAnimation(0, setup.initAnimation.name, setup.initAnimation.loop)\n    }\n    spine.skeleton.setSkinByName(setup.skin)\n\n    return spine\n}\n\nconst playAnimation = (spine, animationName, loop) => {\n    spine.state.setAnimation(0, animationName, loop)\n}\n\nconst setSkinByName = (spine, skinName) => {\n    spine.skeleton.setSkinByName(skinName)\n}\n\nexport default {\n    newSpine,\n    playAnimation,\n    setSkinByName,\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Spine/spine.js","module.exports = { \"default\": require(\"core-js/library/fn/promise\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/promise.js\n// module id = 83\n// module chunks = 0","require('../modules/es6.object.to-string');\nrequire('../modules/es6.string.iterator');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.promise');\nmodule.exports = require('../modules/_core').Promise;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/promise.js\n// module id = 84\n// module chunks = 0","'use strict';\nvar LIBRARY            = require('./_library')\n  , global             = require('./_global')\n  , ctx                = require('./_ctx')\n  , classof            = require('./_classof')\n  , $export            = require('./_export')\n  , isObject           = require('./_is-object')\n  , aFunction          = require('./_a-function')\n  , anInstance         = require('./_an-instance')\n  , forOf              = require('./_for-of')\n  , speciesConstructor = require('./_species-constructor')\n  , task               = require('./_task').set\n  , microtask          = require('./_microtask')()\n  , PROMISE            = 'Promise'\n  , TypeError          = global.TypeError\n  , process            = global.process\n  , $Promise           = global[PROMISE]\n  , process            = global.process\n  , isNode             = classof(process) == 'process'\n  , empty              = function(){ /* empty */ }\n  , Internal, GenericPromiseCapability, Wrapper;\n\nvar USE_NATIVE = !!function(){\n  try {\n    // correct subclassing with @@species support\n    var promise     = $Promise.resolve(1)\n      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch(e){ /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n};\nvar isThenable = function(it){\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar newPromiseCapability = function(C){\n  return sameConstructor($Promise, C)\n    ? new PromiseCapability(C)\n    : new GenericPromiseCapability(C);\n};\nvar PromiseCapability = GenericPromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject  = aFunction(reject);\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(promise, isReject){\n  if(promise._n)return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function(){\n    var value = promise._v\n      , ok    = promise._s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , domain  = reaction.domain\n        , result, then;\n      try {\n        if(handler){\n          if(!ok){\n            if(promise._h == 2)onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if(handler === true)result = value;\n          else {\n            if(domain)domain.enter();\n            result = handler(value);\n            if(domain)domain.exit();\n          }\n          if(result === reaction.promise){\n            reject(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if(isReject && !promise._h)onUnhandled(promise);\n  });\n};\nvar onUnhandled = function(promise){\n  task.call(global, function(){\n    var value = promise._v\n      , abrupt, handler, console;\n    if(isUnhandled(promise)){\n      abrupt = perform(function(){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if(abrupt)throw abrupt.error;\n  });\n};\nvar isUnhandled = function(promise){\n  if(promise._h == 1)return false;\n  var chain = promise._a || promise._c\n    , i     = 0\n    , reaction;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar onHandleUnhandled = function(promise){\n  task.call(global, function(){\n    var handler;\n    if(isNode){\n      process.emit('rejectionHandled', promise);\n    } else if(handler = global.onrejectionhandled){\n      handler({promise: promise, reason: promise._v});\n    }\n  });\n};\nvar $reject = function(value){\n  var promise = this;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if(!promise._a)promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function(value){\n  var promise = this\n    , then;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if(promise === value)throw TypeError(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      microtask(function(){\n        var wrapper = {_w: promise, _d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch(e){\n    $reject.call({_w: promise, _d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE){\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor){\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch(err){\n      $reject.call(this, err);\n    }\n  };\n  Internal = function Promise(executor){\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail   = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if(this._a)this._a.push(reaction);\n      if(this._s)notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n  PromiseCapability = function(){\n    var promise  = new Internal;\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject  = ctx($reject, promise, 1);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = newPromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n    var capability = newPromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      var values    = []\n        , index     = 0\n        , remaining = 1;\n      forOf(iterable, false, function(promise){\n        var $index        = index++\n          , alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled  = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.promise.js\n// module id = 86\n// module chunks = 0","module.exports = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_an-instance.js\n// module id = 87\n// module chunks = 0","var ctx         = require('./_ctx')\n  , call        = require('./_iter-call')\n  , isArrayIter = require('./_is-array-iter')\n  , anObject    = require('./_an-object')\n  , toLength    = require('./_to-length')\n  , getIterFn   = require('./core.get-iterator-method')\n  , BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = call(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_for-of.js\n// module id = 88\n// module chunks = 0","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-call.js\n// module id = 89\n// module chunks = 0","// check on default Array iterator\nvar Iterators  = require('./_iterators')\n  , ITERATOR   = require('./_wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_is-array-iter.js\n// module id = 90\n// module chunks = 0","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject  = require('./_an-object')\n  , aFunction = require('./_a-function')\n  , SPECIES   = require('./_wks')('species');\nmodule.exports = function(O, D){\n  var C = anObject(O).constructor, S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_species-constructor.js\n// module id = 91\n// module chunks = 0","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_invoke.js\n// module id = 92\n// module chunks = 0","var global    = require('./_global')\n  , macrotask = require('./_task').set\n  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n  , process   = global.process\n  , Promise   = global.Promise\n  , isNode    = require('./_cof')(process) == 'process';\n\nmodule.exports = function(){\n  var head, last, notify;\n\n  var flush = function(){\n    var parent, fn;\n    if(isNode && (parent = process.domain))parent.exit();\n    while(head){\n      fn   = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch(e){\n        if(head)notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if(parent)parent.enter();\n  };\n\n  // Node.js\n  if(isNode){\n    notify = function(){\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if(Observer){\n    var toggle = true\n      , node   = document.createTextNode('');\n    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n    notify = function(){\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if(Promise && Promise.resolve){\n    var promise = Promise.resolve();\n    notify = function(){\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function(){\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function(fn){\n    var task = {fn: fn, next: undefined};\n    if(last)last.next = task;\n    if(!head){\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_microtask.js\n// module id = 93\n// module chunks = 0","var hide = require('./_hide');\nmodule.exports = function(target, src, safe){\n  for(var key in src){\n    if(safe && target[key])target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_redefine-all.js\n// module id = 94\n// module chunks = 0","'use strict';\nvar global      = require('./_global')\n  , core        = require('./_core')\n  , dP          = require('./_object-dp')\n  , DESCRIPTORS = require('./_descriptors')\n  , SPECIES     = require('./_wks')('species');\n\nmodule.exports = function(KEY){\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_set-species.js\n// module id = 95\n// module chunks = 0","var ITERATOR     = require('./_wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-detect.js\n// module id = 96\n// module chunks = 0","import loader from './loader'\n\nexport default (Scene_Base) => {\n    let _isReady = Scene_Base.prototype.isReady\n    Scene_Base.prototype.isReady = function () {\n        return _isReady.call(this) && loader.isLoaded()\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Spine/scene-base.js"],"sourceRoot":""}