{"version":3,"sources":["webpack:///YSP_Spine.js","webpack:///webpack/bootstrap 6d3fbb4e27190c57ee98","webpack:///./node_modules/core-js/library/modules/_global.js","webpack:///./node_modules/core-js/library/modules/_wks.js","webpack:///./node_modules/core-js/library/modules/_core.js","webpack:///./node_modules/core-js/library/modules/_descriptors.js","webpack:///./node_modules/core-js/library/modules/_hide.js","webpack:///./node_modules/core-js/library/modules/_an-object.js","webpack:///./node_modules/core-js/library/modules/_is-object.js","webpack:///./node_modules/core-js/library/modules/_to-iobject.js","webpack:///./node_modules/core-js/library/modules/_export.js","webpack:///./node_modules/core-js/library/modules/_has.js","webpack:///./node_modules/core-js/library/modules/_iterators.js","webpack:///./node_modules/core-js/library/modules/_object-dp.js","webpack:///./node_modules/core-js/library/modules/_to-integer.js","webpack:///./node_modules/core-js/library/modules/_cof.js","webpack:///./node_modules/core-js/library/modules/_defined.js","webpack:///./node_modules/core-js/library/modules/_ctx.js","webpack:///./node_modules/core-js/library/modules/_fails.js","webpack:///./node_modules/core-js/library/modules/_shared-key.js","webpack:///./node_modules/core-js/library/modules/_a-function.js","webpack:///./node_modules/core-js/library/modules/_dom-create.js","webpack:///./node_modules/core-js/library/modules/_property-desc.js","webpack:///./node_modules/core-js/library/modules/_shared.js","webpack:///./node_modules/core-js/library/modules/_uid.js","webpack:///./node_modules/core-js/library/modules/_enum-bug-keys.js","webpack:///./node_modules/core-js/library/modules/_iobject.js","webpack:///./node_modules/core-js/library/modules/_ie8-dom-define.js","webpack:///./node_modules/core-js/library/modules/_to-primitive.js","webpack:///./node_modules/core-js/library/modules/_object-keys.js","webpack:///./node_modules/core-js/library/modules/_to-length.js","webpack:///./node_modules/core-js/library/modules/_set-to-string-tag.js","webpack:///./node_modules/core-js/library/modules/_iter-define.js","webpack:///./node_modules/core-js/library/modules/_object-keys-internal.js","webpack:///./node_modules/core-js/library/modules/_array-includes.js","webpack:///./node_modules/core-js/library/modules/_to-absolute-index.js","webpack:///./node_modules/core-js/library/modules/_library.js","webpack:///./node_modules/core-js/library/modules/_object-create.js","webpack:///./node_modules/core-js/library/modules/_html.js","webpack:///./node_modules/core-js/library/modules/_to-object.js","webpack:///./node_modules/core-js/library/modules/_classof.js","webpack:///./node_modules/core-js/library/modules/_object-pie.js","webpack:///./node_modules/core-js/library/modules/web.dom.iterable.js","webpack:///./node_modules/core-js/library/modules/es6.array.iterator.js","webpack:///./node_modules/core-js/library/modules/_add-to-unscopables.js","webpack:///./node_modules/core-js/library/modules/_iter-step.js","webpack:///./node_modules/core-js/library/modules/_redefine.js","webpack:///./node_modules/core-js/library/modules/_iter-create.js","webpack:///./node_modules/core-js/library/modules/_object-dps.js","webpack:///./node_modules/core-js/library/modules/_object-gpo.js","webpack:///./node_modules/core-js/library/modules/es6.string.iterator.js","webpack:///./node_modules/core-js/library/modules/_string-at.js","webpack:///./node_modules/core-js/library/modules/core.get-iterator-method.js","webpack:///./src/Spine/loader.js","webpack:///./node_modules/core-js/library/modules/_new-promise-capability.js","webpack:///./node_modules/core-js/library/modules/_species-constructor.js","webpack:///./node_modules/core-js/library/modules/_task.js","webpack:///./node_modules/core-js/library/modules/_perform.js","webpack:///./node_modules/core-js/library/modules/_promise-resolve.js","webpack:///./src/Spine/index.js","webpack:///./node_modules/babel-runtime/core-js/object/assign.js","webpack:///./node_modules/core-js/library/fn/object/assign.js","webpack:///./node_modules/core-js/library/modules/es6.object.assign.js","webpack:///./node_modules/core-js/library/modules/_object-assign.js","webpack:///./node_modules/core-js/library/modules/_object-gops.js","webpack:///../compilation.ts","webpack:///./node_modules/babel-runtime/core-js/math/fround.js","webpack:///./node_modules/core-js/library/fn/math/fround.js","webpack:///./node_modules/core-js/library/modules/es6.math.fround.js","webpack:///./node_modules/core-js/library/modules/_math-fround.js","webpack:///./node_modules/core-js/library/modules/_math-sign.js","webpack:///./node_modules/babel-runtime/core-js/object/create.js","webpack:///./node_modules/core-js/library/fn/object/create.js","webpack:///./node_modules/core-js/library/modules/es6.object.create.js","webpack:///./node_modules/babel-runtime/core-js/object/set-prototype-of.js","webpack:///./node_modules/core-js/library/fn/object/set-prototype-of.js","webpack:///./node_modules/core-js/library/modules/es6.object.set-prototype-of.js","webpack:///./node_modules/core-js/library/modules/_set-proto.js","webpack:///./node_modules/core-js/library/modules/_object-gopd.js","webpack:///./src/Spine/spine.js","webpack:///./node_modules/babel-runtime/core-js/promise.js","webpack:///./node_modules/core-js/library/fn/promise.js","webpack:///./node_modules/core-js/library/modules/es6.promise.js","webpack:///./node_modules/core-js/library/modules/_an-instance.js","webpack:///./node_modules/core-js/library/modules/_for-of.js","webpack:///./node_modules/core-js/library/modules/_iter-call.js","webpack:///./node_modules/core-js/library/modules/_is-array-iter.js","webpack:///./node_modules/core-js/library/modules/_invoke.js","webpack:///./node_modules/core-js/library/modules/_microtask.js","webpack:///./node_modules/core-js/library/modules/_redefine-all.js","webpack:///./node_modules/core-js/library/modules/_set-species.js","webpack:///./node_modules/core-js/library/modules/_iter-detect.js","webpack:///./node_modules/core-js/library/modules/es7.promise.finally.js","webpack:///./node_modules/core-js/library/modules/es7.promise.try.js","webpack:///./src/Spine/scene-base.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","window","Math","self","Function","__g","store","uid","Symbol","USE_SYMBOL","core","version","__e","a","dP","createDesc","key","value","f","isObject","it","TypeError","IObject","defined","ctx","hide","$export","type","source","own","out","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","P","IS_BIND","B","IS_WRAP","W","expProto","target","undefined","C","b","this","arguments","length","apply","virtual","R","U","anObject","IE8_DOM_DEFINE","toPrimitive","O","Attributes","e","ceil","floor","isNaN","toString","slice","aFunction","fn","that","exec","shared","document","is","createElement","bitmap","writable","id","px","random","concat","split","cof","propertyIsEnumerable","val","valueOf","$keys","enumBugKeys","keys","toInteger","min","def","has","TAG","tag","stat","LIBRARY","redefine","Iterators","$iterCreate","setToStringTag","getPrototypeOf","ITERATOR","BUGGY","returnThis","Base","NAME","Constructor","next","DEFAULT","IS_SET","FORCED","methods","IteratorPrototype","getMethod","kind","proto","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","entries","values","toIObject","arrayIndexOf","IE_PROTO","names","result","push","toLength","toAbsoluteIndex","IS_INCLUDES","$this","el","fromIndex","index","max","dPs","Empty","createDict","iframeDocument","iframe","style","display","appendChild","src","contentWindow","open","write","lt","close","create","Properties","documentElement","ARG","tryGet","T","callee","TO_STRING_TAG","DOMIterables","Collection","Array","addToUnscopables","step","iterated","_t","_i","_k","Arguments","done","descriptor","getKeys","defineProperties","toObject","ObjectProto","constructor","$at","String","point","TO_STRING","pos","charCodeAt","charAt","classof","getIteratorMethod","_promise","_promise2","obj","default","raws","spines","filesToLoad","_loadRaw","path","resolve","reject","xhr","XMLHttpRequest","onload","responseText","onerror","statusText","send","_loadTexture","texture","PIXI","BaseTexture","fromImage","on","baseTexture","loadAssets","spineName","setup","ysp","Spine","SETUP","json","then","res","JSON","parse","catch","console","log","atlas","loadSkeleton","rawSkeletonData","rawAtlasData","spineAtlas","spine","TextureAtlas","line","callback","spineAtlasLoader","AtlasAttachmentLoader","spineJsonParser","SkeletonJson","spineData","readSkeletonData","isLoaded","PromiseCapability","promise","$$resolve","$$reject","SPECIES","D","defer","channel","port","invoke","html","cel","process","setTask","setImmediate","clearTask","clearImmediate","MessageChannel","Dispatch","counter","queue","run","listener","event","data","args","nextTick","now","port2","port1","onmessage","postMessage","addEventListener","importScripts","removeChild","setTimeout","set","clear","v","newPromiseCapability","x","promiseCapability","_interopRequireDefault","_assign","_assign2","_spine","_spine2","_loader","_loader2","_sceneBase","_sceneBase2","Scene_Base","loader","assign","gOPS","pIE","$assign","A","K","forEach","k","join","aLen","getSymbols","isEnum","j","getOwnPropertySymbols","pixi_spine","_fround","_fround2","_create","_create2","_setPrototypeOf","_setPrototypeOf2","__extends","extendStatics","__proto__","__","Animation","timelines","duration","Error","skeleton","lastTime","time","loop","events","alpha","pose","direction","binarySearch","low","high","current","linearSearch","last","MixPose","MixDirection","TimelineType","CurveTimeline","frameCount","curves","Utils","newFloatArray","BEZIER_SIZE","getFrameCount","setLinear","frameIndex","LINEAR","setStepped","STEPPED","getCurveType","BEZIER","setCurve","cx1","cy1","cx2","cy2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","y","getCurvePercent","percent","MathUtils","clamp","start","prevX","prevY","RotateTimeline","_super","_this","frames","getPropertyId","rotate","boneIndex","setFrame","degrees","ROTATION","bone","bones","rotation","r_1","ENTRIES","PREV_ROTATION","r_2","frame","prevRotation","frameTime","PREV_TIME","r","TranslateTimeline","translate","X","Y","PREV_X","PREV_Y","ScaleTimeline","scale","scaleX","scaleY","bx","by","abs","signum","ShearTimeline","shear","shearX","shearY","ColorTimeline","color","slotIndex","g","slot","slots","setFromColor","add","PREV_R","PREV_G","PREV_B","PREV_A","TwoColorTimeline","twoColor","r2","g2","b2","R2","G2","B2","darkColor","light","dark","setupLight","setupDark","PREV_R2","PREV_G2","PREV_B2","AttachmentTimeline","attachmentNames","attachment","attachmentName","attachmentName_1","setAttachment","getAttachment","attachmentName_2","zeros","DeformTimeline","frameVertices","deform","vertices","firedEvents","slotAttachment","VertexAttachment","applyDeform","verticesArray","attachmentVertices","vertexCount","setArraySize","vertexAttachment","zeroVertices","arrayCopy","setupVertices","i_1","lastVertices","i_2","i_3","i_4","prevVertices","nextVertices","i_5","prev","i_6","i_7","i_8","EventTimeline","Number","MAX_VALUE","DrawOrderTimeline","drawOrders","drawOrder","drawOrderToSetupIndex","IkConstraintTimeline","ikConstraint","ikConstraintIndex","mix","bendDirection","MIX","BEND_DIRECTION","constraint","ikConstraints","PREV_MIX","PREV_BEND_DIRECTION","in","TransformConstraintTimeline","transformConstraint","transformConstraintIndex","rotateMix","translateMix","scaleMix","shearMix","ROTATE","TRANSLATE","SCALE","SHEAR","transformConstraints","PREV_ROTATE","PREV_TRANSLATE","PREV_SCALE","PREV_SHEAR","PathConstraintPositionTimeline","pathConstraintPosition","pathConstraintIndex","VALUE","pathConstraints","position","PREV_VALUE","PathConstraintSpacingTimeline","pathConstraintSpacing","spacing","PathConstraintMixTimeline","pathConstraintMix","AnimationState","tracks","listeners","EventQueue","propertyIDs","IntSet","mixingTo","animationsChanged","timeScale","trackEntryPool","Pool","TrackEntry","update","delta","animationLast","nextAnimationLast","trackLast","nextTrackLast","currentDelta","delay","nextTime","trackTime","setCurrent","mixingFrom","mixTime","trackEnd","end","disposeNext","updateMixingFrom","from","drain","to","finished","mixDuration","totalAlpha","interruptAlpha","_animationsChanged","applied","currentPose","currentLayered","applyMixingFrom","animationTime","getAnimationTime","timelineCount","animation","ii","timelineData","firstFrame","timelinesRotation","timeline","FIRST","applyRotateTimeline","queueEvents","eventThreshold","attachments","attachmentThreshold","drawOrderThreshold","timelineDipMix","alphaDip","alphaMix","SUBSEQUENT","DIP","dipMix","rotateTimeline","r1","total","diff","lastTotal","lastDiff","dir","entry","animationStart","animationEnd","trackLastWrapped","event_1","complete","clearTracks","oldDrainDisabled","drainDisabled","clearTrack","trackIndex","interrupt","expandToIndex","setAnimation","animationName","skeletonData","findAnimation","setAnimationWith","trackEntry","addAnimation","addAnimationWith","getMix","setEmptyAnimation","emptyAnimation","addEmptyAnimation","setEmptyAnimations","ensureArrayCapacity","obtain","dispose","setTimelineData","getCurrent","addListener","removeListener","indexOf","splice","clearListeners","clearListenerNotifications","setAnimationByName","deprecatedWarning1","warn","addAnimationByName","deprecatedWarning2","hasAnimation","hasAnimationByName","deprecatedWarning3","DIP_MIX","reset","mixingToArray","lastEntry","pop","mixingToLast","timelinesCount","outer","hasTimeline","setAnimationLast","isComplete","resetRotationDirections","loopsCount","animState","objects","EventType","deprecateStuff","onStart","onEnd","free","count","toInt","onComplete","event_3","onEvent","AnimationStateAdapter2","AnimationStateData","animationToMixTime","defaultMix","setMix","fromName","toName","setMixWith","setMixByName","newRegionAttachment","skin","region","findRegion","RegionAttachment","newMeshAttachment","MeshAttachment","newBoundingBoxAttachment","BoundingBoxAttachment","newPathAttachment","PathAttachment","newPointAttachment","PointAttachment","newClippingAttachment","ClippingAttachment","Attachment","nextID","worldVerticesLength","computeWorldVerticesOld","worldVertices","computeWorldVertices","offset","stride","deformArray","skip","skeletonBones","w","wx","wy","mat","matrix","vx","vy","weight","tx","ty","v_1","sourceAttachment","AttachmentType","Color","inheritDeform","tempColor","updateUVs","uvs","regionUVs","_uvs","w1","width","h1","height","w2","originalWidth","h2","originalHeight","offsetX","pixiOffsetY","u","x0","x1","x3","x2","y0","y1","y3","y2","parentMesh","getParentMesh","setParentMesh","triangles","hullLength","closed","constantSpeed","computeWorldPosition","worldX","worldY","computeWorldRotation","cos","cosDeg","sin","sinDeg","atan2","radDeg","updateOffset","regionScaleX","regionScaleY","localX","localY","offsetY","localX2","localY2","radians","PI","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","OX1","OY1","OX2","OY2","OX3","OY3","OX4","OY4","setRegion","v2","u2","vertexOffset","X1","Y1","C1R","C1G","C1B","C1A","U1","V1","X2","Y2","C2R","C2G","C2B","C2A","U2","V2","X3","Y3","C3R","C3G","C3B","C3A","U3","V3","X4","Y4","C4R","C4G","C4B","C4A","U4","V4","BlendMode","Bone","parent","Matrix","children","ax","ay","arotation","ascaleX","ascaleY","ashearX","ashearY","appliedValid","sorted","setToSetupPose","updateWorldTransformWith","updateWorldTransform","rotationY","la","lb","lc","ld","flipX","flipY","yDown","pa","pb","pc","pd","transformMode","TransformMode","Normal","OnlyTranslation","NoRotationOrReflection","prx","rx","ry","NoScale","NoScaleOrReflection","za","zc","sqrt","zb","zd","getWorldRotationX","getWorldRotationY","getWorldScaleX","getWorldScaleY","updateAppliedTransform","pm","pid","dx","dy","ia","ib","ic","ra","rb","rc","rd","det","worldToLocal","world","invDet","localToWorld","local","worldToLocalRotation","worldRotation","localToWorldRotation","localRotation","rotateWorld","BoneData","Event","EventData","IkConstraint","findBone","getOrder","order","apply1","apply2","targetX","targetY","rotationIK","child","bendDir","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","pp","l1","l2","a1","a2","acos","aa","bb","dd","ta","c1","c2","q","r0","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","IkConstraintData","PathConstraint","spaces","positions","lengths","segments","findSlot","spacingMode","lengthSpacing","SpacingMode","Length","rotateMode","tangents","RotateMode","Tangent","ChainScale","boneCount","spacesCount","setupLength","length_1","computeWorldPositions","positionMode","PositionMode","Percent","boneX","boneY","offsetRotation","tip","Chain","degRad","length_2","length_3","PI2","percentPosition","percentSpacing","verticesLength","curveCount","prevCurve","NONE","pathLength_1","curve","space","BEFORE","addBeforePosition","AFTER","addAfterPosition","length_4","addCurvePosition","pathLength","curveLength","segment","length_5","length_6","temp","tt","ttt","uu","uuu","ut","ut3","uut3","utt3","PathConstraintData","Skeleton","_updateCache","updateCacheReset","boneData","parent_1","slotData","Slot","ikConstraintData","transformConstraintData","TransformConstraint","pathConstraintData","updateCache","ikCount","transformCount","pathCount","constraintCount","sortIkConstraint","sortTransformConstraint","sortPathConstraint","sortBone","constrained","sortReset","slotBone","sortPathConstraintAttachment","defaultSkin","skins","sortPathConstraintAttachmentWith","pathBones","setBonesToSetupPose","setSlotsToSetupPose","getRootBone","boneName","findBoneIndex","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","name_1","getAttachmentByName","findIkConstraint","constraintName","findTransformConstraint","findPathConstraint","getBounds","size","POSITIVE_INFINITY","NEGATIVE_INFINITY","mesh","nn","SkeletonBounds","boundingBoxes","polygons","polygonPool","updateAabb","slotCount","freeAll","boundingBox","polygon","aabbCompute","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","SkeletonClipping","triangulator","Triangulator","clippingPolygon","clipOutput","clippedVertices","clippedTriangles","scratch","clipStart","clip","clipAttachment","makeClockwise","clippingPolygons","decompose","triangulate","n_1","clipEndWithSlot","endSlot","clipEnd","isClipping","clipTriangles","trianglesLength","polygonsCount","vertexSize","u1","v1","u3","v3","clippedVerticesItems","clippedTrianglesItems","clipOutputLength","d0","d1","d2","d4","clipOutputCount","clipOutputItems","c0","clippingArea","output","originalOutput","clipped","input","clippingVertices","clippingVerticesLast","edgeX","edgeY","edgeX2","edgeY2","deltaX","deltaY","inputVertices","inputVerticesLength","outputStart","inputX","inputY","inputX2","inputY2","side2","ua","verticeslength","area","p1x","p1y","p2x","p2y","lastX","other","SkeletonData","animations","fps","findEvent","eventDataName","event_4","findPathConstraintIndex","pathConstraintName","attachmentLoader","linkedMeshes","root","skeletonMap","hash","imagesPath","images","boneMap","parent_2","parentName","getValue","transformModeFromString","slotMap","SlotData","setFromString","blendMode","blendModeFromString","ik","constraintMap","targetName","transform","TransformConstraintData","relative","offsetScaleX","offsetScaleY","offsetShearY","positionModeFromString","spacingModeFromString","rotateModeFromString","Fixed","skinMap","Skin","entryName","readAttachment","addAttachment","linkedMesh","parent_3","eventName","eventMap","intValue","floatValue","stringValue","animationMap","readAnimation","map","box","readVertices","parent_4","LinkedMesh","newArray","scaledVertices","toFloatArray","weights","timelineName","timelineMap","valueMap","readCurve","angle","timelineScale","paths","deformName","deformMap","weighted","deformLength","verticesValue","drawOrderNode","draworder","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","eventData","event_5","toSinglePrecision","prop","defaultValue","str","toLowerCase","Additive","Multiply","Screen","dictionary","oldSkin","attachmentTime","setAttachmentTime","getAttachmentTime","Texture","image","_image","getImage","filterFromString","text","TextureFilter","Nearest","Linear","MipMap","MipMapNearestNearest","MipMapLinearNearest","MipMapNearestLinear","MipMapLinearLinear","wrapFromString","TextureWrap","MirroredRepeat","ClampToEdge","Repeat","TextureRegion","tex","VERSION","crop","trim","orig","spineOffsetY","atlasText","textureLoader","pages","regions","addSpineAtlas","addTexture","page","TextureAtlasPage","realWidth","realHeight","minFilter","magFilter","uWrap","vWrap","TextureAtlasRegion","addTextureHash","textures","stripExtension","substr","lastIndexOf","load","reader","TextureAtlasReader","tuple","iterateParser","readLine","readTuple","parseInt","readValue","hasLoaded","setFilters","resolution","Rectangle","frame2","clone","_updateUvs","lines","colon","substring","lastMatch","comma","filter","scaleMode","SCALE_MODES","NEAREST","mipmap","Vector2","applyRelativeLocal","applyAbsoluteLocal","applyRelativeWorld","applyAbsoluteWorld","targetMat","tb","tc","td","degRadReflect","modified","ts","convexPolygons","convexPolygonsIndices","indicesArray","isConcaveArray","polygonIndicesPool","indices","isConcave","previous","p1","p2","p3","p3x","p3y","positiveArea","previousIndex","nextIndex","polygonIndices","fanBaseIndex","lastWinding","t1","t2","t3","merged","winding1","winding","winding2","firstIndex","lastIndex","prevPrevX","prevPrevY","firstX","firstY","secondX","secondY","otherIndices","otherFirstIndex","otherSecondIndex","otherLastIndex","otherPoly","array","contains","remove","hex","WHITE","RED","GREEN","BLUE","MAGENTA","cbrt","pow","randomTriangular","randomTriangularWith","mode","radiansToDegrees","degreesToRadians","Interpolation","applyInternal","Pow","power","PowOut","sourceStart","dest","destStart","numElements","oldSize","SUPPORTS_TYPED_ARRAYS","Float32Array","newShortArray","Int16Array","DebugUtils","logBones","instantiator","items","item","normalize","len","TimeKeeper","maxDelta","framesPerSecond","totalTime","Date","WindowedMean","windowSize","addedValues","lastValue","mean","dirty","hasEnoughData","addValue","getMean","JitterEffect","jitterX","jitterY","begin","uv","SwirlEffect","radius","centerX","centerY","radAngle","dist","theta","interpolation","isJson","resource","TYPE","loaders","Resource","atlasParser","metadata","metadataSkeletonScale","spineSkeletonScale","metadataAtlas","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","replace","baseUrl","atlasOptions","crossOrigin","xhrType","XHR_RESPONSE_TYPE","TEXT","spineMetadata","parentResource","imageOptions","imageMetadata","adapter","staticImageLoader","imageLoader","imageLoaderAdapter","atlasResource","namePrefix","syncImageLoaderAdapter","Loader","addPixiMiddleware","use","fround","SlotContainerUpdateTransformV3","pt","worldTransform","wt","localTransform","worldAlpha","_currentBounds","tempRgb","SpineSprite","Sprite","SpineMesh","drawMode","Mesh","hackTextureBySlotName","hackTextureBySlotIndex","stateData","state","slotContainers","tempClipContainers","slotContainer","Container","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","createGraphics","clippingContainer","currentGraphics","autoUpdate","tintRgb","updateTransform","autoUpdateTransform","utils","rgb2hex","hex2rgb","dt","g0","b0","attColor","visible","ar","sprites","transAny","matrix2d","_dirtyVersion","isStatic","operMode","TransformBase","setFromMatrix","copy","displayObjectUpdateTransform","tint","TransformStatic","DisplayObject","meshName","meshes","updateGraphics","clippingAttachment","renderable","setSpriteRegion","setMeshRegion","globalAutoUpdate","timeDelta","defName","tempAttachment","tempRegion","anchor","strip","Uint16Array","DRAW_MODES","TRIANGLES","canvasPadding","graphics","Graphics","poly","Polygon","beginFill","drawPolygon","mask","graphicsData","shape","points","clearDirty","sign","EPSILON","EPSILON32","MAX32","MIN32","roundTiesToEven","$abs","$sign","Infinity","$Object","setPrototypeOf","check","test","buggy","gOPD","getOwnPropertyDescriptor","newSpine","initAnimation","autoplay","playAnimation","Promise","Internal","newGenericPromiseCapability","OwnPromiseCapability","Wrapper","anInstance","forOf","speciesConstructor","task","microtask","newPromiseCapabilityModule","perform","promiseResolve","$Promise","isNode","empty","USE_NATIVE","FakePromise","PromiseRejectionEvent","sameConstructor","isThenable","notify","isReject","_n","chain","_c","_v","ok","_s","reaction","handler","fail","domain","_h","onHandleUnhandled","enter","exit","onUnhandled","unhandled","isUnhandled","emit","onunhandledrejection","reason","error","_a","onrejectionhandled","$reject","_d","_w","$resolve","wrapper","executor","err","onFulfilled","onRejected","capability","iter","all","iterable","remaining","$index","alreadyCalled","race","forbiddenField","isArrayIter","getIterFn","BREAK","RETURN","iterator","iterFn","ret","ArrayProto","un","macrotask","Observer","MutationObserver","WebKitMutationObserver","head","flush","toggle","node","createTextNode","observe","characterData","safe","DESCRIPTORS","KEY","SAFE_CLOSING","riter","skipClosing","arr","finally","onFinally","isFunction","try","callbackfn","_isReady","isReady"],"mappings":"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","file":"YSP_Spine.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 67);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store = __webpack_require__(21)('wks');\nvar uid = __webpack_require__(22);\nvar Symbol = __webpack_require__(0).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nvar core = module.exports = { version: '2.5.0' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(16)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(11);\nvar createDesc = __webpack_require__(20);\nmodule.exports = __webpack_require__(3) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(24);\nvar defined = __webpack_require__(14);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(0);\nvar core = __webpack_require__(2);\nvar ctx = __webpack_require__(15);\nvar hide = __webpack_require__(4);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && key in exports) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(5);\nvar IE8_DOM_DEFINE = __webpack_require__(25);\nvar toPrimitive = __webpack_require__(26);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(3) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\n// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// optional / simple context binding\nvar aFunction = __webpack_require__(18);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(21)('keys');\nvar uid = __webpack_require__(22);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(6);\nvar document = __webpack_require__(0).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(0);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\n// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(13);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = !__webpack_require__(3) && !__webpack_require__(16)(function () {\n  return Object.defineProperty(__webpack_require__(19)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(6);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(31);\nvar enumBugKeys = __webpack_require__(23);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.15 ToLength\nvar toInteger = __webpack_require__(12);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar def = __webpack_require__(11).f;\nvar has = __webpack_require__(9);\nvar TAG = __webpack_require__(1)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY = __webpack_require__(34);\nvar $export = __webpack_require__(8);\nvar redefine = __webpack_require__(45);\nvar hide = __webpack_require__(4);\nvar has = __webpack_require__(9);\nvar Iterators = __webpack_require__(10);\nvar $iterCreate = __webpack_require__(46);\nvar setToStringTag = __webpack_require__(29);\nvar getPrototypeOf = __webpack_require__(48);\nvar ITERATOR = __webpack_require__(1)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(9);\nvar toIObject = __webpack_require__(7);\nvar arrayIndexOf = __webpack_require__(32)(false);\nvar IE_PROTO = __webpack_require__(17)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(7);\nvar toLength = __webpack_require__(28);\nvar toAbsoluteIndex = __webpack_require__(33);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(12);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports) {\n\nmodule.exports = true;\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(5);\nvar dPs = __webpack_require__(47);\nvar enumBugKeys = __webpack_require__(23);\nvar IE_PROTO = __webpack_require__(17)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(19)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(36).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar document = __webpack_require__(0).document;\nmodule.exports = document && document.documentElement;\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(14);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(13);\nvar TAG = __webpack_require__(1)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\nexports.f = {}.propertyIsEnumerable;\n\n\n/***/ }),\n/* 40 */,\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(42);\nvar global = __webpack_require__(0);\nvar hide = __webpack_require__(4);\nvar Iterators = __webpack_require__(10);\nvar TO_STRING_TAG = __webpack_require__(1)('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar addToUnscopables = __webpack_require__(43);\nvar step = __webpack_require__(44);\nvar Iterators = __webpack_require__(10);\nvar toIObject = __webpack_require__(7);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(30)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\nmodule.exports = function () { /* empty */ };\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(4);\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar create = __webpack_require__(35);\nvar descriptor = __webpack_require__(20);\nvar setToStringTag = __webpack_require__(29);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(4)(IteratorPrototype, __webpack_require__(1)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dP = __webpack_require__(11);\nvar anObject = __webpack_require__(5);\nvar getKeys = __webpack_require__(27);\n\nmodule.exports = __webpack_require__(3) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(9);\nvar toObject = __webpack_require__(37);\nvar IE_PROTO = __webpack_require__(17)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $at = __webpack_require__(50)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(30)(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(12);\nvar defined = __webpack_require__(14);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(38);\nvar ITERATOR = __webpack_require__(1)('iterator');\nvar Iterators = __webpack_require__(10);\nmodule.exports = __webpack_require__(2).getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n/* 52 */,\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _promise = __webpack_require__(88);\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar raws = {};\nvar spines = {};\nvar filesToLoad = 0;\n\nvar _loadRaw = function _loadRaw(path) {\n    return new _promise2.default(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', path);\n        xhr.onload = function () {\n            return resolve(xhr.responseText);\n        };\n        xhr.onerror = function () {\n            return resolve(xhr.statusText);\n        };\n        xhr.send();\n    });\n};\n\nvar _loadTexture = function _loadTexture(path) {\n    return new _promise2.default(function (resolve, reject) {\n        var texture = PIXI.BaseTexture.fromImage(path);\n        texture.on('loaded', function (baseTexture) {\n            return resolve(baseTexture);\n        });\n        texture.on('error', function (baseTexture) {\n            return reject(baseTexture);\n        });\n    });\n};\n\nvar loadAssets = function loadAssets(spineName) {\n    var setup = ysp.Spine.SETUP[spineName];\n    if (raws[spineName]) {\n        return;\n    }\n    raws[spineName] = {};\n    filesToLoad = filesToLoad + 3;\n\n    _loadRaw(setup.json).then(function (res) {\n        raws[spineName].json = JSON.parse(res);\n        filesToLoad = filesToLoad - 1;\n    }).catch(function (res) {\n        console.log(res);\n    });\n\n    _loadRaw(setup.atlas).then(function (res) {\n        raws[spineName].atlas = res;\n        filesToLoad = filesToLoad - 1;\n    }).catch(function (res) {\n        console.log(res);\n    });\n\n    _loadTexture(setup.texture).then(function (texture) {\n        raws[spineName].texture = texture;\n        filesToLoad = filesToLoad - 1;\n    }).catch(function (texture) {\n        console.log('Couldn\\'t load: ' + setup.texture);\n    });\n};\n\nvar loadSkeleton = function loadSkeleton(spineName) {\n    var setup = ysp.Spine.SETUP[spineName];\n\n    if (spines[spineName]) {\n        return spines[spineName];\n    }\n\n    if (!raws[spineName]) {\n        console.log('[Error] Spine \\'' + spineName + '\\' hasn\\'t pre-loaded');\n        return;\n    }\n\n    var rawSkeletonData = raws[spineName].json;\n    var rawAtlasData = raws[spineName].atlas;\n\n    var spineAtlas = new PIXI.spine.core.TextureAtlas(rawAtlasData, function (line, callback) {\n        callback(raws[spineName].texture);\n    });\n\n    var spineAtlasLoader = new PIXI.spine.core.AtlasAttachmentLoader(spineAtlas);\n    var spineJsonParser = new PIXI.spine.core.SkeletonJson(spineAtlasLoader);\n\n    var spineData = spineJsonParser.readSkeletonData(rawSkeletonData);\n    spines[spineName] = spineData;\n\n    return spines[spineName];\n};\n\nvar isLoaded = function isLoaded() {\n    return filesToLoad === 0;\n};\n\nexports.default = {\n    loadAssets: loadAssets,\n    loadSkeleton: loadSkeleton,\n    isLoaded: isLoaded,\n    raws: raws,\n    spines: spines\n};\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = __webpack_require__(18);\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = __webpack_require__(5);\nvar aFunction = __webpack_require__(18);\nvar SPECIES = __webpack_require__(1)('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx = __webpack_require__(15);\nvar invoke = __webpack_require__(96);\nvar html = __webpack_require__(36);\nvar cel = __webpack_require__(19);\nvar global = __webpack_require__(0);\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (__webpack_require__(13)(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar newPromiseCapability = __webpack_require__(54);\n\nmodule.exports = function (C, x) {\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\n\n/***/ }),\n/* 59 */,\n/* 60 */,\n/* 61 */,\n/* 62 */,\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _assign = __webpack_require__(68);\n\nvar _assign2 = _interopRequireDefault(_assign);\n\n__webpack_require__(73);\n\nvar _spine = __webpack_require__(87);\n\nvar _spine2 = _interopRequireDefault(_spine);\n\nvar _loader = __webpack_require__(53);\n\nvar _loader2 = _interopRequireDefault(_loader);\n\nvar _sceneBase = __webpack_require__(103);\n\nvar _sceneBase2 = _interopRequireDefault(_sceneBase);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nwindow.ysp = window.ysp || {};\n\n(0, _sceneBase2.default)(Scene_Base);\n\nvar _exports = {\n    spine: _spine2.default,\n    loader: _loader2.default\n};\nwindow.ysp.Spine = (0, _assign2.default)({}, window.ysp.Spine, _exports);\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(69), __esModule: true };\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(70);\nmodule.exports = __webpack_require__(2).Object.assign;\n\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.3.1 Object.assign(target, source)\nvar $export = __webpack_require__(8);\n\n$export($export.S + $export.F, 'Object', { assign: __webpack_require__(71) });\n\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = __webpack_require__(27);\nvar gOPS = __webpack_require__(72);\nvar pIE = __webpack_require__(39);\nvar toObject = __webpack_require__(37);\nvar IObject = __webpack_require__(24);\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __webpack_require__(16)(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _fround = __webpack_require__(74);\n\nvar _fround2 = _interopRequireDefault(_fround);\n\nvar _create = __webpack_require__(79);\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _setPrototypeOf = __webpack_require__(82);\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = _setPrototypeOf2.default || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? (0, _create2.default)(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nvar pixi_spine;\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Animation = function () {\n            function Animation(name, timelines, duration) {\n                if (name == null) throw new Error(\"name cannot be null.\");\n                if (timelines == null) throw new Error(\"timelines cannot be null.\");\n                this.name = name;\n                this.timelines = timelines;\n                this.duration = duration;\n            }\n            Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, pose, direction) {\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                if (loop && this.duration != 0) {\n                    time %= this.duration;\n                    if (lastTime > 0) lastTime %= this.duration;\n                }\n                var timelines = this.timelines;\n                for (var i = 0, n = timelines.length; i < n; i++) {\n                    timelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction);\n                }\n            };\n            Animation.binarySearch = function (values, target, step) {\n                if (step === void 0) {\n                    step = 1;\n                }\n                var low = 0;\n                var high = values.length / step - 2;\n                if (high == 0) return step;\n                var current = high >>> 1;\n                while (true) {\n                    if (values[(current + 1) * step] <= target) low = current + 1;else high = current;\n                    if (low == high) return (low + 1) * step;\n                    current = low + high >>> 1;\n                }\n            };\n            Animation.linearSearch = function (values, target, step) {\n                for (var i = 0, last = values.length - step; i <= last; i += step) {\n                    if (values[i] > target) return i;\n                }return -1;\n            };\n            return Animation;\n        }();\n        core.Animation = Animation;\n        var MixPose;\n        (function (MixPose) {\n            MixPose[MixPose[\"setup\"] = 0] = \"setup\";\n            MixPose[MixPose[\"current\"] = 1] = \"current\";\n            MixPose[MixPose[\"currentLayered\"] = 2] = \"currentLayered\";\n        })(MixPose = core.MixPose || (core.MixPose = {}));\n        var MixDirection;\n        (function (MixDirection) {\n            MixDirection[MixDirection[\"in\"] = 0] = \"in\";\n            MixDirection[MixDirection[\"out\"] = 1] = \"out\";\n        })(MixDirection = core.MixDirection || (core.MixDirection = {}));\n        var TimelineType;\n        (function (TimelineType) {\n            TimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\n            TimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\n            TimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\n            TimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\n            TimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\n            TimelineType[TimelineType[\"color\"] = 5] = \"color\";\n            TimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\n            TimelineType[TimelineType[\"event\"] = 7] = \"event\";\n            TimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\n            TimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\n            TimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\n            TimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\n            TimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\n            TimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\n            TimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\n        })(TimelineType = core.TimelineType || (core.TimelineType = {}));\n        var CurveTimeline = function () {\n            function CurveTimeline(frameCount) {\n                if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n                this.curves = core.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n            }\n            CurveTimeline.prototype.getFrameCount = function () {\n                return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n            };\n            CurveTimeline.prototype.setLinear = function (frameIndex) {\n                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n            };\n            CurveTimeline.prototype.setStepped = function (frameIndex) {\n                this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n            };\n            CurveTimeline.prototype.getCurveType = function (frameIndex) {\n                var index = frameIndex * CurveTimeline.BEZIER_SIZE;\n                if (index == this.curves.length) return CurveTimeline.LINEAR;\n                var type = this.curves[index];\n                if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n                if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n                return CurveTimeline.BEZIER;\n            };\n            CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\n                var tmpx = (-cx1 * 2 + cx2) * 0.03,\n                    tmpy = (-cy1 * 2 + cy2) * 0.03;\n                var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006,\n                    dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n                var ddfx = tmpx * 2 + dddfx,\n                    ddfy = tmpy * 2 + dddfy;\n                var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667,\n                    dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n                var i = frameIndex * CurveTimeline.BEZIER_SIZE;\n                var curves = this.curves;\n                curves[i++] = CurveTimeline.BEZIER;\n                var x = dfx,\n                    y = dfy;\n                for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                    curves[i] = x;\n                    curves[i + 1] = y;\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    x += dfx;\n                    y += dfy;\n                }\n            };\n            CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\n                percent = core.MathUtils.clamp(percent, 0, 1);\n                var curves = this.curves;\n                var i = frameIndex * CurveTimeline.BEZIER_SIZE;\n                var type = curves[i];\n                if (type == CurveTimeline.LINEAR) return percent;\n                if (type == CurveTimeline.STEPPED) return 0;\n                i++;\n                var x = 0;\n                for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                    x = curves[i];\n                    if (x >= percent) {\n                        var prevX = void 0,\n                            prevY = void 0;\n                        if (i == start) {\n                            prevX = 0;\n                            prevY = 0;\n                        } else {\n                            prevX = curves[i - 2];\n                            prevY = curves[i - 1];\n                        }\n                        return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n                    }\n                }\n                var y = curves[i - 1];\n                return y + (1 - y) * (percent - x) / (1 - x);\n            };\n            return CurveTimeline;\n        }();\n        CurveTimeline.LINEAR = 0;\n        CurveTimeline.STEPPED = 1;\n        CurveTimeline.BEZIER = 2;\n        CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\n        core.CurveTimeline = CurveTimeline;\n        var RotateTimeline = function (_super) {\n            __extends(RotateTimeline, _super);\n            function RotateTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount << 1);\n                return _this;\n            }\n            RotateTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.rotate << 24) + this.boneIndex;\n            };\n            RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\n                frameIndex <<= 1;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n            };\n            RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var frames = this.frames;\n                var bone = skeleton.bones[this.boneIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            bone.rotation = bone.data.rotation;\n                            return;\n                        case MixPose.current:\n                            var r_1 = bone.data.rotation - bone.rotation;\n                            r_1 -= (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360;\n                            bone.rotation += r_1 * alpha;\n                    }\n                    return;\n                }\n                if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\n                    if (pose == MixPose.setup) bone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;else {\n                        var r_2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\n                        r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;\n                        bone.rotation += r_2 * alpha;\n                    }\n                    return;\n                }\n                var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n                var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                r = prevRotation + r * percent;\n                if (pose == MixPose.setup) {\n                    r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                    bone.rotation = bone.data.rotation + r * alpha;\n                } else {\n                    r = bone.data.rotation + r - bone.rotation;\n                    r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                    bone.rotation += r * alpha;\n                }\n            };\n            return RotateTimeline;\n        }(CurveTimeline);\n        RotateTimeline.ENTRIES = 2;\n        RotateTimeline.PREV_TIME = -2;\n        RotateTimeline.PREV_ROTATION = -1;\n        RotateTimeline.ROTATION = 1;\n        core.RotateTimeline = RotateTimeline;\n        var TranslateTimeline = function (_super) {\n            __extends(TranslateTimeline, _super);\n            function TranslateTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n                return _this;\n            }\n            TranslateTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.translate << 24) + this.boneIndex;\n            };\n            TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\n                frameIndex *= TranslateTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + TranslateTimeline.X] = x;\n                this.frames[frameIndex + TranslateTimeline.Y] = y;\n            };\n            TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var frames = this.frames;\n                var bone = skeleton.bones[this.boneIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            bone.x = bone.data.x;\n                            bone.y = bone.data.y;\n                            return;\n                        case MixPose.current:\n                            bone.x += (bone.data.x - bone.x) * alpha;\n                            bone.y += (bone.data.y - bone.y) * alpha;\n                    }\n                    return;\n                }\n                var x = 0,\n                    y = 0;\n                if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\n                    x = frames[frames.length + TranslateTimeline.PREV_X];\n                    y = frames[frames.length + TranslateTimeline.PREV_Y];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n                    x = frames[frame + TranslateTimeline.PREV_X];\n                    y = frames[frame + TranslateTimeline.PREV_Y];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n                    x += (frames[frame + TranslateTimeline.X] - x) * percent;\n                    y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n                }\n                if (pose == MixPose.setup) {\n                    bone.x = bone.data.x + x * alpha;\n                    bone.y = bone.data.y + y * alpha;\n                } else {\n                    bone.x += (bone.data.x + x - bone.x) * alpha;\n                    bone.y += (bone.data.y + y - bone.y) * alpha;\n                }\n            };\n            return TranslateTimeline;\n        }(CurveTimeline);\n        TranslateTimeline.ENTRIES = 3;\n        TranslateTimeline.PREV_TIME = -3;\n        TranslateTimeline.PREV_X = -2;\n        TranslateTimeline.PREV_Y = -1;\n        TranslateTimeline.X = 1;\n        TranslateTimeline.Y = 2;\n        core.TranslateTimeline = TranslateTimeline;\n        var ScaleTimeline = function (_super) {\n            __extends(ScaleTimeline, _super);\n            function ScaleTimeline(frameCount) {\n                return _super.call(this, frameCount) || this;\n            }\n            ScaleTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.scale << 24) + this.boneIndex;\n            };\n            ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var frames = this.frames;\n                var bone = skeleton.bones[this.boneIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            bone.scaleX = bone.data.scaleX;\n                            bone.scaleY = bone.data.scaleY;\n                            return;\n                        case MixPose.current:\n                            bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                            bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n                    }\n                    return;\n                }\n                var x = 0,\n                    y = 0;\n                if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n                    x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n                    y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n                } else {\n                    var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n                    x = frames[frame + ScaleTimeline.PREV_X];\n                    y = frames[frame + ScaleTimeline.PREV_Y];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n                    x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n                    y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n                }\n                if (alpha == 1) {\n                    bone.scaleX = x;\n                    bone.scaleY = y;\n                } else {\n                    var bx = 0,\n                        by = 0;\n                    if (pose == MixPose.setup) {\n                        bx = bone.data.scaleX;\n                        by = bone.data.scaleY;\n                    } else {\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                    }\n                    if (direction == MixDirection.out) {\n                        x = Math.abs(x) * core.MathUtils.signum(bx);\n                        y = Math.abs(y) * core.MathUtils.signum(by);\n                    } else {\n                        bx = Math.abs(bx) * core.MathUtils.signum(x);\n                        by = Math.abs(by) * core.MathUtils.signum(y);\n                    }\n                    bone.scaleX = bx + (x - bx) * alpha;\n                    bone.scaleY = by + (y - by) * alpha;\n                }\n            };\n            return ScaleTimeline;\n        }(TranslateTimeline);\n        core.ScaleTimeline = ScaleTimeline;\n        var ShearTimeline = function (_super) {\n            __extends(ShearTimeline, _super);\n            function ShearTimeline(frameCount) {\n                return _super.call(this, frameCount) || this;\n            }\n            ShearTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.shear << 24) + this.boneIndex;\n            };\n            ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var frames = this.frames;\n                var bone = skeleton.bones[this.boneIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            bone.shearX = bone.data.shearX;\n                            bone.shearY = bone.data.shearY;\n                            return;\n                        case MixPose.current:\n                            bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                            bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n                    }\n                    return;\n                }\n                var x = 0,\n                    y = 0;\n                if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n                    x = frames[frames.length + ShearTimeline.PREV_X];\n                    y = frames[frames.length + ShearTimeline.PREV_Y];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n                    x = frames[frame + ShearTimeline.PREV_X];\n                    y = frames[frame + ShearTimeline.PREV_Y];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n                    x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n                    y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n                }\n                if (pose == MixPose.setup) {\n                    bone.shearX = bone.data.shearX + x * alpha;\n                    bone.shearY = bone.data.shearY + y * alpha;\n                } else {\n                    bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                }\n            };\n            return ShearTimeline;\n        }(TranslateTimeline);\n        core.ShearTimeline = ShearTimeline;\n        var ColorTimeline = function (_super) {\n            __extends(ColorTimeline, _super);\n            function ColorTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n                return _this;\n            }\n            ColorTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.color << 24) + this.slotIndex;\n            };\n            ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\n                frameIndex *= ColorTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + ColorTimeline.R] = r;\n                this.frames[frameIndex + ColorTimeline.G] = g;\n                this.frames[frameIndex + ColorTimeline.B] = b;\n                this.frames[frameIndex + ColorTimeline.A] = a;\n            };\n            ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var slot = skeleton.slots[this.slotIndex];\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            slot.color.setFromColor(slot.data.color);\n                            return;\n                        case MixPose.current:\n                            var color = slot.color,\n                                setup = slot.data.color;\n                            color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n                    }\n                    return;\n                }\n                var r = 0,\n                    g = 0,\n                    b = 0,\n                    a = 0;\n                if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\n                    var i = frames.length;\n                    r = frames[i + ColorTimeline.PREV_R];\n                    g = frames[i + ColorTimeline.PREV_G];\n                    b = frames[i + ColorTimeline.PREV_B];\n                    a = frames[i + ColorTimeline.PREV_A];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n                    r = frames[frame + ColorTimeline.PREV_R];\n                    g = frames[frame + ColorTimeline.PREV_G];\n                    b = frames[frame + ColorTimeline.PREV_B];\n                    a = frames[frame + ColorTimeline.PREV_A];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n                    r += (frames[frame + ColorTimeline.R] - r) * percent;\n                    g += (frames[frame + ColorTimeline.G] - g) * percent;\n                    b += (frames[frame + ColorTimeline.B] - b) * percent;\n                    a += (frames[frame + ColorTimeline.A] - a) * percent;\n                }\n                if (alpha == 1) slot.color.set(r, g, b, a);else {\n                    var color = slot.color;\n                    if (pose == MixPose.setup) color.setFromColor(slot.data.color);\n                    color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n                }\n            };\n            return ColorTimeline;\n        }(CurveTimeline);\n        ColorTimeline.ENTRIES = 5;\n        ColorTimeline.PREV_TIME = -5;\n        ColorTimeline.PREV_R = -4;\n        ColorTimeline.PREV_G = -3;\n        ColorTimeline.PREV_B = -2;\n        ColorTimeline.PREV_A = -1;\n        ColorTimeline.R = 1;\n        ColorTimeline.G = 2;\n        ColorTimeline.B = 3;\n        ColorTimeline.A = 4;\n        core.ColorTimeline = ColorTimeline;\n        var TwoColorTimeline = function (_super) {\n            __extends(TwoColorTimeline, _super);\n            function TwoColorTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n                return _this;\n            }\n            TwoColorTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.twoColor << 24) + this.slotIndex;\n            };\n            TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\n                frameIndex *= TwoColorTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + TwoColorTimeline.R] = r;\n                this.frames[frameIndex + TwoColorTimeline.G] = g;\n                this.frames[frameIndex + TwoColorTimeline.B] = b;\n                this.frames[frameIndex + TwoColorTimeline.A] = a;\n                this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n                this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n                this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n            };\n            TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var slot = skeleton.slots[this.slotIndex];\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            slot.color.setFromColor(slot.data.color);\n                            slot.darkColor.setFromColor(slot.data.darkColor);\n                            return;\n                        case MixPose.current:\n                            var light = slot.color,\n                                dark = slot.darkColor,\n                                setupLight = slot.data.color,\n                                setupDark = slot.data.darkColor;\n                            light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                            dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n                    }\n                    return;\n                }\n                var r = 0,\n                    g = 0,\n                    b = 0,\n                    a = 0,\n                    r2 = 0,\n                    g2 = 0,\n                    b2 = 0;\n                if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\n                    var i = frames.length;\n                    r = frames[i + TwoColorTimeline.PREV_R];\n                    g = frames[i + TwoColorTimeline.PREV_G];\n                    b = frames[i + TwoColorTimeline.PREV_B];\n                    a = frames[i + TwoColorTimeline.PREV_A];\n                    r2 = frames[i + TwoColorTimeline.PREV_R2];\n                    g2 = frames[i + TwoColorTimeline.PREV_G2];\n                    b2 = frames[i + TwoColorTimeline.PREV_B2];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n                    r = frames[frame + TwoColorTimeline.PREV_R];\n                    g = frames[frame + TwoColorTimeline.PREV_G];\n                    b = frames[frame + TwoColorTimeline.PREV_B];\n                    a = frames[frame + TwoColorTimeline.PREV_A];\n                    r2 = frames[frame + TwoColorTimeline.PREV_R2];\n                    g2 = frames[frame + TwoColorTimeline.PREV_G2];\n                    b2 = frames[frame + TwoColorTimeline.PREV_B2];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n                    r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n                    g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n                    b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n                    a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n                    r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n                    g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n                    b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n                }\n                if (alpha == 1) {\n                    slot.color.set(r, g, b, a);\n                    slot.darkColor.set(r2, g2, b2, 1);\n                } else {\n                    var light = slot.color,\n                        dark = slot.darkColor;\n                    if (pose == MixPose.setup) {\n                        light.setFromColor(slot.data.color);\n                        dark.setFromColor(slot.data.darkColor);\n                    }\n                    light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n                    dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n                }\n            };\n            return TwoColorTimeline;\n        }(CurveTimeline);\n        TwoColorTimeline.ENTRIES = 8;\n        TwoColorTimeline.PREV_TIME = -8;\n        TwoColorTimeline.PREV_R = -7;\n        TwoColorTimeline.PREV_G = -6;\n        TwoColorTimeline.PREV_B = -5;\n        TwoColorTimeline.PREV_A = -4;\n        TwoColorTimeline.PREV_R2 = -3;\n        TwoColorTimeline.PREV_G2 = -2;\n        TwoColorTimeline.PREV_B2 = -1;\n        TwoColorTimeline.R = 1;\n        TwoColorTimeline.G = 2;\n        TwoColorTimeline.B = 3;\n        TwoColorTimeline.A = 4;\n        TwoColorTimeline.R2 = 5;\n        TwoColorTimeline.G2 = 6;\n        TwoColorTimeline.B2 = 7;\n        core.TwoColorTimeline = TwoColorTimeline;\n        var AttachmentTimeline = function () {\n            function AttachmentTimeline(frameCount) {\n                this.frames = core.Utils.newFloatArray(frameCount);\n                this.attachmentNames = new Array(frameCount);\n            }\n            AttachmentTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.attachment << 24) + this.slotIndex;\n            };\n            AttachmentTimeline.prototype.getFrameCount = function () {\n                return this.frames.length;\n            };\n            AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\n                this.frames[frameIndex] = time;\n                this.attachmentNames[frameIndex] = attachmentName;\n            };\n            AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, pose, direction) {\n                var slot = skeleton.slots[this.slotIndex];\n                if (direction == MixDirection.out && pose == MixPose.setup) {\n                    var attachmentName_1 = slot.data.attachmentName;\n                    slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));\n                    return;\n                }\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    if (pose == MixPose.setup) {\n                        var attachmentName_2 = slot.data.attachmentName;\n                        slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));\n                    }\n                    return;\n                }\n                var frameIndex = 0;\n                if (time >= frames[frames.length - 1]) frameIndex = frames.length - 1;else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n                var attachmentName = this.attachmentNames[frameIndex];\n                skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n            };\n            return AttachmentTimeline;\n        }();\n        core.AttachmentTimeline = AttachmentTimeline;\n        var zeros = null;\n        var DeformTimeline = function (_super) {\n            __extends(DeformTimeline, _super);\n            function DeformTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount);\n                _this.frameVertices = new Array(frameCount);\n                if (zeros == null) zeros = core.Utils.newFloatArray(64);\n                return _this;\n            }\n            DeformTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\n            };\n            DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\n                this.frames[frameIndex] = time;\n                this.frameVertices[frameIndex] = vertices;\n            };\n            DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var slot = skeleton.slots[this.slotIndex];\n                var slotAttachment = slot.getAttachment();\n                if (!(slotAttachment instanceof core.VertexAttachment) || !slotAttachment.applyDeform(this.attachment)) return;\n                var verticesArray = slot.attachmentVertices;\n                var frameVertices = this.frameVertices;\n                var vertexCount = frameVertices[0].length;\n                var vertices = core.Utils.setArraySize(verticesArray, vertexCount);\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    var vertexAttachment = slotAttachment;\n                    switch (pose) {\n                        case MixPose.setup:\n                            var zeroVertices = void 0;\n                            if (vertexAttachment.bones == null) {\n                                zeroVertices = vertexAttachment.vertices;\n                            } else {\n                                zeroVertices = zeros;\n                                if (zeroVertices.length < vertexCount) zeros = zeroVertices = core.Utils.newFloatArray(vertexCount);\n                            }\n                            core.Utils.arrayCopy(zeroVertices, 0, vertices, 0, vertexCount);\n                            return;\n                        case MixPose.current:\n                            if (alpha == 1) break;\n                            if (vertexAttachment.bones == null) {\n                                var setupVertices = vertexAttachment.vertices;\n                                for (var i_1 = 0; i_1 < vertexCount; i_1++) {\n                                    vertices[i_1] += (setupVertices[i_1] - vertices[i_1]) * alpha;\n                                }\n                            } else {\n                                alpha = 1 - alpha;\n                                for (var i = 0; i < vertexCount; i++) {\n                                    vertices[i] *= alpha;\n                                }\n                            }\n                    }\n                    return;\n                }\n                if (time >= frames[frames.length - 1]) {\n                    var lastVertices = frameVertices[frames.length - 1];\n                    if (alpha == 1) {\n                        core.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n                    } else if (pose == MixPose.setup) {\n                        var vertexAttachment = slotAttachment;\n                        if (vertexAttachment.bones == null) {\n                            var setupVertices = vertexAttachment.vertices;\n                            for (var i_2 = 0; i_2 < vertexCount; i_2++) {\n                                var setup = setupVertices[i_2];\n                                vertices[i_2] = setup + (lastVertices[i_2] - setup) * alpha;\n                            }\n                        } else {\n                            for (var i_3 = 0; i_3 < vertexCount; i_3++) {\n                                vertices[i_3] = lastVertices[i_3] * alpha;\n                            }\n                        }\n                    } else {\n                        for (var i_4 = 0; i_4 < vertexCount; i_4++) {\n                            vertices[i_4] += (lastVertices[i_4] - vertices[i_4]) * alpha;\n                        }\n                    }\n                    return;\n                }\n                var frame = Animation.binarySearch(frames, time);\n                var prevVertices = frameVertices[frame - 1];\n                var nextVertices = frameVertices[frame];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n                if (alpha == 1) {\n                    for (var i_5 = 0; i_5 < vertexCount; i_5++) {\n                        var prev = prevVertices[i_5];\n                        vertices[i_5] = prev + (nextVertices[i_5] - prev) * percent;\n                    }\n                } else if (pose == MixPose.setup) {\n                    var vertexAttachment = slotAttachment;\n                    if (vertexAttachment.bones == null) {\n                        var setupVertices = vertexAttachment.vertices;\n                        for (var i_6 = 0; i_6 < vertexCount; i_6++) {\n                            var prev = prevVertices[i_6],\n                                setup = setupVertices[i_6];\n                            vertices[i_6] = setup + (prev + (nextVertices[i_6] - prev) * percent - setup) * alpha;\n                        }\n                    } else {\n                        for (var i_7 = 0; i_7 < vertexCount; i_7++) {\n                            var prev = prevVertices[i_7];\n                            vertices[i_7] = (prev + (nextVertices[i_7] - prev) * percent) * alpha;\n                        }\n                    }\n                } else {\n                    for (var i_8 = 0; i_8 < vertexCount; i_8++) {\n                        var prev = prevVertices[i_8];\n                        vertices[i_8] += (prev + (nextVertices[i_8] - prev) * percent - vertices[i_8]) * alpha;\n                    }\n                }\n            };\n            return DeformTimeline;\n        }(CurveTimeline);\n        core.DeformTimeline = DeformTimeline;\n        var EventTimeline = function () {\n            function EventTimeline(frameCount) {\n                this.frames = core.Utils.newFloatArray(frameCount);\n                this.events = new Array(frameCount);\n            }\n            EventTimeline.prototype.getPropertyId = function () {\n                return TimelineType.event << 24;\n            };\n            EventTimeline.prototype.getFrameCount = function () {\n                return this.frames.length;\n            };\n            EventTimeline.prototype.setFrame = function (frameIndex, event) {\n                this.frames[frameIndex] = event.time;\n                this.events[frameIndex] = event;\n            };\n            EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                if (firedEvents == null) return;\n                var frames = this.frames;\n                var frameCount = this.frames.length;\n                if (lastTime > time) {\n                    this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);\n                    lastTime = -1;\n                } else if (lastTime >= frames[frameCount - 1]) return;\n                if (time < frames[0]) return;\n                var frame = 0;\n                if (lastTime < frames[0]) frame = 0;else {\n                    frame = Animation.binarySearch(frames, lastTime);\n                    var frameTime = frames[frame];\n                    while (frame > 0) {\n                        if (frames[frame - 1] != frameTime) break;\n                        frame--;\n                    }\n                }\n                for (; frame < frameCount && time >= frames[frame]; frame++) {\n                    firedEvents.push(this.events[frame]);\n                }\n            };\n            return EventTimeline;\n        }();\n        core.EventTimeline = EventTimeline;\n        var DrawOrderTimeline = function () {\n            function DrawOrderTimeline(frameCount) {\n                this.frames = core.Utils.newFloatArray(frameCount);\n                this.drawOrders = new Array(frameCount);\n            }\n            DrawOrderTimeline.prototype.getPropertyId = function () {\n                return TimelineType.drawOrder << 24;\n            };\n            DrawOrderTimeline.prototype.getFrameCount = function () {\n                return this.frames.length;\n            };\n            DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\n                this.frames[frameIndex] = time;\n                this.drawOrders[frameIndex] = drawOrder;\n            };\n            DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var drawOrder = skeleton.drawOrder;\n                var slots = skeleton.slots;\n                if (direction == MixDirection.out && pose == MixPose.setup) {\n                    core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                    return;\n                }\n                var frames = this.frames;\n                if (time < frames[0]) {\n                    if (pose == MixPose.setup) core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                    return;\n                }\n                var frame = 0;\n                if (time >= frames[frames.length - 1]) frame = frames.length - 1;else frame = Animation.binarySearch(frames, time) - 1;\n                var drawOrderToSetupIndex = this.drawOrders[frame];\n                if (drawOrderToSetupIndex == null) core.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);else {\n                    for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) {\n                        drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n                    }\n                }\n            };\n            return DrawOrderTimeline;\n        }();\n        core.DrawOrderTimeline = DrawOrderTimeline;\n        var IkConstraintTimeline = function (_super) {\n            __extends(IkConstraintTimeline, _super);\n            function IkConstraintTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n                return _this;\n            }\n            IkConstraintTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n            };\n            IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection) {\n                frameIndex *= IkConstraintTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n                this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n            };\n            IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.mix = constraint.data.mix;\n                            constraint.bendDirection = constraint.data.bendDirection;\n                            return;\n                        case MixPose.current:\n                            constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                            constraint.bendDirection = constraint.data.bendDirection;\n                    }\n                    return;\n                }\n                if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\n                    if (pose == MixPose.setup) {\n                        constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                        constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    } else {\n                        constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                        if (direction == MixDirection.in) constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                    }\n                    return;\n                }\n                var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n                var mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n                var frameTime = frames[frame];\n                var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n                if (pose == MixPose.setup) {\n                    constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n                    constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                } else {\n                    constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n                    if (direction == MixDirection.in) constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                }\n            };\n            return IkConstraintTimeline;\n        }(CurveTimeline);\n        IkConstraintTimeline.ENTRIES = 3;\n        IkConstraintTimeline.PREV_TIME = -3;\n        IkConstraintTimeline.PREV_MIX = -2;\n        IkConstraintTimeline.PREV_BEND_DIRECTION = -1;\n        IkConstraintTimeline.MIX = 1;\n        IkConstraintTimeline.BEND_DIRECTION = 2;\n        core.IkConstraintTimeline = IkConstraintTimeline;\n        var TransformConstraintTimeline = function (_super) {\n            __extends(TransformConstraintTimeline, _super);\n            function TransformConstraintTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n                return _this;\n            }\n            TransformConstraintTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n            };\n            TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\n                frameIndex *= TransformConstraintTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n                this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n                this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n                this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n            };\n            TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n                if (time < frames[0]) {\n                    var data = constraint.data;\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.rotateMix = data.rotateMix;\n                            constraint.translateMix = data.translateMix;\n                            constraint.scaleMix = data.scaleMix;\n                            constraint.shearMix = data.shearMix;\n                            return;\n                        case MixPose.current:\n                            constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                            constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                            constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                            constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n                    }\n                    return;\n                }\n                var rotate = 0,\n                    translate = 0,\n                    scale = 0,\n                    shear = 0;\n                if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\n                    var i = frames.length;\n                    rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n                    translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n                    scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n                    shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n                    rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n                    translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n                    scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n                    shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n                    rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n                    translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n                    scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n                    shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n                }\n                if (pose == MixPose.setup) {\n                    var data = constraint.data;\n                    constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n                    constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n                    constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n                    constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n                } else {\n                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (translate - constraint.translateMix) * alpha;\n                    constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n                    constraint.shearMix += (shear - constraint.shearMix) * alpha;\n                }\n            };\n            return TransformConstraintTimeline;\n        }(CurveTimeline);\n        TransformConstraintTimeline.ENTRIES = 5;\n        TransformConstraintTimeline.PREV_TIME = -5;\n        TransformConstraintTimeline.PREV_ROTATE = -4;\n        TransformConstraintTimeline.PREV_TRANSLATE = -3;\n        TransformConstraintTimeline.PREV_SCALE = -2;\n        TransformConstraintTimeline.PREV_SHEAR = -1;\n        TransformConstraintTimeline.ROTATE = 1;\n        TransformConstraintTimeline.TRANSLATE = 2;\n        TransformConstraintTimeline.SCALE = 3;\n        TransformConstraintTimeline.SHEAR = 4;\n        core.TransformConstraintTimeline = TransformConstraintTimeline;\n        var PathConstraintPositionTimeline = function (_super) {\n            __extends(PathConstraintPositionTimeline, _super);\n            function PathConstraintPositionTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n                return _this;\n            }\n            PathConstraintPositionTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n            };\n            PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\n                frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n            };\n            PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.position = constraint.data.position;\n                            return;\n                        case MixPose.current:\n                            constraint.position += (constraint.data.position - constraint.position) * alpha;\n                    }\n                    return;\n                }\n                var position = 0;\n                if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];else {\n                    var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n                    position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n                    position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n                }\n                if (pose == MixPose.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;else constraint.position += (position - constraint.position) * alpha;\n            };\n            return PathConstraintPositionTimeline;\n        }(CurveTimeline);\n        PathConstraintPositionTimeline.ENTRIES = 2;\n        PathConstraintPositionTimeline.PREV_TIME = -2;\n        PathConstraintPositionTimeline.PREV_VALUE = -1;\n        PathConstraintPositionTimeline.VALUE = 1;\n        core.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\n        var PathConstraintSpacingTimeline = function (_super) {\n            __extends(PathConstraintSpacingTimeline, _super);\n            function PathConstraintSpacingTimeline(frameCount) {\n                return _super.call(this, frameCount) || this;\n            }\n            PathConstraintSpacingTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n            };\n            PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.spacing = constraint.data.spacing;\n                            return;\n                        case MixPose.current:\n                            constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n                    }\n                    return;\n                }\n                var spacing = 0;\n                if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];else {\n                    var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n                    spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n                    spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n                }\n                if (pose == MixPose.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;else constraint.spacing += (spacing - constraint.spacing) * alpha;\n            };\n            return PathConstraintSpacingTimeline;\n        }(PathConstraintPositionTimeline);\n        core.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\n        var PathConstraintMixTimeline = function (_super) {\n            __extends(PathConstraintMixTimeline, _super);\n            function PathConstraintMixTimeline(frameCount) {\n                var _this = _super.call(this, frameCount) || this;\n                _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n                return _this;\n            }\n            PathConstraintMixTimeline.prototype.getPropertyId = function () {\n                return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n            };\n            PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\n                frameIndex *= PathConstraintMixTimeline.ENTRIES;\n                this.frames[frameIndex] = time;\n                this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n                this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n            };\n            PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, pose, direction) {\n                var frames = this.frames;\n                var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n                if (time < frames[0]) {\n                    switch (pose) {\n                        case MixPose.setup:\n                            constraint.rotateMix = constraint.data.rotateMix;\n                            constraint.translateMix = constraint.data.translateMix;\n                            return;\n                        case MixPose.current:\n                            constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                            constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n                    }\n                    return;\n                }\n                var rotate = 0,\n                    translate = 0;\n                if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\n                    rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n                    translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n                } else {\n                    var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n                    rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n                    translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n                    var frameTime = frames[frame];\n                    var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n                    rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n                    translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n                }\n                if (pose == MixPose.setup) {\n                    constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n                    constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n                } else {\n                    constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                    constraint.translateMix += (translate - constraint.translateMix) * alpha;\n                }\n            };\n            return PathConstraintMixTimeline;\n        }(CurveTimeline);\n        PathConstraintMixTimeline.ENTRIES = 3;\n        PathConstraintMixTimeline.PREV_TIME = -3;\n        PathConstraintMixTimeline.PREV_ROTATE = -2;\n        PathConstraintMixTimeline.PREV_TRANSLATE = -1;\n        PathConstraintMixTimeline.ROTATE = 1;\n        PathConstraintMixTimeline.TRANSLATE = 2;\n        core.PathConstraintMixTimeline = PathConstraintMixTimeline;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var AnimationState = function () {\n            function AnimationState(data) {\n                this.tracks = new Array();\n                this.events = new Array();\n                this.listeners = new Array();\n                this.queue = new EventQueue(this);\n                this.propertyIDs = new core.IntSet();\n                this.mixingTo = new Array();\n                this.animationsChanged = false;\n                this.timeScale = 1;\n                this.trackEntryPool = new core.Pool(function () {\n                    return new TrackEntry();\n                });\n                this.data = data;\n            }\n            AnimationState.prototype.update = function (delta) {\n                delta *= this.timeScale;\n                var tracks = this.tracks;\n                for (var i = 0, n = tracks.length; i < n; i++) {\n                    var current = tracks[i];\n                    if (current == null) continue;\n                    current.animationLast = current.nextAnimationLast;\n                    current.trackLast = current.nextTrackLast;\n                    var currentDelta = delta * current.timeScale;\n                    if (current.delay > 0) {\n                        current.delay -= currentDelta;\n                        if (current.delay > 0) continue;\n                        currentDelta = -current.delay;\n                        current.delay = 0;\n                    }\n                    var next = current.next;\n                    if (next != null) {\n                        var nextTime = current.trackLast - next.delay;\n                        if (nextTime >= 0) {\n                            next.delay = 0;\n                            next.trackTime = nextTime + delta * next.timeScale;\n                            current.trackTime += currentDelta;\n                            this.setCurrent(i, next, true);\n                            while (next.mixingFrom != null) {\n                                next.mixTime += currentDelta;\n                                next = next.mixingFrom;\n                            }\n                            continue;\n                        }\n                    } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                        tracks[i] = null;\n                        this.queue.end(current);\n                        this.disposeNext(current);\n                        continue;\n                    }\n                    if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                        var from = current.mixingFrom;\n                        current.mixingFrom = null;\n                        while (from != null) {\n                            this.queue.end(from);\n                            from = from.mixingFrom;\n                        }\n                    }\n                    current.trackTime += currentDelta;\n                }\n                this.queue.drain();\n            };\n            AnimationState.prototype.updateMixingFrom = function (to, delta) {\n                var from = to.mixingFrom;\n                if (from == null) return true;\n                var finished = this.updateMixingFrom(from, delta);\n                if (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {\n                    if (from.totalAlpha == 0) {\n                        to.mixingFrom = from.mixingFrom;\n                        to.interruptAlpha = from.interruptAlpha;\n                        this.queue.end(from);\n                    }\n                    return finished;\n                }\n                from.animationLast = from.nextAnimationLast;\n                from.trackLast = from.nextTrackLast;\n                from.trackTime += delta * from.timeScale;\n                to.mixTime += delta * to.timeScale;\n                return false;\n            };\n            AnimationState.prototype.apply = function (skeleton) {\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                if (this.animationsChanged) this._animationsChanged();\n                var events = this.events;\n                var tracks = this.tracks;\n                var applied = false;\n                for (var i = 0, n = tracks.length; i < n; i++) {\n                    var current = tracks[i];\n                    if (current == null || current.delay > 0) continue;\n                    applied = true;\n                    var currentPose = i == 0 ? core.MixPose.current : core.MixPose.currentLayered;\n                    var mix = current.alpha;\n                    if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, currentPose);else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;\n                    var animationLast = current.animationLast,\n                        animationTime = current.getAnimationTime();\n                    var timelineCount = current.animation.timelines.length;\n                    var timelines = current.animation.timelines;\n                    if (mix == 1) {\n                        for (var ii = 0; ii < timelineCount; ii++) {\n                            timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, core.MixPose.setup, core.MixDirection.in);\n                        }\n                    } else {\n                        var timelineData = current.timelineData;\n                        var firstFrame = current.timelinesRotation.length == 0;\n                        if (firstFrame) core.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                        var timelinesRotation = current.timelinesRotation;\n                        for (var ii = 0; ii < timelineCount; ii++) {\n                            var timeline = timelines[ii];\n                            var pose = timelineData[ii] >= AnimationState.FIRST ? core.MixPose.setup : currentPose;\n                            if (timeline instanceof core.RotateTimeline) {\n                                this.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);\n                            } else timeline.apply(skeleton, animationLast, animationTime, events, mix, pose, core.MixDirection.in);\n                        }\n                    }\n                    this.queueEvents(current, animationTime);\n                    events.length = 0;\n                    current.nextAnimationLast = animationTime;\n                    current.nextTrackLast = current.trackTime;\n                }\n                this.queue.drain();\n                return applied;\n            };\n            AnimationState.prototype.applyMixingFrom = function (to, skeleton, currentPose) {\n                var from = to.mixingFrom;\n                if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, currentPose);\n                var mix = 0;\n                if (to.mixDuration == 0) mix = 1;else {\n                    mix = to.mixTime / to.mixDuration;\n                    if (mix > 1) mix = 1;\n                }\n                var events = mix < from.eventThreshold ? this.events : null;\n                var attachments = mix < from.attachmentThreshold,\n                    drawOrder = mix < from.drawOrderThreshold;\n                var animationLast = from.animationLast,\n                    animationTime = from.getAnimationTime();\n                var timelineCount = from.animation.timelines.length;\n                var timelines = from.animation.timelines;\n                var timelineData = from.timelineData;\n                var timelineDipMix = from.timelineDipMix;\n                var firstFrame = from.timelinesRotation.length == 0;\n                if (firstFrame) core.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n                var timelinesRotation = from.timelinesRotation;\n                var pose;\n                var alphaDip = from.alpha * to.interruptAlpha,\n                    alphaMix = alphaDip * (1 - mix),\n                    alpha = 0;\n                from.totalAlpha = 0;\n                for (var i = 0; i < timelineCount; i++) {\n                    var timeline = timelines[i];\n                    switch (timelineData[i]) {\n                        case AnimationState.SUBSEQUENT:\n                            if (!attachments && timeline instanceof core.AttachmentTimeline) continue;\n                            if (!drawOrder && timeline instanceof core.DrawOrderTimeline) continue;\n                            pose = currentPose;\n                            alpha = alphaMix;\n                            break;\n                        case AnimationState.FIRST:\n                            pose = core.MixPose.setup;\n                            alpha = alphaMix;\n                            break;\n                        case AnimationState.DIP:\n                            pose = core.MixPose.setup;\n                            alpha = alphaDip;\n                            break;\n                        default:\n                            pose = core.MixPose.setup;\n                            alpha = alphaDip;\n                            var dipMix = timelineDipMix[i];\n                            alpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);\n                            break;\n                    }\n                    from.totalAlpha += alpha;\n                    if (timeline instanceof core.RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);else {\n                        timeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, core.MixDirection.out);\n                    }\n                }\n                if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n                this.events.length = 0;\n                from.nextAnimationLast = animationTime;\n                from.nextTrackLast = from.trackTime;\n                return mix;\n            };\n            AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, pose, timelinesRotation, i, firstFrame) {\n                if (firstFrame) timelinesRotation[i] = 0;\n                if (alpha == 1) {\n                    timeline.apply(skeleton, 0, time, null, 1, pose, core.MixDirection.in);\n                    return;\n                }\n                var rotateTimeline = timeline;\n                var frames = rotateTimeline.frames;\n                var bone = skeleton.bones[rotateTimeline.boneIndex];\n                if (time < frames[0]) {\n                    if (pose == core.MixPose.setup) bone.rotation = bone.data.rotation;\n                    return;\n                }\n                var r2 = 0;\n                if (time >= frames[frames.length - core.RotateTimeline.ENTRIES]) r2 = bone.data.rotation + frames[frames.length + core.RotateTimeline.PREV_ROTATION];else {\n                    var frame = core.Animation.binarySearch(frames, time, core.RotateTimeline.ENTRIES);\n                    var prevRotation = frames[frame + core.RotateTimeline.PREV_ROTATION];\n                    var frameTime = frames[frame];\n                    var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + core.RotateTimeline.PREV_TIME] - frameTime));\n                    r2 = frames[frame + core.RotateTimeline.ROTATION] - prevRotation;\n                    r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n                    r2 = prevRotation + r2 * percent + bone.data.rotation;\n                    r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n                }\n                var r1 = pose == core.MixPose.setup ? bone.data.rotation : bone.rotation;\n                var total = 0,\n                    diff = r2 - r1;\n                if (diff == 0) {\n                    total = timelinesRotation[i];\n                } else {\n                    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n                    var lastTotal = 0,\n                        lastDiff = 0;\n                    if (firstFrame) {\n                        lastTotal = 0;\n                        lastDiff = diff;\n                    } else {\n                        lastTotal = timelinesRotation[i];\n                        lastDiff = timelinesRotation[i + 1];\n                    }\n                    var current = diff > 0,\n                        dir = lastTotal >= 0;\n                    if (core.MathUtils.signum(lastDiff) != core.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                        if (Math.abs(lastTotal) > 180) lastTotal += 360 * core.MathUtils.signum(lastTotal);\n                        dir = current;\n                    }\n                    total = diff + lastTotal - lastTotal % 360;\n                    if (dir != current) total += 360 * core.MathUtils.signum(lastTotal);\n                    timelinesRotation[i] = total;\n                }\n                timelinesRotation[i + 1] = diff;\n                r1 += total * alpha;\n                bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;\n            };\n            AnimationState.prototype.queueEvents = function (entry, animationTime) {\n                var animationStart = entry.animationStart,\n                    animationEnd = entry.animationEnd;\n                var duration = animationEnd - animationStart;\n                var trackLastWrapped = entry.trackLast % duration;\n                var events = this.events;\n                var i = 0,\n                    n = events.length;\n                for (; i < n; i++) {\n                    var event_1 = events[i];\n                    if (event_1.time < trackLastWrapped) break;\n                    if (event_1.time > animationEnd) continue;\n                    this.queue.event(entry, event_1);\n                }\n                if (entry.loop ? trackLastWrapped > entry.trackTime % duration : animationTime >= animationEnd && entry.animationLast < animationEnd) {\n                    this.queue.complete(entry);\n                }\n                for (; i < n; i++) {\n                    var event_2 = events[i];\n                    if (event_2.time < animationStart) continue;\n                    this.queue.event(entry, events[i]);\n                }\n            };\n            AnimationState.prototype.clearTracks = function () {\n                var oldDrainDisabled = this.queue.drainDisabled;\n                this.queue.drainDisabled = true;\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\n                    this.clearTrack(i);\n                }this.tracks.length = 0;\n                this.queue.drainDisabled = oldDrainDisabled;\n                this.queue.drain();\n            };\n            AnimationState.prototype.clearTrack = function (trackIndex) {\n                if (trackIndex >= this.tracks.length) return;\n                var current = this.tracks[trackIndex];\n                if (current == null) return;\n                this.queue.end(current);\n                this.disposeNext(current);\n                var entry = current;\n                while (true) {\n                    var from = entry.mixingFrom;\n                    if (from == null) break;\n                    this.queue.end(from);\n                    entry.mixingFrom = null;\n                    entry = from;\n                }\n                this.tracks[current.trackIndex] = null;\n                this.queue.drain();\n            };\n            AnimationState.prototype.setCurrent = function (index, current, interrupt) {\n                var from = this.expandToIndex(index);\n                this.tracks[index] = current;\n                if (from != null) {\n                    if (interrupt) this.queue.interrupt(from);\n                    current.mixingFrom = from;\n                    current.mixTime = 0;\n                    if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n                    from.timelinesRotation.length = 0;\n                }\n                this.queue.start(current);\n            };\n            AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\n                var animation = this.data.skeletonData.findAnimation(animationName);\n                if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n                return this.setAnimationWith(trackIndex, animation, loop);\n            };\n            AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\n                if (animation == null) throw new Error(\"animation cannot be null.\");\n                var interrupt = true;\n                var current = this.expandToIndex(trackIndex);\n                if (current != null) {\n                    if (current.nextTrackLast == -1) {\n                        this.tracks[trackIndex] = current.mixingFrom;\n                        this.queue.interrupt(current);\n                        this.queue.end(current);\n                        this.disposeNext(current);\n                        current = current.mixingFrom;\n                        interrupt = false;\n                    } else this.disposeNext(current);\n                }\n                var entry = this.trackEntry(trackIndex, animation, loop, current);\n                this.setCurrent(trackIndex, entry, interrupt);\n                this.queue.drain();\n                return entry;\n            };\n            AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\n                var animation = this.data.skeletonData.findAnimation(animationName);\n                if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n                return this.addAnimationWith(trackIndex, animation, loop, delay);\n            };\n            AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\n                if (animation == null) throw new Error(\"animation cannot be null.\");\n                var last = this.expandToIndex(trackIndex);\n                if (last != null) {\n                    while (last.next != null) {\n                        last = last.next;\n                    }\n                }\n                var entry = this.trackEntry(trackIndex, animation, loop, last);\n                if (last == null) {\n                    this.setCurrent(trackIndex, entry, true);\n                    this.queue.drain();\n                } else {\n                    last.next = entry;\n                    if (delay <= 0) {\n                        var duration = last.animationEnd - last.animationStart;\n                        if (duration != 0) delay += duration * (1 + (last.trackTime / duration | 0)) - this.data.getMix(last.animation, animation);else delay = 0;\n                    }\n                }\n                entry.delay = delay;\n                return entry;\n            };\n            AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\n                var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n                entry.mixDuration = mixDuration;\n                entry.trackEnd = mixDuration;\n                return entry;\n            };\n            AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\n                if (delay <= 0) delay -= mixDuration;\n                var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n                entry.mixDuration = mixDuration;\n                entry.trackEnd = mixDuration;\n                return entry;\n            };\n            AnimationState.prototype.setEmptyAnimations = function (mixDuration) {\n                var oldDrainDisabled = this.queue.drainDisabled;\n                this.queue.drainDisabled = true;\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\n                    var current = this.tracks[i];\n                    if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n                }\n                this.queue.drainDisabled = oldDrainDisabled;\n                this.queue.drain();\n            };\n            AnimationState.prototype.expandToIndex = function (index) {\n                if (index < this.tracks.length) return this.tracks[index];\n                core.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\n                this.tracks.length = index + 1;\n                return null;\n            };\n            AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\n                var entry = this.trackEntryPool.obtain();\n                entry.trackIndex = trackIndex;\n                entry.animation = animation;\n                entry.loop = loop;\n                entry.eventThreshold = 0;\n                entry.attachmentThreshold = 0;\n                entry.drawOrderThreshold = 0;\n                entry.animationStart = 0;\n                entry.animationEnd = animation.duration;\n                entry.animationLast = -1;\n                entry.nextAnimationLast = -1;\n                entry.delay = 0;\n                entry.trackTime = 0;\n                entry.trackLast = -1;\n                entry.nextTrackLast = -1;\n                entry.trackEnd = Number.MAX_VALUE;\n                entry.timeScale = 1;\n                entry.alpha = 1;\n                entry.interruptAlpha = 1;\n                entry.mixTime = 0;\n                entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n                return entry;\n            };\n            AnimationState.prototype.disposeNext = function (entry) {\n                var next = entry.next;\n                while (next != null) {\n                    this.queue.dispose(next);\n                    next = next.next;\n                }\n                entry.next = null;\n            };\n            AnimationState.prototype._animationsChanged = function () {\n                this.animationsChanged = false;\n                var propertyIDs = this.propertyIDs;\n                propertyIDs.clear();\n                var mixingTo = this.mixingTo;\n                var lastEntry = null;\n                for (var i = 0, n = this.tracks.length; i < n; i++) {\n                    var entry = this.tracks[i];\n                    if (entry != null) entry.setTimelineData(null, mixingTo, propertyIDs);\n                }\n            };\n            AnimationState.prototype.getCurrent = function (trackIndex) {\n                if (trackIndex >= this.tracks.length) return null;\n                return this.tracks[trackIndex];\n            };\n            AnimationState.prototype.addListener = function (listener) {\n                if (listener == null) throw new Error(\"listener cannot be null.\");\n                this.listeners.push(listener);\n            };\n            AnimationState.prototype.removeListener = function (listener) {\n                var index = this.listeners.indexOf(listener);\n                if (index >= 0) this.listeners.splice(index, 1);\n            };\n            AnimationState.prototype.clearListeners = function () {\n                this.listeners.length = 0;\n            };\n            AnimationState.prototype.clearListenerNotifications = function () {\n                this.queue.clear();\n            };\n            AnimationState.prototype.setAnimationByName = function (trackIndex, animationName, loop) {\n                if (!AnimationState.deprecatedWarning1) {\n                    AnimationState.deprecatedWarning1 = true;\n                    console.warn(\"Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n                }\n                this.setAnimation(trackIndex, animationName, loop);\n            };\n            AnimationState.prototype.addAnimationByName = function (trackIndex, animationName, loop, delay) {\n                if (!AnimationState.deprecatedWarning2) {\n                    AnimationState.deprecatedWarning2 = true;\n                    console.warn(\"Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n                }\n                this.addAnimation(trackIndex, animationName, loop, delay);\n            };\n            AnimationState.prototype.hasAnimation = function (animationName) {\n                var animation = this.data.skeletonData.findAnimation(animationName);\n                return animation !== null;\n            };\n            AnimationState.prototype.hasAnimationByName = function (animationName) {\n                if (!AnimationState.deprecatedWarning3) {\n                    AnimationState.deprecatedWarning3 = true;\n                    console.warn(\"Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n                }\n                return this.hasAnimation(animationName);\n            };\n            return AnimationState;\n        }();\n        AnimationState.emptyAnimation = new core.Animation(\"<empty>\", [], 0);\n        AnimationState.SUBSEQUENT = 0;\n        AnimationState.FIRST = 1;\n        AnimationState.DIP = 2;\n        AnimationState.DIP_MIX = 3;\n        AnimationState.deprecatedWarning1 = false;\n        AnimationState.deprecatedWarning2 = false;\n        AnimationState.deprecatedWarning3 = false;\n        core.AnimationState = AnimationState;\n        var TrackEntry = function () {\n            function TrackEntry() {\n                this.timelineData = new Array();\n                this.timelineDipMix = new Array();\n                this.timelinesRotation = new Array();\n            }\n            TrackEntry.prototype.reset = function () {\n                this.next = null;\n                this.mixingFrom = null;\n                this.animation = null;\n                this.listener = null;\n                this.timelineData.length = 0;\n                this.timelineDipMix.length = 0;\n                this.timelinesRotation.length = 0;\n            };\n            TrackEntry.prototype.setTimelineData = function (to, mixingToArray, propertyIDs) {\n                if (to != null) mixingToArray.push(to);\n                var lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;\n                if (to != null) mixingToArray.pop();\n                var mixingTo = mixingToArray;\n                var mixingToLast = mixingToArray.length - 1;\n                var timelines = this.animation.timelines;\n                var timelinesCount = this.animation.timelines.length;\n                var timelineData = core.Utils.setArraySize(this.timelineData, timelinesCount);\n                this.timelineDipMix.length = 0;\n                var timelineDipMix = core.Utils.setArraySize(this.timelineDipMix, timelinesCount);\n                outer: for (var i = 0; i < timelinesCount; i++) {\n                    var id = timelines[i].getPropertyId();\n                    if (!propertyIDs.add(id)) timelineData[i] = AnimationState.SUBSEQUENT;else if (to == null || !to.hasTimeline(id)) timelineData[i] = AnimationState.FIRST;else {\n                        for (var ii = mixingToLast; ii >= 0; ii--) {\n                            var entry = mixingTo[ii];\n                            if (!entry.hasTimeline(id)) {\n                                if (entry.mixDuration > 0) {\n                                    timelineData[i] = AnimationState.DIP_MIX;\n                                    timelineDipMix[i] = entry;\n                                    continue outer;\n                                }\n                            }\n                        }\n                        timelineData[i] = AnimationState.DIP;\n                    }\n                }\n                return lastEntry;\n            };\n            TrackEntry.prototype.hasTimeline = function (id) {\n                var timelines = this.animation.timelines;\n                for (var i = 0, n = timelines.length; i < n; i++) {\n                    if (timelines[i].getPropertyId() == id) return true;\n                }return false;\n            };\n            TrackEntry.prototype.getAnimationTime = function () {\n                if (this.loop) {\n                    var duration = this.animationEnd - this.animationStart;\n                    if (duration == 0) return this.animationStart;\n                    return this.trackTime % duration + this.animationStart;\n                }\n                return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n            };\n            TrackEntry.prototype.setAnimationLast = function (animationLast) {\n                this.animationLast = animationLast;\n                this.nextAnimationLast = animationLast;\n            };\n            TrackEntry.prototype.isComplete = function () {\n                return this.trackTime >= this.animationEnd - this.animationStart;\n            };\n            TrackEntry.prototype.resetRotationDirections = function () {\n                this.timelinesRotation.length = 0;\n            };\n            Object.defineProperty(TrackEntry.prototype, \"time\", {\n                get: function get() {\n                    if (!TrackEntry.deprecatedWarning1) {\n                        TrackEntry.deprecatedWarning1 = true;\n                        console.warn(\"Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n                    }\n                    return this.trackTime;\n                },\n                set: function set(value) {\n                    if (!TrackEntry.deprecatedWarning1) {\n                        TrackEntry.deprecatedWarning1 = true;\n                        console.warn(\"Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n                    }\n                    this.trackTime = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TrackEntry.prototype, \"endTime\", {\n                get: function get() {\n                    if (!TrackEntry.deprecatedWarning2) {\n                        TrackEntry.deprecatedWarning2 = true;\n                        console.warn(\"Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n                    }\n                    return this.trackTime;\n                },\n                set: function set(value) {\n                    if (!TrackEntry.deprecatedWarning2) {\n                        TrackEntry.deprecatedWarning2 = true;\n                        console.warn(\"Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n                    }\n                    this.trackTime = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            TrackEntry.prototype.loopsCount = function () {\n                return Math.floor(this.trackTime / this.trackEnd);\n            };\n            return TrackEntry;\n        }();\n        TrackEntry.deprecatedWarning1 = false;\n        TrackEntry.deprecatedWarning2 = false;\n        core.TrackEntry = TrackEntry;\n        var EventQueue = function () {\n            function EventQueue(animState) {\n                this.objects = [];\n                this.drainDisabled = false;\n                this.animState = animState;\n            }\n            EventQueue.prototype.start = function (entry) {\n                this.objects.push(EventType.start);\n                this.objects.push(entry);\n                this.animState.animationsChanged = true;\n            };\n            EventQueue.prototype.interrupt = function (entry) {\n                this.objects.push(EventType.interrupt);\n                this.objects.push(entry);\n            };\n            EventQueue.prototype.end = function (entry) {\n                this.objects.push(EventType.end);\n                this.objects.push(entry);\n                this.animState.animationsChanged = true;\n            };\n            EventQueue.prototype.dispose = function (entry) {\n                this.objects.push(EventType.dispose);\n                this.objects.push(entry);\n            };\n            EventQueue.prototype.complete = function (entry) {\n                this.objects.push(EventType.complete);\n                this.objects.push(entry);\n            };\n            EventQueue.prototype.event = function (entry, event) {\n                this.objects.push(EventType.event);\n                this.objects.push(entry);\n                this.objects.push(event);\n            };\n            EventQueue.prototype.deprecateStuff = function () {\n                if (!EventQueue.deprecatedWarning1) {\n                    EventQueue.deprecatedWarning1 = true;\n                    console.warn(\"Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\n                }\n                return true;\n            };\n            EventQueue.prototype.drain = function () {\n                if (this.drainDisabled) return;\n                this.drainDisabled = true;\n                var objects = this.objects;\n                var listeners = this.animState.listeners;\n                for (var i = 0; i < objects.length; i += 2) {\n                    var type = objects[i];\n                    var entry = objects[i + 1];\n                    switch (type) {\n                        case EventType.start:\n                            if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].start) listeners[ii].start(entry);\n                            }entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                            this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                            break;\n                        case EventType.interrupt:\n                            if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                            }break;\n                        case EventType.end:\n                            if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].end) listeners[ii].end(entry);\n                            }entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                            this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                        case EventType.dispose:\n                            if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                            }this.animState.trackEntryPool.free(entry);\n                            break;\n                        case EventType.complete:\n                            if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].complete) listeners[ii].complete(entry);\n                            }var count = core.MathUtils.toInt(entry.loopsCount());\n                            entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                            this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                            break;\n                        case EventType.event:\n                            var event_3 = objects[i++ + 2];\n                            if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event_3);\n                            for (var ii = 0; ii < listeners.length; ii++) {\n                                if (listeners[ii].event) listeners[ii].event(entry, event_3);\n                            }entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);\n                            this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);\n                            break;\n                    }\n                }\n                this.clear();\n                this.drainDisabled = false;\n            };\n            EventQueue.prototype.clear = function () {\n                this.objects.length = 0;\n            };\n            return EventQueue;\n        }();\n        EventQueue.deprecatedWarning1 = false;\n        core.EventQueue = EventQueue;\n        var EventType;\n        (function (EventType) {\n            EventType[EventType[\"start\"] = 0] = \"start\";\n            EventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\n            EventType[EventType[\"end\"] = 2] = \"end\";\n            EventType[EventType[\"dispose\"] = 3] = \"dispose\";\n            EventType[EventType[\"complete\"] = 4] = \"complete\";\n            EventType[EventType[\"event\"] = 5] = \"event\";\n        })(EventType = core.EventType || (core.EventType = {}));\n        var AnimationStateAdapter2 = function () {\n            function AnimationStateAdapter2() {}\n            AnimationStateAdapter2.prototype.start = function (entry) {};\n            AnimationStateAdapter2.prototype.interrupt = function (entry) {};\n            AnimationStateAdapter2.prototype.end = function (entry) {};\n            AnimationStateAdapter2.prototype.dispose = function (entry) {};\n            AnimationStateAdapter2.prototype.complete = function (entry) {};\n            AnimationStateAdapter2.prototype.event = function (entry, event) {};\n            return AnimationStateAdapter2;\n        }();\n        core.AnimationStateAdapter2 = AnimationStateAdapter2;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var AnimationStateData = function () {\n            function AnimationStateData(skeletonData) {\n                this.animationToMixTime = {};\n                this.defaultMix = 0;\n                if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n                this.skeletonData = skeletonData;\n            }\n            AnimationStateData.prototype.setMix = function (fromName, toName, duration) {\n                var from = this.skeletonData.findAnimation(fromName);\n                if (from == null) throw new Error(\"Animation not found: \" + fromName);\n                var to = this.skeletonData.findAnimation(toName);\n                if (to == null) throw new Error(\"Animation not found: \" + toName);\n                this.setMixWith(from, to, duration);\n            };\n            AnimationStateData.prototype.setMixByName = function (fromName, toName, duration) {\n                if (!AnimationStateData.deprecatedWarning1) {\n                    AnimationStateData.deprecatedWarning1 = true;\n                    console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n                }\n                this.setMix(fromName, toName, duration);\n            };\n            AnimationStateData.prototype.setMixWith = function (from, to, duration) {\n                if (from == null) throw new Error(\"from cannot be null.\");\n                if (to == null) throw new Error(\"to cannot be null.\");\n                var key = from.name + to.name;\n                this.animationToMixTime[key] = duration;\n            };\n            AnimationStateData.prototype.getMix = function (from, to) {\n                var key = from.name + to.name;\n                var value = this.animationToMixTime[key];\n                return value === undefined ? this.defaultMix : value;\n            };\n            return AnimationStateData;\n        }();\n        AnimationStateData.deprecatedWarning1 = false;\n        core.AnimationStateData = AnimationStateData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var AtlasAttachmentLoader = function () {\n            function AtlasAttachmentLoader(atlas) {\n                this.atlas = atlas;\n            }\n            AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\n                var region = this.atlas.findRegion(path);\n                if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n                var attachment = new core.RegionAttachment(name);\n                attachment.region = region;\n                return attachment;\n            };\n            AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\n                var region = this.atlas.findRegion(path);\n                if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n                var attachment = new core.MeshAttachment(name);\n                attachment.region = region;\n                return attachment;\n            };\n            AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\n                return new core.BoundingBoxAttachment(name);\n            };\n            AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\n                return new core.PathAttachment(name);\n            };\n            AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\n                return new core.PointAttachment(name);\n            };\n            AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\n                return new core.ClippingAttachment(name);\n            };\n            return AtlasAttachmentLoader;\n        }();\n        core.AtlasAttachmentLoader = AtlasAttachmentLoader;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Attachment = function () {\n            function Attachment(name) {\n                if (name == null) throw new Error(\"name cannot be null.\");\n                this.name = name;\n            }\n            return Attachment;\n        }();\n        core.Attachment = Attachment;\n        var VertexAttachment = function (_super) {\n            __extends(VertexAttachment, _super);\n            function VertexAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.id = (VertexAttachment.nextID++ & 65535) << 11;\n                _this.worldVerticesLength = 0;\n                return _this;\n            }\n            VertexAttachment.prototype.computeWorldVerticesOld = function (slot, worldVertices) {\n                this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n            };\n            VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\n                count = offset + (count >> 1) * stride;\n                var skeleton = slot.bone.skeleton;\n                var deformArray = slot.attachmentVertices;\n                var vertices = this.vertices;\n                var bones = this.bones;\n                if (bones == null) {\n                    if (deformArray.length > 0) vertices = deformArray;\n                    var mat = slot.bone.matrix;\n                    var x = mat.tx;\n                    var y = mat.ty;\n                    var a = mat.a,\n                        b = mat.c,\n                        c = mat.b,\n                        d = mat.d;\n                    for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\n                        var vx = vertices[v_1],\n                            vy = vertices[v_1 + 1];\n                        worldVertices[w] = vx * a + vy * b + x;\n                        worldVertices[w + 1] = vx * c + vy * d + y;\n                    }\n                    return;\n                }\n                var v = 0,\n                    skip = 0;\n                for (var i = 0; i < start; i += 2) {\n                    var n = bones[v];\n                    v += n + 1;\n                    skip += n;\n                }\n                var skeletonBones = skeleton.bones;\n                if (deformArray.length == 0) {\n                    for (var w = offset, b = skip * 3; w < count; w += stride) {\n                        var wx = 0,\n                            wy = 0;\n                        var n = bones[v++];\n                        n += v;\n                        for (; v < n; v++, b += 3) {\n                            var mat = skeletonBones[bones[v]].matrix;\n                            var vx = vertices[b],\n                                vy = vertices[b + 1],\n                                weight = vertices[b + 2];\n                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                        }\n                        worldVertices[w] = wx;\n                        worldVertices[w + 1] = wy;\n                    }\n                } else {\n                    var deform = deformArray;\n                    for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                        var wx = 0,\n                            wy = 0;\n                        var n = bones[v++];\n                        n += v;\n                        for (; v < n; v++, b += 3, f += 2) {\n                            var mat = skeletonBones[bones[v]].matrix;\n                            var vx = vertices[b] + deform[f],\n                                vy = vertices[b + 1] + deform[f + 1],\n                                weight = vertices[b + 2];\n                            wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                            wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                        }\n                        worldVertices[w] = wx;\n                        worldVertices[w + 1] = wy;\n                    }\n                }\n            };\n            VertexAttachment.prototype.applyDeform = function (sourceAttachment) {\n                return this == sourceAttachment;\n            };\n            return VertexAttachment;\n        }(Attachment);\n        VertexAttachment.nextID = 0;\n        core.VertexAttachment = VertexAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var AttachmentType;\n        (function (AttachmentType) {\n            AttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\n            AttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\n            AttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\n            AttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\n            AttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\n            AttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\n        })(AttachmentType = core.AttachmentType || (core.AttachmentType = {}));\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var BoundingBoxAttachment = function (_super) {\n            __extends(BoundingBoxAttachment, _super);\n            function BoundingBoxAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.color = new core.Color(1, 1, 1, 1);\n                return _this;\n            }\n            return BoundingBoxAttachment;\n        }(core.VertexAttachment);\n        core.BoundingBoxAttachment = BoundingBoxAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var ClippingAttachment = function (_super) {\n            __extends(ClippingAttachment, _super);\n            function ClippingAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.color = new core.Color(0.2275, 0.2275, 0.8078, 1);\n                return _this;\n            }\n            return ClippingAttachment;\n        }(core.VertexAttachment);\n        core.ClippingAttachment = ClippingAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var MeshAttachment = function (_super) {\n            __extends(MeshAttachment, _super);\n            function MeshAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.color = new core.Color(1, 1, 1, 1);\n                _this.inheritDeform = false;\n                _this.tempColor = new core.Color(0, 0, 0, 0);\n                return _this;\n            }\n            MeshAttachment.prototype.updateUVs = function (region, uvs) {\n                var regionUVs = this.regionUVs;\n                var n = regionUVs.length;\n                if (!uvs || uvs.length != n) {\n                    uvs = core.Utils.newFloatArray(n);\n                }\n                if (region == null) {\n                    return;\n                }\n                var texture = region.texture;\n                var r = texture._uvs;\n                var w1 = region.width,\n                    h1 = region.height,\n                    w2 = region.originalWidth,\n                    h2 = region.originalHeight;\n                var x = region.offsetX,\n                    y = region.pixiOffsetY;\n                for (var i = 0; i < n; i += 2) {\n                    var u = this.regionUVs[i],\n                        v = this.regionUVs[i + 1];\n                    u = (u * w2 - x) / w1;\n                    v = (v * h2 - y) / h1;\n                    uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n                    uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n                }\n                return uvs;\n            };\n            MeshAttachment.prototype.applyDeform = function (sourceAttachment) {\n                return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;\n            };\n            MeshAttachment.prototype.getParentMesh = function () {\n                return this.parentMesh;\n            };\n            MeshAttachment.prototype.setParentMesh = function (parentMesh) {\n                this.parentMesh = parentMesh;\n                if (parentMesh != null) {\n                    this.bones = parentMesh.bones;\n                    this.vertices = parentMesh.vertices;\n                    this.worldVerticesLength = parentMesh.worldVerticesLength;\n                    this.regionUVs = parentMesh.regionUVs;\n                    this.triangles = parentMesh.triangles;\n                    this.hullLength = parentMesh.hullLength;\n                    this.worldVerticesLength = parentMesh.worldVerticesLength;\n                }\n            };\n            return MeshAttachment;\n        }(core.VertexAttachment);\n        core.MeshAttachment = MeshAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var PathAttachment = function (_super) {\n            __extends(PathAttachment, _super);\n            function PathAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.closed = false;\n                _this.constantSpeed = false;\n                _this.color = new core.Color(1, 1, 1, 1);\n                return _this;\n            }\n            return PathAttachment;\n        }(core.VertexAttachment);\n        core.PathAttachment = PathAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var PointAttachment = function (_super) {\n            __extends(PointAttachment, _super);\n            function PointAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.color = new core.Color(0.38, 0.94, 0, 1);\n                return _this;\n            }\n            PointAttachment.prototype.computeWorldPosition = function (bone, point) {\n                var mat = bone.matrix;\n                point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n                point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n                return point;\n            };\n            PointAttachment.prototype.computeWorldRotation = function (bone) {\n                var mat = bone.matrix;\n                var cos = core.MathUtils.cosDeg(this.rotation),\n                    sin = core.MathUtils.sinDeg(this.rotation);\n                var x = cos * mat.a + sin * mat.c;\n                var y = cos * mat.b + sin * mat.d;\n                return Math.atan2(y, x) * core.MathUtils.radDeg;\n            };\n            return PointAttachment;\n        }(core.VertexAttachment);\n        core.PointAttachment = PointAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var RegionAttachment = function (_super) {\n            __extends(RegionAttachment, _super);\n            function RegionAttachment(name) {\n                var _this = _super.call(this, name) || this;\n                _this.x = 0;\n                _this.y = 0;\n                _this.scaleX = 1;\n                _this.scaleY = 1;\n                _this.rotation = 0;\n                _this.width = 0;\n                _this.height = 0;\n                _this.color = new core.Color(1, 1, 1, 1);\n                _this.offset = core.Utils.newFloatArray(8);\n                _this.uvs = core.Utils.newFloatArray(8);\n                _this.tempColor = new core.Color(1, 1, 1, 1);\n                return _this;\n            }\n            RegionAttachment.prototype.updateOffset = function () {\n                var regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n                var regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n                var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n                var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n                var localX2 = localX + this.region.width * regionScaleX;\n                var localY2 = localY + this.region.height * regionScaleY;\n                var radians = this.rotation * Math.PI / 180;\n                var cos = Math.cos(radians);\n                var sin = Math.sin(radians);\n                var localXCos = localX * cos + this.x;\n                var localXSin = localX * sin;\n                var localYCos = localY * cos + this.y;\n                var localYSin = localY * sin;\n                var localX2Cos = localX2 * cos + this.x;\n                var localX2Sin = localX2 * sin;\n                var localY2Cos = localY2 * cos + this.y;\n                var localY2Sin = localY2 * sin;\n                var offset = this.offset;\n                offset[RegionAttachment.OX1] = localXCos - localYSin;\n                offset[RegionAttachment.OY1] = localYCos + localXSin;\n                offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n                offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n                offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n                offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n                offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n                offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n            };\n            RegionAttachment.prototype.setRegion = function (region) {\n                this.region = region;\n                var uvs = this.uvs;\n                if (region.rotate) {\n                    uvs[2] = region.u;\n                    uvs[3] = region.v2;\n                    uvs[4] = region.u;\n                    uvs[5] = region.v;\n                    uvs[6] = region.u2;\n                    uvs[7] = region.v;\n                    uvs[0] = region.u2;\n                    uvs[1] = region.v2;\n                } else {\n                    uvs[0] = region.u;\n                    uvs[1] = region.v2;\n                    uvs[2] = region.u;\n                    uvs[3] = region.v;\n                    uvs[4] = region.u2;\n                    uvs[5] = region.v;\n                    uvs[6] = region.u2;\n                    uvs[7] = region.v2;\n                }\n            };\n            RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\n                var vertexOffset = this.offset;\n                var mat = bone.matrix;\n                var x = mat.tx,\n                    y = mat.ty;\n                var a = mat.a,\n                    b = mat.c,\n                    c = mat.b,\n                    d = mat.d;\n                var offsetX = 0,\n                    offsetY = 0;\n                offsetX = vertexOffset[RegionAttachment.OX1];\n                offsetY = vertexOffset[RegionAttachment.OY1];\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n                offset += stride;\n                offsetX = vertexOffset[RegionAttachment.OX2];\n                offsetY = vertexOffset[RegionAttachment.OY2];\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n                offset += stride;\n                offsetX = vertexOffset[RegionAttachment.OX3];\n                offsetY = vertexOffset[RegionAttachment.OY3];\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n                offset += stride;\n                offsetX = vertexOffset[RegionAttachment.OX4];\n                offsetY = vertexOffset[RegionAttachment.OY4];\n                worldVertices[offset] = offsetX * a + offsetY * b + x;\n                worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            };\n            return RegionAttachment;\n        }(core.Attachment);\n        RegionAttachment.OX1 = 0;\n        RegionAttachment.OY1 = 1;\n        RegionAttachment.OX2 = 2;\n        RegionAttachment.OY2 = 3;\n        RegionAttachment.OX3 = 4;\n        RegionAttachment.OY3 = 5;\n        RegionAttachment.OX4 = 6;\n        RegionAttachment.OY4 = 7;\n        RegionAttachment.X1 = 0;\n        RegionAttachment.Y1 = 1;\n        RegionAttachment.C1R = 2;\n        RegionAttachment.C1G = 3;\n        RegionAttachment.C1B = 4;\n        RegionAttachment.C1A = 5;\n        RegionAttachment.U1 = 6;\n        RegionAttachment.V1 = 7;\n        RegionAttachment.X2 = 8;\n        RegionAttachment.Y2 = 9;\n        RegionAttachment.C2R = 10;\n        RegionAttachment.C2G = 11;\n        RegionAttachment.C2B = 12;\n        RegionAttachment.C2A = 13;\n        RegionAttachment.U2 = 14;\n        RegionAttachment.V2 = 15;\n        RegionAttachment.X3 = 16;\n        RegionAttachment.Y3 = 17;\n        RegionAttachment.C3R = 18;\n        RegionAttachment.C3G = 19;\n        RegionAttachment.C3B = 20;\n        RegionAttachment.C3A = 21;\n        RegionAttachment.U3 = 22;\n        RegionAttachment.V3 = 23;\n        RegionAttachment.X4 = 24;\n        RegionAttachment.Y4 = 25;\n        RegionAttachment.C4R = 26;\n        RegionAttachment.C4G = 27;\n        RegionAttachment.C4B = 28;\n        RegionAttachment.C4A = 29;\n        RegionAttachment.U4 = 30;\n        RegionAttachment.V4 = 31;\n        core.RegionAttachment = RegionAttachment;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var BlendMode;\n        (function (BlendMode) {\n            BlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\n            BlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\n            BlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\n            BlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\n        })(BlendMode = core.BlendMode || (core.BlendMode = {}));\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Bone = function () {\n            function Bone(data, skeleton, parent) {\n                this.matrix = new PIXI.Matrix();\n                this.children = new Array();\n                this.x = 0;\n                this.y = 0;\n                this.rotation = 0;\n                this.scaleX = 0;\n                this.scaleY = 0;\n                this.shearX = 0;\n                this.shearY = 0;\n                this.ax = 0;\n                this.ay = 0;\n                this.arotation = 0;\n                this.ascaleX = 0;\n                this.ascaleY = 0;\n                this.ashearX = 0;\n                this.ashearY = 0;\n                this.appliedValid = false;\n                this.sorted = false;\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                this.data = data;\n                this.skeleton = skeleton;\n                this.parent = parent;\n                this.setToSetupPose();\n            }\n            Object.defineProperty(Bone.prototype, \"worldX\", {\n                get: function get() {\n                    return this.matrix.tx;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(Bone.prototype, \"worldY\", {\n                get: function get() {\n                    return this.matrix.ty;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Bone.prototype.update = function () {\n                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n            };\n            Bone.prototype.updateWorldTransform = function () {\n                this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n            };\n            Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\n                this.ax = x;\n                this.ay = y;\n                this.arotation = rotation;\n                this.ascaleX = scaleX;\n                this.ascaleY = scaleY;\n                this.ashearX = shearX;\n                this.ashearY = shearY;\n                this.appliedValid = true;\n                var parent = this.parent;\n                var m = this.matrix;\n                if (parent == null) {\n                    var rotationY = rotation + 90 + shearY;\n                    var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    var lb = core.MathUtils.cosDeg(rotationY) * scaleY;\n                    var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    var ld = core.MathUtils.sinDeg(rotationY) * scaleY;\n                    var skeleton = this.skeleton;\n                    if (skeleton.flipX) {\n                        x = -x;\n                        la = -la;\n                        lb = -lb;\n                    }\n                    if (skeleton.flipY !== Bone.yDown) {\n                        y = -y;\n                        lc = -lc;\n                        ld = -ld;\n                    }\n                    m.a = la;\n                    m.c = lb;\n                    m.b = lc;\n                    m.d = ld;\n                    m.tx = x + skeleton.x;\n                    m.ty = y + skeleton.y;\n                    return;\n                }\n                var pa = parent.matrix.a,\n                    pb = parent.matrix.c,\n                    pc = parent.matrix.b,\n                    pd = parent.matrix.d;\n                m.tx = pa * x + pb * y + parent.matrix.tx;\n                m.ty = pc * x + pd * y + parent.matrix.ty;\n                switch (this.data.transformMode) {\n                    case core.TransformMode.Normal:\n                        {\n                            var rotationY = rotation + 90 + shearY;\n                            var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\n                            var lb = core.MathUtils.cosDeg(rotationY) * scaleY;\n                            var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\n                            var ld = core.MathUtils.sinDeg(rotationY) * scaleY;\n                            m.a = pa * la + pb * lc;\n                            m.c = pa * lb + pb * ld;\n                            m.b = pc * la + pd * lc;\n                            m.d = pc * lb + pd * ld;\n                            return;\n                        }\n                    case core.TransformMode.OnlyTranslation:\n                        {\n                            var rotationY = rotation + 90 + shearY;\n                            m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\n                            m.c = core.MathUtils.cosDeg(rotationY) * scaleY;\n                            m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\n                            m.d = core.MathUtils.sinDeg(rotationY) * scaleY;\n                            break;\n                        }\n                    case core.TransformMode.NoRotationOrReflection:\n                        {\n                            var s = pa * pa + pc * pc;\n                            var prx = 0;\n                            if (s > 0.0001) {\n                                s = Math.abs(pa * pd - pb * pc) / s;\n                                pb = pc * s;\n                                pd = pa * s;\n                                prx = Math.atan2(pc, pa) * core.MathUtils.radDeg;\n                            } else {\n                                pa = 0;\n                                pc = 0;\n                                prx = 90 - Math.atan2(pd, pb) * core.MathUtils.radDeg;\n                            }\n                            var rx = rotation + shearX - prx;\n                            var ry = rotation + shearY - prx + 90;\n                            var la = core.MathUtils.cosDeg(rx) * scaleX;\n                            var lb = core.MathUtils.cosDeg(ry) * scaleY;\n                            var lc = core.MathUtils.sinDeg(rx) * scaleX;\n                            var ld = core.MathUtils.sinDeg(ry) * scaleY;\n                            m.a = pa * la - pb * lc;\n                            m.c = pa * lb - pb * ld;\n                            m.b = pc * la + pd * lc;\n                            m.d = pc * lb + pd * ld;\n                            break;\n                        }\n                    case core.TransformMode.NoScale:\n                    case core.TransformMode.NoScaleOrReflection:\n                        {\n                            var cos = core.MathUtils.cosDeg(rotation);\n                            var sin = core.MathUtils.sinDeg(rotation);\n                            var za = pa * cos + pb * sin;\n                            var zc = pc * cos + pd * sin;\n                            var s = Math.sqrt(za * za + zc * zc);\n                            if (s > 0.00001) s = 1 / s;\n                            za *= s;\n                            zc *= s;\n                            s = Math.sqrt(za * za + zc * zc);\n                            var r = Math.PI / 2 + Math.atan2(zc, za);\n                            var zb = Math.cos(r) * s;\n                            var zd = Math.sin(r) * s;\n                            var la = core.MathUtils.cosDeg(shearX) * scaleX;\n                            var lb = core.MathUtils.cosDeg(90 + shearY) * scaleY;\n                            var lc = core.MathUtils.sinDeg(shearX) * scaleX;\n                            var ld = core.MathUtils.sinDeg(90 + shearY) * scaleY;\n                            m.a = za * la + zb * lc;\n                            m.c = za * lb + zb * ld;\n                            m.b = zc * la + zd * lc;\n                            m.d = zc * lb + zd * ld;\n                            if (this.data.transformMode != core.TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : this.skeleton.flipX != this.skeleton.flipY != Bone.yDown) {\n                                m.c = -m.c;\n                                m.d = -m.d;\n                            }\n                            return;\n                        }\n                }\n                if (this.skeleton.flipX) {\n                    m.a = -m.a;\n                    m.c = -m.c;\n                }\n                if (this.skeleton.flipY != Bone.yDown) {\n                    m.b = -m.b;\n                    m.d = -m.d;\n                }\n            };\n            Bone.prototype.setToSetupPose = function () {\n                var data = this.data;\n                this.x = data.x;\n                this.y = data.y;\n                this.rotation = data.rotation;\n                this.scaleX = data.scaleX;\n                this.scaleY = data.scaleY;\n                this.shearX = data.shearX;\n                this.shearY = data.shearY;\n            };\n            Bone.prototype.getWorldRotationX = function () {\n                return Math.atan2(this.matrix.b, this.matrix.a) * core.MathUtils.radDeg;\n            };\n            Bone.prototype.getWorldRotationY = function () {\n                return Math.atan2(this.matrix.d, this.matrix.c) * core.MathUtils.radDeg;\n            };\n            Bone.prototype.getWorldScaleX = function () {\n                var m = this.matrix;\n                return Math.sqrt(m.a * m.a + m.c * m.c);\n            };\n            Bone.prototype.getWorldScaleY = function () {\n                var m = this.matrix;\n                return Math.sqrt(m.b * m.b + m.d * m.d);\n            };\n            Bone.prototype.updateAppliedTransform = function () {\n                this.appliedValid = true;\n                var parent = this.parent;\n                var m = this.matrix;\n                if (parent == null) {\n                    this.ax = m.tx;\n                    this.ay = m.ty;\n                    this.arotation = Math.atan2(m.b, m.a) * core.MathUtils.radDeg;\n                    this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n                    this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n                    this.ashearX = 0;\n                    this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * core.MathUtils.radDeg;\n                    return;\n                }\n                var pm = parent.matrix;\n                var pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n                var dx = m.tx - pm.tx,\n                    dy = m.ty - pm.ty;\n                this.ax = dx * pm.d * pid - dy * pm.c * pid;\n                this.ay = dy * pm.a * pid - dx * pm.b * pid;\n                var ia = pid * pm.d;\n                var id = pid * pm.a;\n                var ib = pid * pm.c;\n                var ic = pid * pm.b;\n                var ra = ia * m.a - ib * m.b;\n                var rb = ia * m.c - ib * m.d;\n                var rc = id * m.b - ic * m.a;\n                var rd = id * m.d - ic * m.c;\n                this.ashearX = 0;\n                this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n                if (this.ascaleX > 0.0001) {\n                    var det = ra * rd - rb * rc;\n                    this.ascaleY = det / this.ascaleX;\n                    this.ashearY = Math.atan2(ra * rb + rc * rd, det) * core.MathUtils.radDeg;\n                    this.arotation = Math.atan2(rc, ra) * core.MathUtils.radDeg;\n                } else {\n                    this.ascaleX = 0;\n                    this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n                    this.ashearY = 0;\n                    this.arotation = 90 - Math.atan2(rd, rb) * core.MathUtils.radDeg;\n                }\n            };\n            Bone.prototype.worldToLocal = function (world) {\n                var m = this.matrix;\n                var a = m.a,\n                    b = m.c,\n                    c = m.b,\n                    d = m.d;\n                var invDet = 1 / (a * d - b * c);\n                var x = world.x - m.tx,\n                    y = world.y - m.ty;\n                world.x = x * d * invDet - y * b * invDet;\n                world.y = y * a * invDet - x * c * invDet;\n                return world;\n            };\n            Bone.prototype.localToWorld = function (local) {\n                var m = this.matrix;\n                var x = local.x,\n                    y = local.y;\n                local.x = x * m.a + y * m.c + m.tx;\n                local.y = x * m.b + y * m.d + m.ty;\n                return local;\n            };\n            Bone.prototype.worldToLocalRotation = function (worldRotation) {\n                var sin = core.MathUtils.sinDeg(worldRotation),\n                    cos = core.MathUtils.cosDeg(worldRotation);\n                var mat = this.matrix;\n                return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * core.MathUtils.radDeg;\n            };\n            Bone.prototype.localToWorldRotation = function (localRotation) {\n                var sin = core.MathUtils.sinDeg(localRotation),\n                    cos = core.MathUtils.cosDeg(localRotation);\n                var mat = this.matrix;\n                return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * core.MathUtils.radDeg;\n            };\n            Bone.prototype.rotateWorld = function (degrees) {\n                var mat = this.matrix;\n                var a = mat.a,\n                    b = mat.c,\n                    c = mat.b,\n                    d = mat.d;\n                var cos = core.MathUtils.cosDeg(degrees),\n                    sin = core.MathUtils.sinDeg(degrees);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n                this.appliedValid = false;\n            };\n            return Bone;\n        }();\n        Bone.yDown = false;\n        core.Bone = Bone;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var BoneData = function () {\n            function BoneData(index, name, parent) {\n                this.x = 0;\n                this.y = 0;\n                this.rotation = 0;\n                this.scaleX = 1;\n                this.scaleY = 1;\n                this.shearX = 0;\n                this.shearY = 0;\n                this.transformMode = TransformMode.Normal;\n                if (index < 0) throw new Error(\"index must be >= 0.\");\n                if (name == null) throw new Error(\"name cannot be null.\");\n                this.index = index;\n                this.name = name;\n                this.parent = parent;\n            }\n            return BoneData;\n        }();\n        core.BoneData = BoneData;\n        var TransformMode;\n        (function (TransformMode) {\n            TransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\n            TransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\n            TransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\n            TransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\n            TransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\n        })(TransformMode = core.TransformMode || (core.TransformMode = {}));\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Event = function () {\n            function Event(time, data) {\n                if (data == null) throw new Error(\"data cannot be null.\");\n                this.time = time;\n                this.data = data;\n            }\n            return Event;\n        }();\n        core.Event = Event;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var EventData = function () {\n            function EventData(name) {\n                this.name = name;\n            }\n            return EventData;\n        }();\n        core.EventData = EventData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var IkConstraint = function () {\n            function IkConstraint(data, skeleton) {\n                this.mix = 1;\n                this.bendDirection = 0;\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                this.data = data;\n                this.mix = data.mix;\n                this.bendDirection = data.bendDirection;\n                this.bones = new Array();\n                for (var i = 0; i < data.bones.length; i++) {\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\n                }this.target = skeleton.findBone(data.target.name);\n            }\n            IkConstraint.prototype.getOrder = function () {\n                return this.data.order;\n            };\n            IkConstraint.prototype.apply = function () {\n                this.update();\n            };\n            IkConstraint.prototype.update = function () {\n                var target = this.target;\n                var bones = this.bones;\n                switch (bones.length) {\n                    case 1:\n                        this.apply1(bones[0], target.worldX, target.worldY, this.mix);\n                        break;\n                    case 2:\n                        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n                        break;\n                }\n            };\n            IkConstraint.prototype.apply1 = function (bone, targetX, targetY, alpha) {\n                if (!bone.appliedValid) bone.updateAppliedTransform();\n                var p = bone.parent.matrix;\n                var id = 1 / (p.a * p.d - p.b * p.c);\n                var x = targetX - p.tx,\n                    y = targetY - p.ty;\n                var tx = (x * p.d - y * p.c) * id - bone.ax,\n                    ty = (y * p.a - x * p.b) * id - bone.ay;\n                var rotationIK = Math.atan2(ty, tx) * core.MathUtils.radDeg - bone.ashearX - bone.arotation;\n                if (bone.ascaleX < 0) rotationIK += 180;\n                if (rotationIK > 180) rotationIK -= 360;else if (rotationIK < -180) rotationIK += 360;\n                bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX, bone.ashearY);\n            };\n            IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, alpha) {\n                if (alpha == 0) {\n                    child.updateWorldTransform();\n                    return;\n                }\n                if (!parent.appliedValid) parent.updateAppliedTransform();\n                if (!child.appliedValid) child.updateAppliedTransform();\n                var px = parent.ax,\n                    py = parent.ay,\n                    psx = parent.ascaleX,\n                    psy = parent.ascaleY,\n                    csx = child.ascaleX;\n                var pmat = parent.matrix;\n                var os1 = 0,\n                    os2 = 0,\n                    s2 = 0;\n                if (psx < 0) {\n                    psx = -psx;\n                    os1 = 180;\n                    s2 = -1;\n                } else {\n                    os1 = 0;\n                    s2 = 1;\n                }\n                if (psy < 0) {\n                    psy = -psy;\n                    s2 = -s2;\n                }\n                if (csx < 0) {\n                    csx = -csx;\n                    os2 = 180;\n                } else os2 = 0;\n                var cx = child.ax,\n                    cy = 0,\n                    cwx = 0,\n                    cwy = 0,\n                    a = pmat.a,\n                    b = pmat.c,\n                    c = pmat.b,\n                    d = pmat.d;\n                var u = Math.abs(psx - psy) <= 0.0001;\n                if (!u) {\n                    cy = 0;\n                    cwx = a * cx + pmat.tx;\n                    cwy = c * cx + pmat.ty;\n                } else {\n                    cy = child.ay;\n                    cwx = a * cx + b * cy + pmat.tx;\n                    cwy = c * cx + d * cy + pmat.ty;\n                }\n                var pp = parent.parent.matrix;\n                a = pp.a;\n                b = pp.c;\n                c = pp.b;\n                d = pp.d;\n                var id = 1 / (a * d - b * c),\n                    x = targetX - pp.tx,\n                    y = targetY - pp.ty;\n                var tx = (x * d - y * b) * id - px,\n                    ty = (y * a - x * c) * id - py;\n                x = cwx - pp.tx;\n                y = cwy - pp.ty;\n                var dx = (x * d - y * b) * id - px,\n                    dy = (y * a - x * c) * id - py;\n                var l1 = Math.sqrt(dx * dx + dy * dy),\n                    l2 = child.data.length * csx,\n                    a1 = 0,\n                    a2 = 0;\n                outer: if (u) {\n                    l2 *= psx;\n                    var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n                    if (cos < -1) cos = -1;else if (cos > 1) cos = 1;\n                    a2 = Math.acos(cos) * bendDir;\n                    a = l1 + l2 * cos;\n                    b = l2 * Math.sin(a2);\n                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n                } else {\n                    a = psx * l2;\n                    b = psy * l2;\n                    var aa = a * a,\n                        bb = b * b,\n                        dd = tx * tx + ty * ty,\n                        ta = Math.atan2(ty, tx);\n                    c = bb * l1 * l1 + aa * dd - aa * bb;\n                    var c1 = -2 * bb * l1,\n                        c2 = bb - aa;\n                    d = c1 * c1 - 4 * c2 * c;\n                    if (d >= 0) {\n                        var q = Math.sqrt(d);\n                        if (c1 < 0) q = -q;\n                        q = -(c1 + q) / 2;\n                        var r0 = q / c2,\n                            r1 = c / q;\n                        var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                        if (r * r <= dd) {\n                            y = Math.sqrt(dd - r * r) * bendDir;\n                            a1 = ta - Math.atan2(y, r);\n                            a2 = Math.atan2(y / psy, (r - l1) / psx);\n                            break outer;\n                        }\n                    }\n                    var minAngle = core.MathUtils.PI,\n                        minX = l1 - a,\n                        minDist = minX * minX,\n                        minY = 0;\n                    var maxAngle = 0,\n                        maxX = l1 + a,\n                        maxDist = maxX * maxX,\n                        maxY = 0;\n                    c = -a * l1 / (aa - bb);\n                    if (c >= -1 && c <= 1) {\n                        c = Math.acos(c);\n                        x = a * Math.cos(c) + l1;\n                        y = b * Math.sin(c);\n                        d = x * x + y * y;\n                        if (d < minDist) {\n                            minAngle = c;\n                            minDist = d;\n                            minX = x;\n                            minY = y;\n                        }\n                        if (d > maxDist) {\n                            maxAngle = c;\n                            maxDist = d;\n                            maxX = x;\n                            maxY = y;\n                        }\n                    }\n                    if (dd <= (minDist + maxDist) / 2) {\n                        a1 = ta - Math.atan2(minY * bendDir, minX);\n                        a2 = minAngle * bendDir;\n                    } else {\n                        a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                        a2 = maxAngle * bendDir;\n                    }\n                }\n                var os = Math.atan2(cy, cx) * s2;\n                var rotation = parent.arotation;\n                a1 = (a1 - os) * core.MathUtils.radDeg + os1 - rotation;\n                if (a1 > 180) a1 -= 360;else if (a1 < -180) a1 += 360;\n                parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);\n                rotation = child.arotation;\n                a2 = ((a2 + os) * core.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n                if (a2 > 180) a2 -= 360;else if (a2 < -180) a2 += 360;\n                child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n            };\n            return IkConstraint;\n        }();\n        core.IkConstraint = IkConstraint;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var IkConstraintData = function () {\n            function IkConstraintData(name) {\n                this.order = 0;\n                this.bones = new Array();\n                this.bendDirection = 1;\n                this.mix = 1;\n                this.name = name;\n            }\n            return IkConstraintData;\n        }();\n        core.IkConstraintData = IkConstraintData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var PathConstraint = function () {\n            function PathConstraint(data, skeleton) {\n                this.position = 0;\n                this.spacing = 0;\n                this.rotateMix = 0;\n                this.translateMix = 0;\n                this.spaces = new Array();\n                this.positions = new Array();\n                this.world = new Array();\n                this.curves = new Array();\n                this.lengths = new Array();\n                this.segments = new Array();\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                this.data = data;\n                this.bones = new Array();\n                for (var i = 0, n = data.bones.length; i < n; i++) {\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\n                }this.target = skeleton.findSlot(data.target.name);\n                this.position = data.position;\n                this.spacing = data.spacing;\n                this.rotateMix = data.rotateMix;\n                this.translateMix = data.translateMix;\n            }\n            PathConstraint.prototype.apply = function () {\n                this.update();\n            };\n            PathConstraint.prototype.update = function () {\n                var attachment = this.target.getAttachment();\n                if (!(attachment instanceof core.PathAttachment)) return;\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix;\n                var translate = translateMix > 0,\n                    rotate = rotateMix > 0;\n                if (!translate && !rotate) return;\n                var data = this.data;\n                var spacingMode = data.spacingMode;\n                var lengthSpacing = spacingMode == core.SpacingMode.Length;\n                var rotateMode = data.rotateMode;\n                var tangents = rotateMode == core.RotateMode.Tangent,\n                    scale = rotateMode == core.RotateMode.ChainScale;\n                var boneCount = this.bones.length,\n                    spacesCount = tangents ? boneCount : boneCount + 1;\n                var bones = this.bones;\n                var spaces = core.Utils.setArraySize(this.spaces, spacesCount),\n                    lengths = null;\n                var spacing = this.spacing;\n                if (scale || lengthSpacing) {\n                    if (scale) lengths = core.Utils.setArraySize(this.lengths, boneCount);\n                    for (var i = 0, n = spacesCount - 1; i < n;) {\n                        var bone = bones[i];\n                        var setupLength = bone.data.length,\n                            x = setupLength * bone.matrix.a,\n                            y = setupLength * bone.matrix.b;\n                        var length_1 = Math.sqrt(x * x + y * y);\n                        if (scale) lengths[i] = length_1;\n                        spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;\n                    }\n                } else {\n                    for (var i = 1; i < spacesCount; i++) {\n                        spaces[i] = spacing;\n                    }\n                }\n                var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == core.PositionMode.Percent, spacingMode == core.SpacingMode.Percent);\n                var boneX = positions[0],\n                    boneY = positions[1],\n                    offsetRotation = data.offsetRotation;\n                var tip = false;\n                if (offsetRotation == 0) tip = rotateMode == core.RotateMode.Chain;else {\n                    tip = false;\n                    var p = this.target.bone.matrix;\n                    offsetRotation *= p.a * p.d - p.b * p.c > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n                }\n                for (var i = 0, p = 3; i < boneCount; i++, p += 3) {\n                    var bone = bones[i];\n                    var mat = bone.matrix;\n                    mat.tx += (boneX - mat.tx) * translateMix;\n                    mat.ty += (boneY - mat.ty) * translateMix;\n                    var x = positions[p],\n                        y = positions[p + 1],\n                        dx = x - boneX,\n                        dy = y - boneY;\n                    if (scale) {\n                        var length_2 = lengths[i];\n                        if (length_2 != 0) {\n                            var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;\n                            mat.a *= s;\n                            mat.b *= s;\n                        }\n                    }\n                    boneX = x;\n                    boneY = y;\n                    if (rotate) {\n                        var a = mat.a,\n                            b = mat.c,\n                            c = mat.b,\n                            d = mat.d,\n                            r = 0,\n                            cos = 0,\n                            sin = 0;\n                        if (tangents) r = positions[p - 1];else if (spaces[i + 1] == 0) r = positions[p + 2];else r = Math.atan2(dy, dx);\n                        r -= Math.atan2(c, a);\n                        if (tip) {\n                            cos = Math.cos(r);\n                            sin = Math.sin(r);\n                            var length_3 = bone.data.length;\n                            boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;\n                            boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;\n                        } else {\n                            r += offsetRotation;\n                        }\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        r *= rotateMix;\n                        cos = Math.cos(r);\n                        sin = Math.sin(r);\n                        mat.a = cos * a - sin * c;\n                        mat.c = cos * b - sin * d;\n                        mat.b = sin * a + cos * c;\n                        mat.d = sin * b + cos * d;\n                    }\n                    bone.appliedValid = false;\n                }\n            };\n            PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\n                var target = this.target;\n                var position = this.position;\n                var spaces = this.spaces,\n                    out = core.Utils.setArraySize(this.positions, spacesCount * 3 + 2),\n                    world = null;\n                var closed = path.closed;\n                var verticesLength = path.worldVerticesLength,\n                    curveCount = verticesLength / 6,\n                    prevCurve = PathConstraint.NONE;\n                if (!path.constantSpeed) {\n                    var lengths = path.lengths;\n                    curveCount -= closed ? 1 : 2;\n                    var pathLength_1 = lengths[curveCount];\n                    if (percentPosition) position *= pathLength_1;\n                    if (percentSpacing) {\n                        for (var i = 0; i < spacesCount; i++) {\n                            spaces[i] *= pathLength_1;\n                        }\n                    }\n                    world = core.Utils.setArraySize(this.world, 8);\n                    for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                        var space = spaces[i];\n                        position += space;\n                        var p = position;\n                        if (closed) {\n                            p %= pathLength_1;\n                            if (p < 0) p += pathLength_1;\n                            curve = 0;\n                        } else if (p < 0) {\n                            if (prevCurve != PathConstraint.BEFORE) {\n                                prevCurve = PathConstraint.BEFORE;\n                                path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                            }\n                            this.addBeforePosition(p, world, 0, out, o);\n                            continue;\n                        } else if (p > pathLength_1) {\n                            if (prevCurve != PathConstraint.AFTER) {\n                                prevCurve = PathConstraint.AFTER;\n                                path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                            }\n                            this.addAfterPosition(p - pathLength_1, world, 0, out, o);\n                            continue;\n                        }\n                        for (;; curve++) {\n                            var length_4 = lengths[curve];\n                            if (p > length_4) continue;\n                            if (curve == 0) p /= length_4;else {\n                                var prev = lengths[curve - 1];\n                                p = (p - prev) / (length_4 - prev);\n                            }\n                            break;\n                        }\n                        if (curve != prevCurve) {\n                            prevCurve = curve;\n                            if (closed && curve == curveCount) {\n                                path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                                path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                            } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                        }\n                        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n                    }\n                    return out;\n                }\n                if (closed) {\n                    verticesLength += 2;\n                    world = core.Utils.setArraySize(this.world, verticesLength);\n                    path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n                    path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n                    world[verticesLength - 2] = world[0];\n                    world[verticesLength - 1] = world[1];\n                } else {\n                    curveCount--;\n                    verticesLength -= 4;\n                    world = core.Utils.setArraySize(this.world, verticesLength);\n                    path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n                }\n                var curves = core.Utils.setArraySize(this.curves, curveCount);\n                var pathLength = 0;\n                var x1 = world[0],\n                    y1 = world[1],\n                    cx1 = 0,\n                    cy1 = 0,\n                    cx2 = 0,\n                    cy2 = 0,\n                    x2 = 0,\n                    y2 = 0;\n                var tmpx = 0,\n                    tmpy = 0,\n                    dddfx = 0,\n                    dddfy = 0,\n                    ddfx = 0,\n                    ddfy = 0,\n                    dfx = 0,\n                    dfy = 0;\n                for (var i = 0, w = 2; i < curveCount; i++, w += 6) {\n                    cx1 = world[w];\n                    cy1 = world[w + 1];\n                    cx2 = world[w + 2];\n                    cy2 = world[w + 3];\n                    x2 = world[w + 4];\n                    y2 = world[w + 5];\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n                    ddfx = tmpx * 2 + dddfx;\n                    ddfy = tmpy * 2 + dddfy;\n                    dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n                    dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    dfx += ddfx + dddfx;\n                    dfy += ddfy + dddfy;\n                    pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    curves[i] = pathLength;\n                    x1 = x2;\n                    y1 = y2;\n                }\n                if (percentPosition) position *= pathLength;\n                if (percentSpacing) {\n                    for (var i = 0; i < spacesCount; i++) {\n                        spaces[i] *= pathLength;\n                    }\n                }\n                var segments = this.segments;\n                var curveLength = 0;\n                for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n                    var space = spaces[i];\n                    position += space;\n                    var p = position;\n                    if (closed) {\n                        p %= pathLength;\n                        if (p < 0) p += pathLength;\n                        curve = 0;\n                    } else if (p < 0) {\n                        this.addBeforePosition(p, world, 0, out, o);\n                        continue;\n                    } else if (p > pathLength) {\n                        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                        continue;\n                    }\n                    for (;; curve++) {\n                        var length_5 = curves[curve];\n                        if (p > length_5) continue;\n                        if (curve == 0) p /= length_5;else {\n                            var prev = curves[curve - 1];\n                            p = (p - prev) / (length_5 - prev);\n                        }\n                        break;\n                    }\n                    if (curve != prevCurve) {\n                        prevCurve = curve;\n                        var ii = curve * 6;\n                        x1 = world[ii];\n                        y1 = world[ii + 1];\n                        cx1 = world[ii + 2];\n                        cy1 = world[ii + 3];\n                        cx2 = world[ii + 4];\n                        cy2 = world[ii + 5];\n                        x2 = world[ii + 6];\n                        y2 = world[ii + 7];\n                        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                        ddfx = tmpx * 2 + dddfx;\n                        ddfy = tmpy * 2 + dddfy;\n                        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[0] = curveLength;\n                        for (ii = 1; ii < 8; ii++) {\n                            dfx += ddfx;\n                            dfy += ddfy;\n                            ddfx += dddfx;\n                            ddfy += dddfy;\n                            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                            segments[ii] = curveLength;\n                        }\n                        dfx += ddfx;\n                        dfy += ddfy;\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[8] = curveLength;\n                        dfx += ddfx + dddfx;\n                        dfy += ddfy + dddfy;\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[9] = curveLength;\n                        segment = 0;\n                    }\n                    p *= curveLength;\n                    for (;; segment++) {\n                        var length_6 = segments[segment];\n                        if (p > length_6) continue;\n                        if (segment == 0) p /= length_6;else {\n                            var prev = segments[segment - 1];\n                            p = segment + (p - prev) / (length_6 - prev);\n                        }\n                        break;\n                    }\n                    this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n                }\n                return out;\n            };\n            PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\n                var x1 = temp[i],\n                    y1 = temp[i + 1],\n                    dx = temp[i + 2] - x1,\n                    dy = temp[i + 3] - y1,\n                    r = Math.atan2(dy, dx);\n                out[o] = x1 + p * Math.cos(r);\n                out[o + 1] = y1 + p * Math.sin(r);\n                out[o + 2] = r;\n            };\n            PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\n                var x1 = temp[i + 2],\n                    y1 = temp[i + 3],\n                    dx = x1 - temp[i],\n                    dy = y1 - temp[i + 1],\n                    r = Math.atan2(dy, dx);\n                out[o] = x1 + p * Math.cos(r);\n                out[o + 1] = y1 + p * Math.sin(r);\n                out[o + 2] = r;\n            };\n            PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n                if (p == 0 || isNaN(p)) p = 0.0001;\n                var tt = p * p,\n                    ttt = tt * p,\n                    u = 1 - p,\n                    uu = u * u,\n                    uuu = uu * u;\n                var ut = u * p,\n                    ut3 = ut * 3,\n                    uut3 = u * ut3,\n                    utt3 = ut3 * p;\n                var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt,\n                    y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n                out[o] = x;\n                out[o + 1] = y;\n                if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n            };\n            PathConstraint.prototype.getOrder = function () {\n                return this.data.order;\n            };\n            return PathConstraint;\n        }();\n        PathConstraint.NONE = -1;\n        PathConstraint.BEFORE = -2;\n        PathConstraint.AFTER = -3;\n        core.PathConstraint = PathConstraint;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var PathConstraintData = function () {\n            function PathConstraintData(name) {\n                this.order = 0;\n                this.bones = new Array();\n                this.name = name;\n            }\n            return PathConstraintData;\n        }();\n        core.PathConstraintData = PathConstraintData;\n        var PositionMode;\n        (function (PositionMode) {\n            PositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\n            PositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\n        })(PositionMode = core.PositionMode || (core.PositionMode = {}));\n        var SpacingMode;\n        (function (SpacingMode) {\n            SpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\n            SpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\n            SpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\n        })(SpacingMode = core.SpacingMode || (core.SpacingMode = {}));\n        var RotateMode;\n        (function (RotateMode) {\n            RotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\n            RotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\n            RotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\n        })(RotateMode = core.RotateMode || (core.RotateMode = {}));\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Skeleton = function () {\n            function Skeleton(data) {\n                this._updateCache = new Array();\n                this.updateCacheReset = new Array();\n                this.time = 0;\n                this.flipX = false;\n                this.flipY = false;\n                this.x = 0;\n                this.y = 0;\n                if (data == null) throw new Error(\"data cannot be null.\");\n                this.data = data;\n                this.bones = new Array();\n                for (var i = 0; i < data.bones.length; i++) {\n                    var boneData = data.bones[i];\n                    var bone = void 0;\n                    if (boneData.parent == null) bone = new core.Bone(boneData, this, null);else {\n                        var parent_1 = this.bones[boneData.parent.index];\n                        bone = new core.Bone(boneData, this, parent_1);\n                        parent_1.children.push(bone);\n                    }\n                    this.bones.push(bone);\n                }\n                this.slots = new Array();\n                this.drawOrder = new Array();\n                for (var i = 0; i < data.slots.length; i++) {\n                    var slotData = data.slots[i];\n                    var bone = this.bones[slotData.boneData.index];\n                    var slot = new core.Slot(slotData, bone);\n                    this.slots.push(slot);\n                    this.drawOrder.push(slot);\n                }\n                this.ikConstraints = new Array();\n                for (var i = 0; i < data.ikConstraints.length; i++) {\n                    var ikConstraintData = data.ikConstraints[i];\n                    this.ikConstraints.push(new core.IkConstraint(ikConstraintData, this));\n                }\n                this.transformConstraints = new Array();\n                for (var i = 0; i < data.transformConstraints.length; i++) {\n                    var transformConstraintData = data.transformConstraints[i];\n                    this.transformConstraints.push(new core.TransformConstraint(transformConstraintData, this));\n                }\n                this.pathConstraints = new Array();\n                for (var i = 0; i < data.pathConstraints.length; i++) {\n                    var pathConstraintData = data.pathConstraints[i];\n                    this.pathConstraints.push(new core.PathConstraint(pathConstraintData, this));\n                }\n                this.color = new core.Color(1, 1, 1, 1);\n                this.updateCache();\n            }\n            Skeleton.prototype.updateCache = function () {\n                var updateCache = this._updateCache;\n                updateCache.length = 0;\n                this.updateCacheReset.length = 0;\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    bones[i].sorted = false;\n                }var ikConstraints = this.ikConstraints;\n                var transformConstraints = this.transformConstraints;\n                var pathConstraints = this.pathConstraints;\n                var ikCount = ikConstraints.length,\n                    transformCount = transformConstraints.length,\n                    pathCount = pathConstraints.length;\n                var constraintCount = ikCount + transformCount + pathCount;\n                outer: for (var i = 0; i < constraintCount; i++) {\n                    for (var ii = 0; ii < ikCount; ii++) {\n                        var constraint = ikConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortIkConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                    for (var ii = 0; ii < transformCount; ii++) {\n                        var constraint = transformConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortTransformConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                    for (var ii = 0; ii < pathCount; ii++) {\n                        var constraint = pathConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortPathConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                }\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    this.sortBone(bones[i]);\n                }\n            };\n            Skeleton.prototype.sortIkConstraint = function (constraint) {\n                var target = constraint.target;\n                this.sortBone(target);\n                var constrained = constraint.bones;\n                var parent = constrained[0];\n                this.sortBone(parent);\n                if (constrained.length > 1) {\n                    var child = constrained[constrained.length - 1];\n                    if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n                }\n                this._updateCache.push(constraint);\n                this.sortReset(parent.children);\n                constrained[constrained.length - 1].sorted = true;\n            };\n            Skeleton.prototype.sortPathConstraint = function (constraint) {\n                var slot = constraint.target;\n                var slotIndex = slot.data.index;\n                var slotBone = slot.bone;\n                if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n                if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n                for (var i = 0, n = this.data.skins.length; i < n; i++) {\n                    this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n                }var attachment = slot.getAttachment();\n                if (attachment instanceof core.PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n                var constrained = constraint.bones;\n                var boneCount = constrained.length;\n                for (var i = 0; i < boneCount; i++) {\n                    this.sortBone(constrained[i]);\n                }this._updateCache.push(constraint);\n                for (var i = 0; i < boneCount; i++) {\n                    this.sortReset(constrained[i].children);\n                }for (var i = 0; i < boneCount; i++) {\n                    constrained[i].sorted = true;\n                }\n            };\n            Skeleton.prototype.sortTransformConstraint = function (constraint) {\n                this.sortBone(constraint.target);\n                var constrained = constraint.bones;\n                var boneCount = constrained.length;\n                if (constraint.data.local) {\n                    for (var i = 0; i < boneCount; i++) {\n                        var child = constrained[i];\n                        this.sortBone(child.parent);\n                        if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n                    }\n                } else {\n                    for (var i = 0; i < boneCount; i++) {\n                        this.sortBone(constrained[i]);\n                    }\n                }\n                this._updateCache.push(constraint);\n                for (var ii = 0; ii < boneCount; ii++) {\n                    this.sortReset(constrained[ii].children);\n                }for (var ii = 0; ii < boneCount; ii++) {\n                    constrained[ii].sorted = true;\n                }\n            };\n            Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\n                var attachments = skin.attachments[slotIndex];\n                if (!attachments) return;\n                for (var key in attachments) {\n                    this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n                }\n            };\n            Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\n                if (!(attachment instanceof core.PathAttachment)) return;\n                var pathBones = attachment.bones;\n                if (pathBones == null) this.sortBone(slotBone);else {\n                    var bones = this.bones;\n                    var i = 0;\n                    while (i < pathBones.length) {\n                        var boneCount = pathBones[i++];\n                        for (var n = i + boneCount; i < n; i++) {\n                            var boneIndex = pathBones[i];\n                            this.sortBone(bones[boneIndex]);\n                        }\n                    }\n                }\n            };\n            Skeleton.prototype.sortBone = function (bone) {\n                if (bone.sorted) return;\n                var parent = bone.parent;\n                if (parent != null) this.sortBone(parent);\n                bone.sorted = true;\n                this._updateCache.push(bone);\n            };\n            Skeleton.prototype.sortReset = function (bones) {\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (bone.sorted) this.sortReset(bone.children);\n                    bone.sorted = false;\n                }\n            };\n            Skeleton.prototype.updateWorldTransform = function () {\n                var updateCacheReset = this.updateCacheReset;\n                for (var i = 0, n = updateCacheReset.length; i < n; i++) {\n                    var bone = updateCacheReset[i];\n                    bone.ax = bone.x;\n                    bone.ay = bone.y;\n                    bone.arotation = bone.rotation;\n                    bone.ascaleX = bone.scaleX;\n                    bone.ascaleY = bone.scaleY;\n                    bone.ashearX = bone.shearX;\n                    bone.ashearY = bone.shearY;\n                    bone.appliedValid = true;\n                }\n                var updateCache = this._updateCache;\n                for (var i = 0, n = updateCache.length; i < n; i++) {\n                    updateCache[i].update();\n                }\n            };\n            Skeleton.prototype.setToSetupPose = function () {\n                this.setBonesToSetupPose();\n                this.setSlotsToSetupPose();\n            };\n            Skeleton.prototype.setBonesToSetupPose = function () {\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    bones[i].setToSetupPose();\n                }var ikConstraints = this.ikConstraints;\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                    var constraint = ikConstraints[i];\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.mix = constraint.data.mix;\n                }\n                var transformConstraints = this.transformConstraints;\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                    var constraint = transformConstraints[i];\n                    var data = constraint.data;\n                    constraint.rotateMix = data.rotateMix;\n                    constraint.translateMix = data.translateMix;\n                    constraint.scaleMix = data.scaleMix;\n                    constraint.shearMix = data.shearMix;\n                }\n                var pathConstraints = this.pathConstraints;\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                    var constraint = pathConstraints[i];\n                    var data = constraint.data;\n                    constraint.position = data.position;\n                    constraint.spacing = data.spacing;\n                    constraint.rotateMix = data.rotateMix;\n                    constraint.translateMix = data.translateMix;\n                }\n            };\n            Skeleton.prototype.setSlotsToSetupPose = function () {\n                var slots = this.slots;\n                core.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    slots[i].setToSetupPose();\n                }\n            };\n            Skeleton.prototype.getRootBone = function () {\n                if (this.bones.length == 0) return null;\n                return this.bones[0];\n            };\n            Skeleton.prototype.findBone = function (boneName) {\n                if (boneName == null) throw new Error(\"boneName cannot be null.\");\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (bone.data.name == boneName) return bone;\n                }\n                return null;\n            };\n            Skeleton.prototype.findBoneIndex = function (boneName) {\n                if (boneName == null) throw new Error(\"boneName cannot be null.\");\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    if (bones[i].data.name == boneName) return i;\n                }return -1;\n            };\n            Skeleton.prototype.findSlot = function (slotName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    var slot = slots[i];\n                    if (slot.data.name == slotName) return slot;\n                }\n                return null;\n            };\n            Skeleton.prototype.findSlotIndex = function (slotName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    if (slots[i].data.name == slotName) return i;\n                }return -1;\n            };\n            Skeleton.prototype.setSkinByName = function (skinName) {\n                var skin = this.data.findSkin(skinName);\n                if (skin == null) throw new Error(\"Skin not found: \" + skinName);\n                this.setSkin(skin);\n            };\n            Skeleton.prototype.setSkin = function (newSkin) {\n                if (newSkin != null) {\n                    if (this.skin != null) newSkin.attachAll(this, this.skin);else {\n                        var slots = this.slots;\n                        for (var i = 0, n = slots.length; i < n; i++) {\n                            var slot = slots[i];\n                            var name_1 = slot.data.attachmentName;\n                            if (name_1 != null) {\n                                var attachment = newSkin.getAttachment(i, name_1);\n                                if (attachment != null) slot.setAttachment(attachment);\n                            }\n                        }\n                    }\n                }\n                this.skin = newSkin;\n            };\n            Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\n                return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n            };\n            Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\n                if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\n                if (this.skin != null) {\n                    var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n                    if (attachment != null) return attachment;\n                }\n                if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n                return null;\n            };\n            Skeleton.prototype.setAttachment = function (slotName, attachmentName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    var slot = slots[i];\n                    if (slot.data.name == slotName) {\n                        var attachment = null;\n                        if (attachmentName != null) {\n                            attachment = this.getAttachment(i, attachmentName);\n                            if (attachment == null) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                        }\n                        slot.setAttachment(attachment);\n                        return;\n                    }\n                }\n                throw new Error(\"Slot not found: \" + slotName);\n            };\n            Skeleton.prototype.findIkConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var ikConstraints = this.ikConstraints;\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                    var ikConstraint = ikConstraints[i];\n                    if (ikConstraint.data.name == constraintName) return ikConstraint;\n                }\n                return null;\n            };\n            Skeleton.prototype.findTransformConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var transformConstraints = this.transformConstraints;\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                    var constraint = transformConstraints[i];\n                    if (constraint.data.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            Skeleton.prototype.findPathConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var pathConstraints = this.pathConstraints;\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                    var constraint = pathConstraints[i];\n                    if (constraint.data.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            Skeleton.prototype.getBounds = function (offset, size, temp) {\n                if (offset == null) throw new Error(\"offset cannot be null.\");\n                if (size == null) throw new Error(\"size cannot be null.\");\n                var drawOrder = this.drawOrder;\n                var minX = Number.POSITIVE_INFINITY,\n                    minY = Number.POSITIVE_INFINITY,\n                    maxX = Number.NEGATIVE_INFINITY,\n                    maxY = Number.NEGATIVE_INFINITY;\n                for (var i = 0, n = drawOrder.length; i < n; i++) {\n                    var slot = drawOrder[i];\n                    var verticesLength = 0;\n                    var vertices = null;\n                    var attachment = slot.getAttachment();\n                    if (attachment instanceof core.RegionAttachment) {\n                        verticesLength = 8;\n                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);\n                        attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n                    } else if (attachment instanceof core.MeshAttachment) {\n                        var mesh = attachment;\n                        verticesLength = mesh.worldVerticesLength;\n                        vertices = core.Utils.setArraySize(temp, verticesLength, 0);\n                        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n                    }\n                    if (vertices != null) {\n                        for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                            var x = vertices[ii],\n                                y = vertices[ii + 1];\n                            minX = Math.min(minX, x);\n                            minY = Math.min(minY, y);\n                            maxX = Math.max(maxX, x);\n                            maxY = Math.max(maxY, y);\n                        }\n                    }\n                }\n                offset.set(minX, minY);\n                size.set(maxX - minX, maxY - minY);\n            };\n            Skeleton.prototype.update = function (delta) {\n                this.time += delta;\n            };\n            return Skeleton;\n        }();\n        core.Skeleton = Skeleton;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SkeletonBounds = function () {\n            function SkeletonBounds() {\n                this.minX = 0;\n                this.minY = 0;\n                this.maxX = 0;\n                this.maxY = 0;\n                this.boundingBoxes = new Array();\n                this.polygons = new Array();\n                this.polygonPool = new core.Pool(function () {\n                    return core.Utils.newFloatArray(16);\n                });\n            }\n            SkeletonBounds.prototype.update = function (skeleton, updateAabb) {\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                var boundingBoxes = this.boundingBoxes;\n                var polygons = this.polygons;\n                var polygonPool = this.polygonPool;\n                var slots = skeleton.slots;\n                var slotCount = slots.length;\n                boundingBoxes.length = 0;\n                polygonPool.freeAll(polygons);\n                polygons.length = 0;\n                for (var i = 0; i < slotCount; i++) {\n                    var slot = slots[i];\n                    var attachment = slot.getAttachment();\n                    if (attachment instanceof core.BoundingBoxAttachment) {\n                        var boundingBox = attachment;\n                        boundingBoxes.push(boundingBox);\n                        var polygon = polygonPool.obtain();\n                        if (polygon.length != boundingBox.worldVerticesLength) {\n                            polygon = core.Utils.newFloatArray(boundingBox.worldVerticesLength);\n                        }\n                        polygons.push(polygon);\n                        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n                    }\n                }\n                if (updateAabb) {\n                    this.aabbCompute();\n                } else {\n                    this.minX = Number.POSITIVE_INFINITY;\n                    this.minY = Number.POSITIVE_INFINITY;\n                    this.maxX = Number.NEGATIVE_INFINITY;\n                    this.maxY = Number.NEGATIVE_INFINITY;\n                }\n            };\n            SkeletonBounds.prototype.aabbCompute = function () {\n                var minX = Number.POSITIVE_INFINITY,\n                    minY = Number.POSITIVE_INFINITY,\n                    maxX = Number.NEGATIVE_INFINITY,\n                    maxY = Number.NEGATIVE_INFINITY;\n                var polygons = this.polygons;\n                for (var i = 0, n = polygons.length; i < n; i++) {\n                    var polygon = polygons[i];\n                    var vertices = polygon;\n                    for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                        var x = vertices[ii];\n                        var y = vertices[ii + 1];\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n                this.minX = minX;\n                this.minY = minY;\n                this.maxX = maxX;\n                this.maxY = maxY;\n            };\n            SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\n                return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n            };\n            SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\n                var minX = this.minX;\n                var minY = this.minY;\n                var maxX = this.maxX;\n                var maxY = this.maxY;\n                if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;\n                var m = (y2 - y1) / (x2 - x1);\n                var y = m * (minX - x1) + y1;\n                if (y > minY && y < maxY) return true;\n                y = m * (maxX - x1) + y1;\n                if (y > minY && y < maxY) return true;\n                var x = (minY - y1) / m + x1;\n                if (x > minX && x < maxX) return true;\n                x = (maxY - y1) / m + x1;\n                if (x > minX && x < maxX) return true;\n                return false;\n            };\n            SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\n                return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n            };\n            SkeletonBounds.prototype.containsPoint = function (x, y) {\n                var polygons = this.polygons;\n                for (var i = 0, n = polygons.length; i < n; i++) {\n                    if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n                }return null;\n            };\n            SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\n                var vertices = polygon;\n                var nn = polygon.length;\n                var prevIndex = nn - 2;\n                var inside = false;\n                for (var ii = 0; ii < nn; ii += 2) {\n                    var vertexY = vertices[ii + 1];\n                    var prevY = vertices[prevIndex + 1];\n                    if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {\n                        var vertexX = vertices[ii];\n                        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n                    }\n                    prevIndex = ii;\n                }\n                return inside;\n            };\n            SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\n                var polygons = this.polygons;\n                for (var i = 0, n = polygons.length; i < n; i++) {\n                    if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n                }return null;\n            };\n            SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\n                var vertices = polygon;\n                var nn = polygon.length;\n                var width12 = x1 - x2,\n                    height12 = y1 - y2;\n                var det1 = x1 * y2 - y1 * x2;\n                var x3 = vertices[nn - 2],\n                    y3 = vertices[nn - 1];\n                for (var ii = 0; ii < nn; ii += 2) {\n                    var x4 = vertices[ii],\n                        y4 = vertices[ii + 1];\n                    var det2 = x3 * y4 - y3 * x4;\n                    var width34 = x3 - x4,\n                        height34 = y3 - y4;\n                    var det3 = width12 * height34 - height12 * width34;\n                    var x = (det1 * width34 - width12 * det2) / det3;\n                    if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {\n                        var y = (det1 * height34 - height12 * det2) / det3;\n                        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;\n                    }\n                    x3 = x4;\n                    y3 = y4;\n                }\n                return false;\n            };\n            SkeletonBounds.prototype.getPolygon = function (boundingBox) {\n                if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\n                var index = this.boundingBoxes.indexOf(boundingBox);\n                return index == -1 ? null : this.polygons[index];\n            };\n            SkeletonBounds.prototype.getWidth = function () {\n                return this.maxX - this.minX;\n            };\n            SkeletonBounds.prototype.getHeight = function () {\n                return this.maxY - this.minY;\n            };\n            return SkeletonBounds;\n        }();\n        core.SkeletonBounds = SkeletonBounds;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SkeletonClipping = function () {\n            function SkeletonClipping() {\n                this.triangulator = new core.Triangulator();\n                this.clippingPolygon = new Array();\n                this.clipOutput = new Array();\n                this.clippedVertices = new Array();\n                this.clippedTriangles = new Array();\n                this.scratch = new Array();\n            }\n            SkeletonClipping.prototype.clipStart = function (slot, clip) {\n                if (this.clipAttachment != null) return 0;\n                this.clipAttachment = clip;\n                var n = clip.worldVerticesLength;\n                var vertices = core.Utils.setArraySize(this.clippingPolygon, n);\n                clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n                var clippingPolygon = this.clippingPolygon;\n                SkeletonClipping.makeClockwise(clippingPolygon);\n                var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n                for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {\n                    var polygon = clippingPolygons[i];\n                    SkeletonClipping.makeClockwise(polygon);\n                    polygon.push(polygon[0]);\n                    polygon.push(polygon[1]);\n                }\n                return clippingPolygons.length;\n            };\n            SkeletonClipping.prototype.clipEndWithSlot = function (slot) {\n                if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd();\n            };\n            SkeletonClipping.prototype.clipEnd = function () {\n                if (this.clipAttachment == null) return;\n                this.clipAttachment = null;\n                this.clippingPolygons = null;\n                this.clippedVertices.length = 0;\n                this.clippedTriangles.length = 0;\n                this.clippingPolygon.length = 0;\n            };\n            SkeletonClipping.prototype.isClipping = function () {\n                return this.clipAttachment != null;\n            };\n            SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\n                var clipOutput = this.clipOutput,\n                    clippedVertices = this.clippedVertices;\n                var clippedTriangles = this.clippedTriangles;\n                var polygons = this.clippingPolygons;\n                var polygonsCount = this.clippingPolygons.length;\n                var vertexSize = twoColor ? 12 : 8;\n                var index = 0;\n                clippedVertices.length = 0;\n                clippedTriangles.length = 0;\n                outer: for (var i = 0; i < trianglesLength; i += 3) {\n                    var vertexOffset = triangles[i] << 1;\n                    var x1 = vertices[vertexOffset],\n                        y1 = vertices[vertexOffset + 1];\n                    var u1 = uvs[vertexOffset],\n                        v1 = uvs[vertexOffset + 1];\n                    vertexOffset = triangles[i + 1] << 1;\n                    var x2 = vertices[vertexOffset],\n                        y2 = vertices[vertexOffset + 1];\n                    var u2 = uvs[vertexOffset],\n                        v2 = uvs[vertexOffset + 1];\n                    vertexOffset = triangles[i + 2] << 1;\n                    var x3 = vertices[vertexOffset],\n                        y3 = vertices[vertexOffset + 1];\n                    var u3 = uvs[vertexOffset],\n                        v3 = uvs[vertexOffset + 1];\n                    for (var p = 0; p < polygonsCount; p++) {\n                        var s = clippedVertices.length;\n                        if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n                            var clipOutputLength = clipOutput.length;\n                            if (clipOutputLength == 0) continue;\n                            var d0 = y2 - y3,\n                                d1 = x3 - x2,\n                                d2 = x1 - x3,\n                                d4 = y3 - y1;\n                            var d = 1 / (d0 * d2 + d1 * (y1 - y3));\n                            var clipOutputCount = clipOutputLength >> 1;\n                            var clipOutputItems = this.clipOutput;\n                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n                            for (var ii = 0; ii < clipOutputLength; ii += 2) {\n                                var x = clipOutputItems[ii],\n                                    y = clipOutputItems[ii + 1];\n                                clippedVerticesItems[s] = x;\n                                clippedVerticesItems[s + 1] = y;\n                                clippedVerticesItems[s + 2] = light.r;\n                                clippedVerticesItems[s + 3] = light.g;\n                                clippedVerticesItems[s + 4] = light.b;\n                                clippedVerticesItems[s + 5] = light.a;\n                                var c0 = x - x3,\n                                    c1 = y - y3;\n                                var a = (d0 * c0 + d1 * c1) * d;\n                                var b = (d4 * c0 + d2 * c1) * d;\n                                var c = 1 - a - b;\n                                clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n                                clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n                                if (twoColor) {\n                                    clippedVerticesItems[s + 8] = dark.r;\n                                    clippedVerticesItems[s + 9] = dark.g;\n                                    clippedVerticesItems[s + 10] = dark.b;\n                                    clippedVerticesItems[s + 11] = dark.a;\n                                }\n                                s += vertexSize;\n                            }\n                            s = clippedTriangles.length;\n                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n                            clipOutputCount--;\n                            for (var ii = 1; ii < clipOutputCount; ii++) {\n                                clippedTrianglesItems[s] = index;\n                                clippedTrianglesItems[s + 1] = index + ii;\n                                clippedTrianglesItems[s + 2] = index + ii + 1;\n                                s += 3;\n                            }\n                            index += clipOutputCount + 1;\n                        } else {\n                            var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n                            clippedVerticesItems[s] = x1;\n                            clippedVerticesItems[s + 1] = y1;\n                            clippedVerticesItems[s + 2] = light.r;\n                            clippedVerticesItems[s + 3] = light.g;\n                            clippedVerticesItems[s + 4] = light.b;\n                            clippedVerticesItems[s + 5] = light.a;\n                            if (!twoColor) {\n                                clippedVerticesItems[s + 6] = u1;\n                                clippedVerticesItems[s + 7] = v1;\n                                clippedVerticesItems[s + 8] = x2;\n                                clippedVerticesItems[s + 9] = y2;\n                                clippedVerticesItems[s + 10] = light.r;\n                                clippedVerticesItems[s + 11] = light.g;\n                                clippedVerticesItems[s + 12] = light.b;\n                                clippedVerticesItems[s + 13] = light.a;\n                                clippedVerticesItems[s + 14] = u2;\n                                clippedVerticesItems[s + 15] = v2;\n                                clippedVerticesItems[s + 16] = x3;\n                                clippedVerticesItems[s + 17] = y3;\n                                clippedVerticesItems[s + 18] = light.r;\n                                clippedVerticesItems[s + 19] = light.g;\n                                clippedVerticesItems[s + 20] = light.b;\n                                clippedVerticesItems[s + 21] = light.a;\n                                clippedVerticesItems[s + 22] = u3;\n                                clippedVerticesItems[s + 23] = v3;\n                            } else {\n                                clippedVerticesItems[s + 6] = u1;\n                                clippedVerticesItems[s + 7] = v1;\n                                clippedVerticesItems[s + 8] = dark.r;\n                                clippedVerticesItems[s + 9] = dark.g;\n                                clippedVerticesItems[s + 10] = dark.b;\n                                clippedVerticesItems[s + 11] = dark.a;\n                                clippedVerticesItems[s + 12] = x2;\n                                clippedVerticesItems[s + 13] = y2;\n                                clippedVerticesItems[s + 14] = light.r;\n                                clippedVerticesItems[s + 15] = light.g;\n                                clippedVerticesItems[s + 16] = light.b;\n                                clippedVerticesItems[s + 17] = light.a;\n                                clippedVerticesItems[s + 18] = u2;\n                                clippedVerticesItems[s + 19] = v2;\n                                clippedVerticesItems[s + 20] = dark.r;\n                                clippedVerticesItems[s + 21] = dark.g;\n                                clippedVerticesItems[s + 22] = dark.b;\n                                clippedVerticesItems[s + 23] = dark.a;\n                                clippedVerticesItems[s + 24] = x3;\n                                clippedVerticesItems[s + 25] = y3;\n                                clippedVerticesItems[s + 26] = light.r;\n                                clippedVerticesItems[s + 27] = light.g;\n                                clippedVerticesItems[s + 28] = light.b;\n                                clippedVerticesItems[s + 29] = light.a;\n                                clippedVerticesItems[s + 30] = u3;\n                                clippedVerticesItems[s + 31] = v3;\n                                clippedVerticesItems[s + 32] = dark.r;\n                                clippedVerticesItems[s + 33] = dark.g;\n                                clippedVerticesItems[s + 34] = dark.b;\n                                clippedVerticesItems[s + 35] = dark.a;\n                            }\n                            s = clippedTriangles.length;\n                            var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3);\n                            clippedTrianglesItems[s] = index;\n                            clippedTrianglesItems[s + 1] = index + 1;\n                            clippedTrianglesItems[s + 2] = index + 2;\n                            index += 3;\n                            continue outer;\n                        }\n                    }\n                }\n            };\n            SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\n                var originalOutput = output;\n                var clipped = false;\n                var input = null;\n                if (clippingArea.length % 4 >= 2) {\n                    input = output;\n                    output = this.scratch;\n                } else input = this.scratch;\n                input.length = 0;\n                input.push(x1);\n                input.push(y1);\n                input.push(x2);\n                input.push(y2);\n                input.push(x3);\n                input.push(y3);\n                input.push(x1);\n                input.push(y1);\n                output.length = 0;\n                var clippingVertices = clippingArea;\n                var clippingVerticesLast = clippingArea.length - 4;\n                for (var i = 0;; i += 2) {\n                    var edgeX = clippingVertices[i],\n                        edgeY = clippingVertices[i + 1];\n                    var edgeX2 = clippingVertices[i + 2],\n                        edgeY2 = clippingVertices[i + 3];\n                    var deltaX = edgeX - edgeX2,\n                        deltaY = edgeY - edgeY2;\n                    var inputVertices = input;\n                    var inputVerticesLength = input.length - 2,\n                        outputStart = output.length;\n                    for (var ii = 0; ii < inputVerticesLength; ii += 2) {\n                        var inputX = inputVertices[ii],\n                            inputY = inputVertices[ii + 1];\n                        var inputX2 = inputVertices[ii + 2],\n                            inputY2 = inputVertices[ii + 3];\n                        var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n                        if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n                            if (side2) {\n                                output.push(inputX2);\n                                output.push(inputY2);\n                                continue;\n                            }\n                            var c0 = inputY2 - inputY,\n                                c2 = inputX2 - inputX;\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\n                        } else if (side2) {\n                            var c0 = inputY2 - inputY,\n                                c2 = inputX2 - inputX;\n                            var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n                            output.push(edgeX + (edgeX2 - edgeX) * ua);\n                            output.push(edgeY + (edgeY2 - edgeY) * ua);\n                            output.push(inputX2);\n                            output.push(inputY2);\n                        }\n                        clipped = true;\n                    }\n                    if (outputStart == output.length) {\n                        originalOutput.length = 0;\n                        return true;\n                    }\n                    output.push(output[0]);\n                    output.push(output[1]);\n                    if (i == clippingVerticesLast) break;\n                    var temp = output;\n                    output = input;\n                    output.length = 0;\n                    input = temp;\n                }\n                if (originalOutput != output) {\n                    originalOutput.length = 0;\n                    for (var i = 0, n = output.length - 2; i < n; i++) {\n                        originalOutput[i] = output[i];\n                    }\n                } else originalOutput.length = originalOutput.length - 2;\n                return clipped;\n            };\n            SkeletonClipping.makeClockwise = function (polygon) {\n                var vertices = polygon;\n                var verticeslength = polygon.length;\n                var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1],\n                    p1x = 0,\n                    p1y = 0,\n                    p2x = 0,\n                    p2y = 0;\n                for (var i = 0, n = verticeslength - 3; i < n; i += 2) {\n                    p1x = vertices[i];\n                    p1y = vertices[i + 1];\n                    p2x = vertices[i + 2];\n                    p2y = vertices[i + 3];\n                    area += p1x * p2y - p2x * p1y;\n                }\n                if (area < 0) return;\n                for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n                    var x = vertices[i],\n                        y = vertices[i + 1];\n                    var other = lastX - i;\n                    vertices[i] = vertices[other];\n                    vertices[i + 1] = vertices[other + 1];\n                    vertices[other] = x;\n                    vertices[other + 1] = y;\n                }\n            };\n            return SkeletonClipping;\n        }();\n        core.SkeletonClipping = SkeletonClipping;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SkeletonData = function () {\n            function SkeletonData() {\n                this.bones = new Array();\n                this.slots = new Array();\n                this.skins = new Array();\n                this.events = new Array();\n                this.animations = new Array();\n                this.ikConstraints = new Array();\n                this.transformConstraints = new Array();\n                this.pathConstraints = new Array();\n                this.fps = 0;\n            }\n            SkeletonData.prototype.findBone = function (boneName) {\n                if (boneName == null) throw new Error(\"boneName cannot be null.\");\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (bone.name == boneName) return bone;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findBoneIndex = function (boneName) {\n                if (boneName == null) throw new Error(\"boneName cannot be null.\");\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    if (bones[i].name == boneName) return i;\n                }return -1;\n            };\n            SkeletonData.prototype.findSlot = function (slotName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    var slot = slots[i];\n                    if (slot.name == slotName) return slot;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findSlotIndex = function (slotName) {\n                if (slotName == null) throw new Error(\"slotName cannot be null.\");\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++) {\n                    if (slots[i].name == slotName) return i;\n                }return -1;\n            };\n            SkeletonData.prototype.findSkin = function (skinName) {\n                if (skinName == null) throw new Error(\"skinName cannot be null.\");\n                var skins = this.skins;\n                for (var i = 0, n = skins.length; i < n; i++) {\n                    var skin = skins[i];\n                    if (skin.name == skinName) return skin;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findEvent = function (eventDataName) {\n                if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\n                var events = this.events;\n                for (var i = 0, n = events.length; i < n; i++) {\n                    var event_4 = events[i];\n                    if (event_4.name == eventDataName) return event_4;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findAnimation = function (animationName) {\n                if (animationName == null) throw new Error(\"animationName cannot be null.\");\n                var animations = this.animations;\n                for (var i = 0, n = animations.length; i < n; i++) {\n                    var animation = animations[i];\n                    if (animation.name == animationName) return animation;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findIkConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var ikConstraints = this.ikConstraints;\n                for (var i = 0, n = ikConstraints.length; i < n; i++) {\n                    var constraint = ikConstraints[i];\n                    if (constraint.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findTransformConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var transformConstraints = this.transformConstraints;\n                for (var i = 0, n = transformConstraints.length; i < n; i++) {\n                    var constraint = transformConstraints[i];\n                    if (constraint.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findPathConstraint = function (constraintName) {\n                if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n                var pathConstraints = this.pathConstraints;\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                    var constraint = pathConstraints[i];\n                    if (constraint.name == constraintName) return constraint;\n                }\n                return null;\n            };\n            SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\n                if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n                var pathConstraints = this.pathConstraints;\n                for (var i = 0, n = pathConstraints.length; i < n; i++) {\n                    if (pathConstraints[i].name == pathConstraintName) return i;\n                }return -1;\n            };\n            return SkeletonData;\n        }();\n        core.SkeletonData = SkeletonData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SkeletonJson = function () {\n            function SkeletonJson(attachmentLoader) {\n                this.scale = 1;\n                this.linkedMeshes = new Array();\n                this.attachmentLoader = attachmentLoader;\n            }\n            SkeletonJson.prototype.readSkeletonData = function (json) {\n                var scale = this.scale;\n                var skeletonData = new core.SkeletonData();\n                var root = typeof json === \"string\" ? JSON.parse(json) : json;\n                var skeletonMap = root.skeleton;\n                if (skeletonMap != null) {\n                    skeletonData.hash = skeletonMap.hash;\n                    skeletonData.version = skeletonMap.spine;\n                    skeletonData.width = skeletonMap.width;\n                    skeletonData.height = skeletonMap.height;\n                    skeletonData.fps = skeletonMap.fps;\n                    skeletonData.imagesPath = skeletonMap.images;\n                }\n                if (root.bones) {\n                    for (var i = 0; i < root.bones.length; i++) {\n                        var boneMap = root.bones[i];\n                        var parent_2 = null;\n                        var parentName = this.getValue(boneMap, \"parent\", null);\n                        if (parentName != null) {\n                            parent_2 = skeletonData.findBone(parentName);\n                            if (parent_2 == null) throw new Error(\"Parent bone not found: \" + parentName);\n                        }\n                        var data = new core.BoneData(skeletonData.bones.length, boneMap.name, parent_2);\n                        data.length = this.getValue(boneMap, \"length\", 0) * scale;\n                        data.x = this.getValue(boneMap, \"x\", 0) * scale;\n                        data.y = this.getValue(boneMap, \"y\", 0) * scale;\n                        data.rotation = this.getValue(boneMap, \"rotation\", 0);\n                        data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n                        data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n                        data.shearX = this.getValue(boneMap, \"shearX\", 0);\n                        data.shearY = this.getValue(boneMap, \"shearY\", 0);\n                        data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n                        skeletonData.bones.push(data);\n                    }\n                }\n                if (root.slots) {\n                    for (var i = 0; i < root.slots.length; i++) {\n                        var slotMap = root.slots[i];\n                        var slotName = slotMap.name;\n                        var boneName = slotMap.bone;\n                        var boneData = skeletonData.findBone(boneName);\n                        if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n                        var data = new core.SlotData(skeletonData.slots.length, slotName, boneData);\n                        var color = this.getValue(slotMap, \"color\", null);\n                        if (color != null) data.color.setFromString(color);\n                        var dark = this.getValue(slotMap, \"dark\", null);\n                        if (dark != null) {\n                            data.darkColor = new core.Color(1, 1, 1, 1);\n                            data.darkColor.setFromString(dark);\n                        }\n                        data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n                        data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n                        skeletonData.slots.push(data);\n                    }\n                }\n                if (root.ik) {\n                    for (var i = 0; i < root.ik.length; i++) {\n                        var constraintMap = root.ik[i];\n                        var data = new core.IkConstraintData(constraintMap.name);\n                        data.order = this.getValue(constraintMap, \"order\", 0);\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\n                            var boneName = constraintMap.bones[j];\n                            var bone = skeletonData.findBone(boneName);\n                            if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n                            data.bones.push(bone);\n                        }\n                        var targetName = constraintMap.target;\n                        data.target = skeletonData.findBone(targetName);\n                        if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\n                        data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n                        data.mix = this.getValue(constraintMap, \"mix\", 1);\n                        skeletonData.ikConstraints.push(data);\n                    }\n                }\n                if (root.transform) {\n                    for (var i = 0; i < root.transform.length; i++) {\n                        var constraintMap = root.transform[i];\n                        var data = new core.TransformConstraintData(constraintMap.name);\n                        data.order = this.getValue(constraintMap, \"order\", 0);\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\n                            var boneName = constraintMap.bones[j];\n                            var bone = skeletonData.findBone(boneName);\n                            if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                            data.bones.push(bone);\n                        }\n                        var targetName = constraintMap.target;\n                        data.target = skeletonData.findBone(targetName);\n                        if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n                        data.local = this.getValue(constraintMap, \"local\", false);\n                        data.relative = this.getValue(constraintMap, \"relative\", false);\n                        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                        data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n                        data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n                        data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n                        data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n                        data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n                        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                        data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n                        data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n                        skeletonData.transformConstraints.push(data);\n                    }\n                }\n                if (root.path) {\n                    for (var i = 0; i < root.path.length; i++) {\n                        var constraintMap = root.path[i];\n                        var data = new core.PathConstraintData(constraintMap.name);\n                        data.order = this.getValue(constraintMap, \"order\", 0);\n                        for (var j = 0; j < constraintMap.bones.length; j++) {\n                            var boneName = constraintMap.bones[j];\n                            var bone = skeletonData.findBone(boneName);\n                            if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                            data.bones.push(bone);\n                        }\n                        var targetName = constraintMap.target;\n                        data.target = skeletonData.findSlot(targetName);\n                        if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n                        data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n                        data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n                        data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n                        data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                        data.position = this.getValue(constraintMap, \"position\", 0);\n                        if (data.positionMode == core.PositionMode.Fixed) data.position *= scale;\n                        data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n                        if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed) data.spacing *= scale;\n                        data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                        data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                        skeletonData.pathConstraints.push(data);\n                    }\n                }\n                if (root.skins) {\n                    for (var skinName in root.skins) {\n                        var skinMap = root.skins[skinName];\n                        var skin = new core.Skin(skinName);\n                        for (var slotName in skinMap) {\n                            var slotIndex = skeletonData.findSlotIndex(slotName);\n                            if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                            var slotMap = skinMap[slotName];\n                            for (var entryName in slotMap) {\n                                var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n                                if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                            }\n                        }\n                        skeletonData.skins.push(skin);\n                        if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n                    }\n                }\n                for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\n                    var linkedMesh = this.linkedMeshes[i];\n                    var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n                    if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n                    var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n                    if (parent_3 == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n                    linkedMesh.mesh.setParentMesh(parent_3);\n                }\n                this.linkedMeshes.length = 0;\n                if (root.events) {\n                    for (var eventName in root.events) {\n                        var eventMap = root.events[eventName];\n                        var data = new core.EventData(eventName);\n                        data.intValue = this.getValue(eventMap, \"int\", 0);\n                        data.floatValue = this.getValue(eventMap, \"float\", 0);\n                        data.stringValue = this.getValue(eventMap, \"string\", \"\");\n                        skeletonData.events.push(data);\n                    }\n                }\n                if (root.animations) {\n                    for (var animationName in root.animations) {\n                        var animationMap = root.animations[animationName];\n                        this.readAnimation(animationMap, animationName, skeletonData);\n                    }\n                }\n                return skeletonData;\n            };\n            SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\n                var scale = this.scale;\n                name = this.getValue(map, \"name\", name);\n                var type = this.getValue(map, \"type\", \"region\");\n                switch (type) {\n                    case \"region\":\n                        {\n                            var path = this.getValue(map, \"path\", name);\n                            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n                            if (region == null) return null;\n                            region.path = path;\n                            region.x = this.getValue(map, \"x\", 0) * scale;\n                            region.y = this.getValue(map, \"y\", 0) * scale;\n                            region.scaleX = this.getValue(map, \"scaleX\", 1);\n                            region.scaleY = this.getValue(map, \"scaleY\", 1);\n                            region.rotation = this.getValue(map, \"rotation\", 0);\n                            region.width = map.width * scale;\n                            region.height = map.height * scale;\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) region.color.setFromString(color);\n                            return region;\n                        }\n                    case \"boundingbox\":\n                        {\n                            var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n                            if (box == null) return null;\n                            this.readVertices(map, box, map.vertexCount << 1);\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) box.color.setFromString(color);\n                            return box;\n                        }\n                    case \"mesh\":\n                    case \"linkedmesh\":\n                        {\n                            var path = this.getValue(map, \"path\", name);\n                            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                            if (mesh == null) return null;\n                            mesh.path = path;\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) mesh.color.setFromString(color);\n                            var parent_4 = this.getValue(map, \"parent\", null);\n                            if (parent_4 != null) {\n                                mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                                this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_4));\n                                return mesh;\n                            }\n                            var uvs = map.uvs;\n                            this.readVertices(map, mesh, uvs.length);\n                            mesh.triangles = map.triangles;\n                            mesh.regionUVs = uvs;\n                            mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n                            return mesh;\n                        }\n                    case \"path\":\n                        {\n                            var path = this.attachmentLoader.newPathAttachment(skin, name);\n                            if (path == null) return null;\n                            path.closed = this.getValue(map, \"closed\", false);\n                            path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n                            var vertexCount = map.vertexCount;\n                            this.readVertices(map, path, vertexCount << 1);\n                            var lengths = core.Utils.newArray(vertexCount / 3, 0);\n                            for (var i = 0; i < map.lengths.length; i++) {\n                                lengths[i] = map.lengths[i] * scale;\n                            }path.lengths = lengths;\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) path.color.setFromString(color);\n                            return path;\n                        }\n                    case \"point\":\n                        {\n                            var point = this.attachmentLoader.newPointAttachment(skin, name);\n                            if (point == null) return null;\n                            point.x = this.getValue(map, \"x\", 0) * scale;\n                            point.y = this.getValue(map, \"y\", 0) * scale;\n                            point.rotation = this.getValue(map, \"rotation\", 0);\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) point.color.setFromString(color);\n                            return point;\n                        }\n                    case \"clipping\":\n                        {\n                            var clip = this.attachmentLoader.newClippingAttachment(skin, name);\n                            if (clip == null) return null;\n                            var end = this.getValue(map, \"end\", null);\n                            if (end != null) {\n                                var slot = skeletonData.findSlot(end);\n                                if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\n                                clip.endSlot = slot;\n                            }\n                            var vertexCount = map.vertexCount;\n                            this.readVertices(map, clip, vertexCount << 1);\n                            var color = this.getValue(map, \"color\", null);\n                            if (color != null) clip.color.setFromString(color);\n                            return clip;\n                        }\n                }\n                return null;\n            };\n            SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\n                var scale = this.scale;\n                attachment.worldVerticesLength = verticesLength;\n                var vertices = map.vertices;\n                if (verticesLength == vertices.length) {\n                    var scaledVertices = core.Utils.toFloatArray(vertices);\n                    if (scale != 1) {\n                        for (var i = 0, n = vertices.length; i < n; i++) {\n                            scaledVertices[i] *= scale;\n                        }\n                    }\n                    attachment.vertices = scaledVertices;\n                    return;\n                }\n                var weights = new Array();\n                var bones = new Array();\n                for (var i = 0, n = vertices.length; i < n;) {\n                    var boneCount = vertices[i++];\n                    bones.push(boneCount);\n                    for (var nn = i + boneCount * 4; i < nn; i += 4) {\n                        bones.push(vertices[i]);\n                        weights.push(vertices[i + 1] * scale);\n                        weights.push(vertices[i + 2] * scale);\n                        weights.push(vertices[i + 3]);\n                    }\n                }\n                attachment.bones = bones;\n                attachment.vertices = core.Utils.toFloatArray(weights);\n            };\n            SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\n                var scale = this.scale;\n                var timelines = new Array();\n                var duration = 0;\n                if (map.slots) {\n                    for (var slotName in map.slots) {\n                        var slotMap = map.slots[slotName];\n                        var slotIndex = skeletonData.findSlotIndex(slotName);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                        for (var timelineName in slotMap) {\n                            var timelineMap = slotMap[timelineName];\n                            if (timelineName == \"attachment\") {\n                                var timeline = new core.AttachmentTimeline(timelineMap.length);\n                                timeline.slotIndex = slotIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                            } else if (timelineName == \"color\") {\n                                var timeline = new core.ColorTimeline(timelineMap.length);\n                                timeline.slotIndex = slotIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    var color = new core.Color();\n                                    color.setFromString(valueMap.color);\n                                    timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.ColorTimeline.ENTRIES]);\n                            } else if (timelineName == \"twoColor\") {\n                                var timeline = new core.TwoColorTimeline(timelineMap.length);\n                                timeline.slotIndex = slotIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    var light = new core.Color();\n                                    var dark = new core.Color();\n                                    light.setFromString(valueMap.light);\n                                    dark.setFromString(valueMap.dark);\n                                    timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TwoColorTimeline.ENTRIES]);\n                            } else throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n                        }\n                    }\n                }\n                if (map.bones) {\n                    for (var boneName in map.bones) {\n                        var boneMap = map.bones[boneName];\n                        var boneIndex = skeletonData.findBoneIndex(boneName);\n                        if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n                        for (var timelineName in boneMap) {\n                            var timelineMap = boneMap[timelineName];\n                            if (timelineName === \"rotate\") {\n                                var timeline = new core.RotateTimeline(timelineMap.length);\n                                timeline.boneIndex = boneIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.RotateTimeline.ENTRIES]);\n                            } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                                var timeline = null;\n                                var timelineScale = 1;\n                                if (timelineName === \"scale\") timeline = new core.ScaleTimeline(timelineMap.length);else if (timelineName === \"shear\") timeline = new core.ShearTimeline(timelineMap.length);else {\n                                    timeline = new core.TranslateTimeline(timelineMap.length);\n                                    timelineScale = scale;\n                                }\n                                timeline.boneIndex = boneIndex;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    var x = this.getValue(valueMap, \"x\", 0),\n                                        y = this.getValue(valueMap, \"y\", 0);\n                                    timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TranslateTimeline.ENTRIES]);\n                            } else throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n                        }\n                    }\n                }\n                if (map.ik) {\n                    for (var constraintName in map.ik) {\n                        var constraintMap = map.ik[constraintName];\n                        var constraint = skeletonData.findIkConstraint(constraintName);\n                        var timeline = new core.IkConstraintTimeline(constraintMap.length);\n                        timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                        var frameIndex = 0;\n                        for (var i = 0; i < constraintMap.length; i++) {\n                            var valueMap = constraintMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.IkConstraintTimeline.ENTRIES]);\n                    }\n                }\n                if (map.transform) {\n                    for (var constraintName in map.transform) {\n                        var constraintMap = map.transform[constraintName];\n                        var constraint = skeletonData.findTransformConstraint(constraintName);\n                        var timeline = new core.TransformConstraintTimeline(constraintMap.length);\n                        timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                        var frameIndex = 0;\n                        for (var i = 0; i < constraintMap.length; i++) {\n                            var valueMap = constraintMap[i];\n                            timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n                            this.readCurve(valueMap, timeline, frameIndex);\n                            frameIndex++;\n                        }\n                        timelines.push(timeline);\n                        duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TransformConstraintTimeline.ENTRIES]);\n                    }\n                }\n                if (map.paths) {\n                    for (var constraintName in map.paths) {\n                        var constraintMap = map.paths[constraintName];\n                        var index = skeletonData.findPathConstraintIndex(constraintName);\n                        if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n                        var data = skeletonData.pathConstraints[index];\n                        for (var timelineName in constraintMap) {\n                            var timelineMap = constraintMap[timelineName];\n                            if (timelineName === \"position\" || timelineName === \"spacing\") {\n                                var timeline = null;\n                                var timelineScale = 1;\n                                if (timelineName === \"spacing\") {\n                                    timeline = new core.PathConstraintSpacingTimeline(timelineMap.length);\n                                    if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed) timelineScale = scale;\n                                } else {\n                                    timeline = new core.PathConstraintPositionTimeline(timelineMap.length);\n                                    if (data.positionMode == core.PositionMode.Fixed) timelineScale = scale;\n                                }\n                                timeline.pathConstraintIndex = index;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintPositionTimeline.ENTRIES]);\n                            } else if (timelineName === \"mix\") {\n                                var timeline = new core.PathConstraintMixTimeline(timelineMap.length);\n                                timeline.pathConstraintIndex = index;\n                                var frameIndex = 0;\n                                for (var i = 0; i < timelineMap.length; i++) {\n                                    var valueMap = timelineMap[i];\n                                    timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintMixTimeline.ENTRIES]);\n                            }\n                        }\n                    }\n                }\n                if (map.deform) {\n                    for (var deformName in map.deform) {\n                        var deformMap = map.deform[deformName];\n                        var skin = skeletonData.findSkin(deformName);\n                        if (skin == null) throw new Error(\"Skin not found: \" + deformName);\n                        for (var slotName in deformMap) {\n                            var slotMap = deformMap[slotName];\n                            var slotIndex = skeletonData.findSlotIndex(slotName);\n                            if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n                            for (var timelineName in slotMap) {\n                                var timelineMap = slotMap[timelineName];\n                                var attachment = skin.getAttachment(slotIndex, timelineName);\n                                if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                                var weighted = attachment.bones != null;\n                                var vertices = attachment.vertices;\n                                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n                                var timeline = new core.DeformTimeline(timelineMap.length);\n                                timeline.slotIndex = slotIndex;\n                                timeline.attachment = attachment;\n                                var frameIndex = 0;\n                                for (var j = 0; j < timelineMap.length; j++) {\n                                    var valueMap = timelineMap[j];\n                                    var deform = void 0;\n                                    var verticesValue = this.getValue(valueMap, \"vertices\", null);\n                                    if (verticesValue == null) deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;else {\n                                        deform = core.Utils.newFloatArray(deformLength);\n                                        var start = this.getValue(valueMap, \"offset\", 0);\n                                        core.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                        if (scale != 1) {\n                                            for (var i = start, n = i + verticesValue.length; i < n; i++) {\n                                                deform[i] *= scale;\n                                            }\n                                        }\n                                        if (!weighted) {\n                                            for (var i = 0; i < deformLength; i++) {\n                                                deform[i] += vertices[i];\n                                            }\n                                        }\n                                    }\n                                    timeline.setFrame(frameIndex, valueMap.time, deform);\n                                    this.readCurve(valueMap, timeline, frameIndex);\n                                    frameIndex++;\n                                }\n                                timelines.push(timeline);\n                                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                            }\n                        }\n                    }\n                }\n                var drawOrderNode = map.drawOrder;\n                if (drawOrderNode == null) drawOrderNode = map.draworder;\n                if (drawOrderNode != null) {\n                    var timeline = new core.DrawOrderTimeline(drawOrderNode.length);\n                    var slotCount = skeletonData.slots.length;\n                    var frameIndex = 0;\n                    for (var j = 0; j < drawOrderNode.length; j++) {\n                        var drawOrderMap = drawOrderNode[j];\n                        var drawOrder = null;\n                        var offsets = this.getValue(drawOrderMap, \"offsets\", null);\n                        if (offsets != null) {\n                            drawOrder = core.Utils.newArray(slotCount, -1);\n                            var unchanged = core.Utils.newArray(slotCount - offsets.length, 0);\n                            var originalIndex = 0,\n                                unchangedIndex = 0;\n                            for (var i = 0; i < offsets.length; i++) {\n                                var offsetMap = offsets[i];\n                                var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                                if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\n                                while (originalIndex != slotIndex) {\n                                    unchanged[unchangedIndex++] = originalIndex++;\n                                }drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                            }\n                            while (originalIndex < slotCount) {\n                                unchanged[unchangedIndex++] = originalIndex++;\n                            }for (var i = slotCount - 1; i >= 0; i--) {\n                                if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                            }\n                        }\n                        timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n                if (map.events) {\n                    var timeline = new core.EventTimeline(map.events.length);\n                    var frameIndex = 0;\n                    for (var i = 0; i < map.events.length; i++) {\n                        var eventMap = map.events[i];\n                        var eventData = skeletonData.findEvent(eventMap.name);\n                        if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\n                        var event_5 = new core.Event(core.Utils.toSinglePrecision(eventMap.time), eventData);\n                        event_5.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n                        event_5.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n                        event_5.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n                        timeline.setFrame(frameIndex++, event_5);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n                if (isNaN(duration)) {\n                    throw new Error(\"Error while parsing animation, duration is NaN\");\n                }\n                skeletonData.animations.push(new core.Animation(name, timelines, duration));\n            };\n            SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\n                if (!map.curve) return;\n                if (map.curve === \"stepped\") timeline.setStepped(frameIndex);else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n                    var curve = map.curve;\n                    timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n                }\n            };\n            SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\n                return map[prop] !== undefined ? map[prop] : defaultValue;\n            };\n            SkeletonJson.blendModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"normal\") return core.BlendMode.Normal;\n                if (str == \"additive\") return core.BlendMode.Additive;\n                if (str == \"multiply\") return core.BlendMode.Multiply;\n                if (str == \"screen\") return core.BlendMode.Screen;\n                throw new Error(\"Unknown blend mode: \" + str);\n            };\n            SkeletonJson.positionModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"fixed\") return core.PositionMode.Fixed;\n                if (str == \"percent\") return core.PositionMode.Percent;\n                throw new Error(\"Unknown position mode: \" + str);\n            };\n            SkeletonJson.spacingModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"length\") return core.SpacingMode.Length;\n                if (str == \"fixed\") return core.SpacingMode.Fixed;\n                if (str == \"percent\") return core.SpacingMode.Percent;\n                throw new Error(\"Unknown position mode: \" + str);\n            };\n            SkeletonJson.rotateModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"tangent\") return core.RotateMode.Tangent;\n                if (str == \"chain\") return core.RotateMode.Chain;\n                if (str == \"chainscale\") return core.RotateMode.ChainScale;\n                throw new Error(\"Unknown rotate mode: \" + str);\n            };\n            SkeletonJson.transformModeFromString = function (str) {\n                str = str.toLowerCase();\n                if (str == \"normal\") return core.TransformMode.Normal;\n                if (str == \"onlytranslation\") return core.TransformMode.OnlyTranslation;\n                if (str == \"norotationorreflection\") return core.TransformMode.NoRotationOrReflection;\n                if (str == \"noscale\") return core.TransformMode.NoScale;\n                if (str == \"noscaleorreflection\") return core.TransformMode.NoScaleOrReflection;\n                throw new Error(\"Unknown transform mode: \" + str);\n            };\n            return SkeletonJson;\n        }();\n        core.SkeletonJson = SkeletonJson;\n        var LinkedMesh = function () {\n            function LinkedMesh(mesh, skin, slotIndex, parent) {\n                this.mesh = mesh;\n                this.skin = skin;\n                this.slotIndex = slotIndex;\n                this.parent = parent;\n            }\n            return LinkedMesh;\n        }();\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Skin = function () {\n            function Skin(name) {\n                this.attachments = new Array();\n                if (name == null) throw new Error(\"name cannot be null.\");\n                this.name = name;\n            }\n            Skin.prototype.addAttachment = function (slotIndex, name, attachment) {\n                if (attachment == null) throw new Error(\"attachment cannot be null.\");\n                var attachments = this.attachments;\n                if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n                if (!attachments[slotIndex]) attachments[slotIndex] = {};\n                attachments[slotIndex][name] = attachment;\n            };\n            Skin.prototype.getAttachment = function (slotIndex, name) {\n                var dictionary = this.attachments[slotIndex];\n                return dictionary ? dictionary[name] : null;\n            };\n            Skin.prototype.attachAll = function (skeleton, oldSkin) {\n                var slotIndex = 0;\n                for (var i = 0; i < skeleton.slots.length; i++) {\n                    var slot = skeleton.slots[i];\n                    var slotAttachment = slot.getAttachment();\n                    if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                        var dictionary = oldSkin.attachments[slotIndex];\n                        for (var key in dictionary) {\n                            var skinAttachment = dictionary[key];\n                            if (slotAttachment == skinAttachment) {\n                                var attachment = this.getAttachment(slotIndex, name);\n                                if (attachment != null) slot.setAttachment(attachment);\n                                break;\n                            }\n                        }\n                    }\n                    slotIndex++;\n                }\n            };\n            return Skin;\n        }();\n        core.Skin = Skin;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Slot = function () {\n            function Slot(data, bone) {\n                this.attachmentVertices = new Array();\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (bone == null) throw new Error(\"bone cannot be null.\");\n                this.data = data;\n                this.bone = bone;\n                this.color = new core.Color();\n                this.darkColor = data.darkColor == null ? null : new core.Color();\n                this.setToSetupPose();\n                this.blendMode = this.data.blendMode;\n            }\n            Slot.prototype.getAttachment = function () {\n                return this.attachment;\n            };\n            Slot.prototype.setAttachment = function (attachment) {\n                if (this.attachment == attachment) return;\n                this.attachment = attachment;\n                this.attachmentTime = this.bone.skeleton.time;\n                this.attachmentVertices.length = 0;\n            };\n            Slot.prototype.setAttachmentTime = function (time) {\n                this.attachmentTime = this.bone.skeleton.time - time;\n            };\n            Slot.prototype.getAttachmentTime = function () {\n                return this.bone.skeleton.time - this.attachmentTime;\n            };\n            Slot.prototype.setToSetupPose = function () {\n                this.color.setFromColor(this.data.color);\n                if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n                if (this.data.attachmentName == null) this.attachment = null;else {\n                    this.attachment = null;\n                    this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n                }\n            };\n            return Slot;\n        }();\n        core.Slot = Slot;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SlotData = function () {\n            function SlotData(index, name, boneData) {\n                this.color = new core.Color(1, 1, 1, 1);\n                if (index < 0) throw new Error(\"index must be >= 0.\");\n                if (name == null) throw new Error(\"name cannot be null.\");\n                if (boneData == null) throw new Error(\"boneData cannot be null.\");\n                this.index = index;\n                this.name = name;\n                this.boneData = boneData;\n            }\n            return SlotData;\n        }();\n        core.SlotData = SlotData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Texture = function () {\n            function Texture(image) {\n                this._image = image;\n            }\n            Texture.prototype.getImage = function () {\n                return this._image;\n            };\n            Texture.filterFromString = function (text) {\n                switch (text.toLowerCase()) {\n                    case \"nearest\":\n                        return TextureFilter.Nearest;\n                    case \"linear\":\n                        return TextureFilter.Linear;\n                    case \"mipmap\":\n                        return TextureFilter.MipMap;\n                    case \"mipmapnearestnearest\":\n                        return TextureFilter.MipMapNearestNearest;\n                    case \"mipmaplinearnearest\":\n                        return TextureFilter.MipMapLinearNearest;\n                    case \"mipmapnearestlinear\":\n                        return TextureFilter.MipMapNearestLinear;\n                    case \"mipmaplinearlinear\":\n                        return TextureFilter.MipMapLinearLinear;\n                    default:\n                        throw new Error(\"Unknown texture filter \" + text);\n                }\n            };\n            Texture.wrapFromString = function (text) {\n                switch (text.toLowerCase()) {\n                    case \"mirroredtepeat\":\n                        return TextureWrap.MirroredRepeat;\n                    case \"clamptoedge\":\n                        return TextureWrap.ClampToEdge;\n                    case \"repeat\":\n                        return TextureWrap.Repeat;\n                    default:\n                        throw new Error(\"Unknown texture wrap \" + text);\n                }\n            };\n            return Texture;\n        }();\n        core.Texture = Texture;\n        var TextureFilter;\n        (function (TextureFilter) {\n            TextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\n            TextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\n            TextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\n            TextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\n            TextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\n            TextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\n            TextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\n        })(TextureFilter = core.TextureFilter || (core.TextureFilter = {}));\n        var TextureWrap;\n        (function (TextureWrap) {\n            TextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\n            TextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\n            TextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\n        })(TextureWrap = core.TextureWrap || (core.TextureWrap = {}));\n        var TextureRegion = function () {\n            function TextureRegion() {\n                this.size = null;\n            }\n            Object.defineProperty(TextureRegion.prototype, \"width\", {\n                get: function get() {\n                    var tex = this.texture;\n                    if (PIXI.VERSION[0] == '3') {\n                        return tex.crop.width;\n                    }\n                    if (tex.trim) {\n                        return tex.trim.width;\n                    }\n                    return tex.orig.width;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"height\", {\n                get: function get() {\n                    var tex = this.texture;\n                    if (PIXI.VERSION[0] == '3') {\n                        return tex.crop.height;\n                    }\n                    if (tex.trim) {\n                        return tex.trim.height;\n                    }\n                    return tex.orig.height;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"u\", {\n                get: function get() {\n                    return this.texture._uvs.x0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"v\", {\n                get: function get() {\n                    return this.texture._uvs.y0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"u2\", {\n                get: function get() {\n                    return this.texture._uvs.x2;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"v2\", {\n                get: function get() {\n                    return this.texture._uvs.y2;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"offsetX\", {\n                get: function get() {\n                    var tex = this.texture;\n                    return tex.trim ? tex.trim.x : 0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"offsetY\", {\n                get: function get() {\n                    console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n                    return this.spineOffsetY;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"pixiOffsetY\", {\n                get: function get() {\n                    var tex = this.texture;\n                    return tex.trim ? tex.trim.y : 0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"spineOffsetY\", {\n                get: function get() {\n                    var tex = this.texture;\n                    return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"originalWidth\", {\n                get: function get() {\n                    var tex = this.texture;\n                    if (PIXI.VERSION[0] == '3') {\n                        if (tex.trim) {\n                            return tex.trim.width;\n                        }\n                        return tex.crop.width;\n                    }\n                    return tex.orig.width;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"originalHeight\", {\n                get: function get() {\n                    var tex = this.texture;\n                    if (PIXI.VERSION[0] == '3') {\n                        if (tex.trim) {\n                            return tex.trim.height;\n                        }\n                        return tex.crop.height;\n                    }\n                    return tex.orig.height;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"x\", {\n                get: function get() {\n                    return this.texture.frame.x;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"y\", {\n                get: function get() {\n                    return this.texture.frame.y;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(TextureRegion.prototype, \"rotate\", {\n                get: function get() {\n                    return this.texture.rotate !== 0;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return TextureRegion;\n        }();\n        core.TextureRegion = TextureRegion;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var TextureAtlas = function () {\n            function TextureAtlas(atlasText, textureLoader, callback) {\n                this.pages = new Array();\n                this.regions = new Array();\n                if (atlasText) {\n                    this.addSpineAtlas(atlasText, textureLoader, callback);\n                }\n            }\n            TextureAtlas.prototype.addTexture = function (name, texture) {\n                var pages = this.pages;\n                var page = null;\n                for (var i = 0; i < pages.length; i++) {\n                    if (pages[i].baseTexture === texture.baseTexture) {\n                        page = pages[i];\n                        break;\n                    }\n                }\n                if (page === null) {\n                    page = new TextureAtlasPage();\n                    page.name = 'texturePage';\n                    var baseTexture = texture.baseTexture;\n                    page.width = baseTexture.realWidth;\n                    page.height = baseTexture.realHeight;\n                    page.baseTexture = baseTexture;\n                    page.minFilter = page.magFilter = core.TextureFilter.Nearest;\n                    page.uWrap = core.TextureWrap.ClampToEdge;\n                    page.vWrap = core.TextureWrap.ClampToEdge;\n                    pages.push(page);\n                }\n                var region = new TextureAtlasRegion();\n                region.name = name;\n                region.page = page;\n                region.texture = texture;\n                region.index = -1;\n                this.regions.push(region);\n                return region;\n            };\n            TextureAtlas.prototype.addTextureHash = function (textures, stripExtension) {\n                for (var key in textures) {\n                    if (textures.hasOwnProperty(key)) {\n                        this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n                    }\n                }\n            };\n            TextureAtlas.prototype.addSpineAtlas = function (atlasText, textureLoader, callback) {\n                return this.load(atlasText, textureLoader, callback);\n            };\n            TextureAtlas.prototype.load = function (atlasText, textureLoader, callback) {\n                var _this = this;\n                if (textureLoader == null) throw new Error(\"textureLoader cannot be null.\");\n                var reader = new TextureAtlasReader(atlasText);\n                var tuple = new Array(4);\n                var page = null;\n                var iterateParser = function iterateParser() {\n                    while (true) {\n                        var line = reader.readLine();\n                        if (line == null) {\n                            return callback && callback(_this);\n                        }\n                        line = line.trim();\n                        if (line.length == 0) page = null;else if (!page) {\n                            page = new TextureAtlasPage();\n                            page.name = line;\n                            if (reader.readTuple(tuple) == 2) {\n                                page.width = parseInt(tuple[0]);\n                                page.height = parseInt(tuple[1]);\n                                reader.readTuple(tuple);\n                            }\n                            reader.readTuple(tuple);\n                            page.minFilter = core.Texture.filterFromString(tuple[0]);\n                            page.magFilter = core.Texture.filterFromString(tuple[1]);\n                            var direction = reader.readValue();\n                            page.uWrap = core.TextureWrap.ClampToEdge;\n                            page.vWrap = core.TextureWrap.ClampToEdge;\n                            if (direction == \"x\") page.uWrap = core.TextureWrap.Repeat;else if (direction == \"y\") page.vWrap = core.TextureWrap.Repeat;else if (direction == \"xy\") page.uWrap = page.vWrap = core.TextureWrap.Repeat;\n                            textureLoader(line, function (texture) {\n                                page.baseTexture = texture;\n                                if (!texture.hasLoaded) {\n                                    texture.width = page.width;\n                                    texture.height = page.height;\n                                }\n                                _this.pages.push(page);\n                                page.setFilters();\n                                if (!page.width || !page.height) {\n                                    page.width = texture.realWidth;\n                                    page.height = texture.realHeight;\n                                    if (!page.width || !page.height) {\n                                        console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                                    }\n                                }\n                                iterateParser();\n                            });\n                            _this.pages.push(page);\n                            break;\n                        } else {\n                            var region = new TextureAtlasRegion();\n                            region.name = line;\n                            region.page = page;\n                            var rotate = reader.readValue() == \"true\" ? 6 : 0;\n                            reader.readTuple(tuple);\n                            var x = parseInt(tuple[0]);\n                            var y = parseInt(tuple[1]);\n                            reader.readTuple(tuple);\n                            var width = parseInt(tuple[0]);\n                            var height = parseInt(tuple[1]);\n                            var resolution = page.baseTexture.resolution;\n                            x /= resolution;\n                            y /= resolution;\n                            width /= resolution;\n                            height /= resolution;\n                            var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n                            if (reader.readTuple(tuple) == 4) {\n                                if (reader.readTuple(tuple) == 4) {\n                                    reader.readTuple(tuple);\n                                }\n                            }\n                            var originalWidth = parseInt(tuple[0]) / resolution;\n                            var originalHeight = parseInt(tuple[1]) / resolution;\n                            reader.readTuple(tuple);\n                            var offsetX = parseInt(tuple[0]) / resolution;\n                            var offsetY = parseInt(tuple[1]) / resolution;\n                            var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n                            var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n                            if (PIXI.VERSION[0] != '3') {\n                                region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\n                            } else {\n                                var frame2 = new PIXI.Rectangle(x, y, width, height);\n                                var crop = frame2.clone();\n                                trim.width = originalWidth;\n                                trim.height = originalHeight;\n                                region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\n                            }\n                            region.index = parseInt(reader.readValue());\n                            region.texture._updateUvs();\n                            _this.regions.push(region);\n                        }\n                    }\n                };\n                iterateParser();\n            };\n            TextureAtlas.prototype.findRegion = function (name) {\n                for (var i = 0; i < this.regions.length; i++) {\n                    if (this.regions[i].name == name) {\n                        return this.regions[i];\n                    }\n                }\n                return null;\n            };\n            TextureAtlas.prototype.dispose = function () {\n                for (var i = 0; i < this.pages.length; i++) {\n                    this.pages[i].baseTexture.dispose();\n                }\n            };\n            return TextureAtlas;\n        }();\n        core.TextureAtlas = TextureAtlas;\n        var TextureAtlasReader = function () {\n            function TextureAtlasReader(text) {\n                this.index = 0;\n                this.lines = text.split(/\\r\\n|\\r|\\n/);\n            }\n            TextureAtlasReader.prototype.readLine = function () {\n                if (this.index >= this.lines.length) return null;\n                return this.lines[this.index++];\n            };\n            TextureAtlasReader.prototype.readValue = function () {\n                var line = this.readLine();\n                var colon = line.indexOf(\":\");\n                if (colon == -1) throw new Error(\"Invalid line: \" + line);\n                return line.substring(colon + 1).trim();\n            };\n            TextureAtlasReader.prototype.readTuple = function (tuple) {\n                var line = this.readLine();\n                var colon = line.indexOf(\":\");\n                if (colon == -1) throw new Error(\"Invalid line: \" + line);\n                var i = 0,\n                    lastMatch = colon + 1;\n                for (; i < 3; i++) {\n                    var comma = line.indexOf(\",\", lastMatch);\n                    if (comma == -1) break;\n                    tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n                    lastMatch = comma + 1;\n                }\n                tuple[i] = line.substring(lastMatch).trim();\n                return i + 1;\n            };\n            return TextureAtlasReader;\n        }();\n        var TextureAtlasPage = function () {\n            function TextureAtlasPage() {}\n            TextureAtlasPage.prototype.setFilters = function () {\n                var tex = this.baseTexture;\n                var filter = this.minFilter;\n                if (filter == core.TextureFilter.Linear) {\n                    tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n                } else if (this.minFilter == core.TextureFilter.Nearest) {\n                    tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n                } else {\n                    tex.mipmap = true;\n                    if (filter == core.TextureFilter.MipMapNearestNearest) {\n                        tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n                    } else {\n                        tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n                    }\n                }\n            };\n            return TextureAtlasPage;\n        }();\n        core.TextureAtlasPage = TextureAtlasPage;\n        var TextureAtlasRegion = function (_super) {\n            __extends(TextureAtlasRegion, _super);\n            function TextureAtlasRegion() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            return TextureAtlasRegion;\n        }(core.TextureRegion);\n        core.TextureAtlasRegion = TextureAtlasRegion;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var TransformConstraint = function () {\n            function TransformConstraint(data, skeleton) {\n                this.rotateMix = 0;\n                this.translateMix = 0;\n                this.scaleMix = 0;\n                this.shearMix = 0;\n                this.temp = new core.Vector2();\n                if (data == null) throw new Error(\"data cannot be null.\");\n                if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n                this.data = data;\n                this.rotateMix = data.rotateMix;\n                this.translateMix = data.translateMix;\n                this.scaleMix = data.scaleMix;\n                this.shearMix = data.shearMix;\n                this.bones = new Array();\n                for (var i = 0; i < data.bones.length; i++) {\n                    this.bones.push(skeleton.findBone(data.bones[i].name));\n                }this.target = skeleton.findBone(data.target.name);\n            }\n            TransformConstraint.prototype.apply = function () {\n                this.update();\n            };\n            TransformConstraint.prototype.update = function () {\n                if (this.data.local) {\n                    if (this.data.relative) this.applyRelativeLocal();else this.applyAbsoluteLocal();\n                } else {\n                    if (this.data.relative) this.applyRelativeWorld();else this.applyAbsoluteWorld();\n                }\n            };\n            TransformConstraint.prototype.applyAbsoluteWorld = function () {\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix,\n                    scaleMix = this.scaleMix,\n                    shearMix = this.shearMix;\n                var target = this.target;\n                var targetMat = target.matrix;\n                var ta = targetMat.a,\n                    tb = targetMat.c,\n                    tc = targetMat.b,\n                    td = targetMat.d;\n                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n                var offsetRotation = this.data.offsetRotation * degRadReflect;\n                var offsetShearY = this.data.offsetShearY * degRadReflect;\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    var modified = false;\n                    var mat = bone.matrix;\n                    if (rotateMix != 0) {\n                        var a = mat.a,\n                            b = mat.c,\n                            c = mat.b,\n                            d = mat.d;\n                        var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        r *= rotateMix;\n                        var cos = Math.cos(r),\n                            sin = Math.sin(r);\n                        mat.a = cos * a - sin * c;\n                        mat.c = cos * b - sin * d;\n                        mat.b = sin * a + cos * c;\n                        mat.d = sin * b + cos * d;\n                        modified = true;\n                    }\n                    if (translateMix != 0) {\n                        var temp = this.temp;\n                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                        mat.tx += (temp.x - mat.tx) * translateMix;\n                        mat.ty += (temp.y - mat.ty) * translateMix;\n                        modified = true;\n                    }\n                    if (scaleMix > 0) {\n                        var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                        var ts = Math.sqrt(ta * ta + tc * tc);\n                        if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                        mat.a *= s;\n                        mat.b *= s;\n                        s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                        ts = Math.sqrt(tb * tb + td * td);\n                        if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                        mat.c *= s;\n                        mat.d *= s;\n                        modified = true;\n                    }\n                    if (shearMix > 0) {\n                        var b = mat.c,\n                            d = mat.d;\n                        var by = Math.atan2(d, b);\n                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        r = by + (r + offsetShearY) * shearMix;\n                        var s = Math.sqrt(b * b + d * d);\n                        mat.c = Math.cos(r) * s;\n                        mat.d = Math.sin(r) * s;\n                        modified = true;\n                    }\n                    if (modified) bone.appliedValid = false;\n                }\n            };\n            TransformConstraint.prototype.applyRelativeWorld = function () {\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix,\n                    scaleMix = this.scaleMix,\n                    shearMix = this.shearMix;\n                var target = this.target;\n                var targetMat = target.matrix;\n                var ta = targetMat.a,\n                    tb = targetMat.c,\n                    tc = targetMat.b,\n                    td = targetMat.d;\n                var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n                var offsetRotation = this.data.offsetRotation * degRadReflect,\n                    offsetShearY = this.data.offsetShearY * degRadReflect;\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    var modified = false;\n                    var mat = bone.matrix;\n                    if (rotateMix != 0) {\n                        var a = mat.a,\n                            b = mat.c,\n                            c = mat.b,\n                            d = mat.d;\n                        var r = Math.atan2(tc, ta) + offsetRotation;\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        r *= rotateMix;\n                        var cos = Math.cos(r),\n                            sin = Math.sin(r);\n                        mat.a = cos * a - sin * c;\n                        mat.c = cos * b - sin * d;\n                        mat.b = sin * a + cos * c;\n                        mat.d = sin * b + cos * d;\n                        modified = true;\n                    }\n                    if (translateMix != 0) {\n                        var temp = this.temp;\n                        target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                        mat.tx += temp.x * translateMix;\n                        mat.ty += temp.y * translateMix;\n                        modified = true;\n                    }\n                    if (scaleMix > 0) {\n                        var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                        mat.a *= s;\n                        mat.b *= s;\n                        s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                        mat.c *= s;\n                        mat.d *= s;\n                        modified = true;\n                    }\n                    if (shearMix > 0) {\n                        var r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n                        if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n                        var b = mat.c,\n                            d = mat.d;\n                        r = Math.atan2(d, b) + (r - core.MathUtils.PI / 2 + offsetShearY) * shearMix;\n                        var s = Math.sqrt(b * b + d * d);\n                        mat.c = Math.cos(r) * s;\n                        mat.d = Math.sin(r) * s;\n                        modified = true;\n                    }\n                    if (modified) bone.appliedValid = false;\n                }\n            };\n            TransformConstraint.prototype.applyAbsoluteLocal = function () {\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix,\n                    scaleMix = this.scaleMix,\n                    shearMix = this.shearMix;\n                var target = this.target;\n                if (!target.appliedValid) target.updateAppliedTransform();\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (!bone.appliedValid) bone.updateAppliedTransform();\n                    var rotation = bone.arotation;\n                    if (rotateMix != 0) {\n                        var r = target.arotation - rotation + this.data.offsetRotation;\n                        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                        rotation += r * rotateMix;\n                    }\n                    var x = bone.ax,\n                        y = bone.ay;\n                    if (translateMix != 0) {\n                        x += (target.ax - x + this.data.offsetX) * translateMix;\n                        y += (target.ay - y + this.data.offsetY) * translateMix;\n                    }\n                    var scaleX = bone.ascaleX,\n                        scaleY = bone.ascaleY;\n                    if (scaleMix > 0) {\n                        if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                        if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n                    }\n                    var shearY = bone.ashearY;\n                    if (shearMix > 0) {\n                        var r = target.ashearY - shearY + this.data.offsetShearY;\n                        r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n                        bone.shearY += r * shearMix;\n                    }\n                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n                }\n            };\n            TransformConstraint.prototype.applyRelativeLocal = function () {\n                var rotateMix = this.rotateMix,\n                    translateMix = this.translateMix,\n                    scaleMix = this.scaleMix,\n                    shearMix = this.shearMix;\n                var target = this.target;\n                if (!target.appliedValid) target.updateAppliedTransform();\n                var bones = this.bones;\n                for (var i = 0, n = bones.length; i < n; i++) {\n                    var bone = bones[i];\n                    if (!bone.appliedValid) bone.updateAppliedTransform();\n                    var rotation = bone.arotation;\n                    if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n                    var x = bone.ax,\n                        y = bone.ay;\n                    if (translateMix != 0) {\n                        x += (target.ax + this.data.offsetX) * translateMix;\n                        y += (target.ay + this.data.offsetY) * translateMix;\n                    }\n                    var scaleX = bone.ascaleX,\n                        scaleY = bone.ascaleY;\n                    if (scaleMix > 0) {\n                        if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                        if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                    }\n                    var shearY = bone.ashearY;\n                    if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n                    bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n                }\n            };\n            TransformConstraint.prototype.getOrder = function () {\n                return this.data.order;\n            };\n            return TransformConstraint;\n        }();\n        core.TransformConstraint = TransformConstraint;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var TransformConstraintData = function () {\n            function TransformConstraintData(name) {\n                this.order = 0;\n                this.bones = new Array();\n                this.rotateMix = 0;\n                this.translateMix = 0;\n                this.scaleMix = 0;\n                this.shearMix = 0;\n                this.offsetRotation = 0;\n                this.offsetX = 0;\n                this.offsetY = 0;\n                this.offsetScaleX = 0;\n                this.offsetScaleY = 0;\n                this.offsetShearY = 0;\n                this.relative = false;\n                this.local = false;\n                if (name == null) throw new Error(\"name cannot be null.\");\n                this.name = name;\n            }\n            return TransformConstraintData;\n        }();\n        core.TransformConstraintData = TransformConstraintData;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var Triangulator = function () {\n            function Triangulator() {\n                this.convexPolygons = new Array();\n                this.convexPolygonsIndices = new Array();\n                this.indicesArray = new Array();\n                this.isConcaveArray = new Array();\n                this.triangles = new Array();\n                this.polygonPool = new core.Pool(function () {\n                    return new Array();\n                });\n                this.polygonIndicesPool = new core.Pool(function () {\n                    return new Array();\n                });\n            }\n            Triangulator.prototype.triangulate = function (verticesArray) {\n                var vertices = verticesArray;\n                var vertexCount = verticesArray.length >> 1;\n                var indices = this.indicesArray;\n                indices.length = 0;\n                for (var i = 0; i < vertexCount; i++) {\n                    indices[i] = i;\n                }var isConcave = this.isConcaveArray;\n                isConcave.length = 0;\n                for (var i = 0, n = vertexCount; i < n; ++i) {\n                    isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n                }var triangles = this.triangles;\n                triangles.length = 0;\n                while (vertexCount > 3) {\n                    var previous = vertexCount - 1,\n                        i = 0,\n                        next = 1;\n                    while (true) {\n                        outer: if (!isConcave[i]) {\n                            var p1 = indices[previous] << 1,\n                                p2 = indices[i] << 1,\n                                p3 = indices[next] << 1;\n                            var p1x = vertices[p1],\n                                p1y = vertices[p1 + 1];\n                            var p2x = vertices[p2],\n                                p2y = vertices[p2 + 1];\n                            var p3x = vertices[p3],\n                                p3y = vertices[p3 + 1];\n                            for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n                                if (!isConcave[ii]) continue;\n                                var v = indices[ii] << 1;\n                                var vx = vertices[v],\n                                    vy = vertices[v + 1];\n                                if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n                                    if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n                                        if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                        if (next == 0) {\n                            do {\n                                if (!isConcave[i]) break;\n                                i--;\n                            } while (i > 0);\n                            break;\n                        }\n                        previous = i;\n                        i = next;\n                        next = (next + 1) % vertexCount;\n                    }\n                    triangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n                    triangles.push(indices[i]);\n                    triangles.push(indices[(i + 1) % vertexCount]);\n                    indices.splice(i, 1);\n                    isConcave.splice(i, 1);\n                    vertexCount--;\n                    var previousIndex = (vertexCount + i - 1) % vertexCount;\n                    var nextIndex = i == vertexCount ? 0 : i;\n                    isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n                    isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n                }\n                if (vertexCount == 3) {\n                    triangles.push(indices[2]);\n                    triangles.push(indices[0]);\n                    triangles.push(indices[1]);\n                }\n                return triangles;\n            };\n            Triangulator.prototype.decompose = function (verticesArray, triangles) {\n                var vertices = verticesArray;\n                var convexPolygons = this.convexPolygons;\n                this.polygonPool.freeAll(convexPolygons);\n                convexPolygons.length = 0;\n                var convexPolygonsIndices = this.convexPolygonsIndices;\n                this.polygonIndicesPool.freeAll(convexPolygonsIndices);\n                convexPolygonsIndices.length = 0;\n                var polygonIndices = this.polygonIndicesPool.obtain();\n                polygonIndices.length = 0;\n                var polygon = this.polygonPool.obtain();\n                polygon.length = 0;\n                var fanBaseIndex = -1,\n                    lastWinding = 0;\n                for (var i = 0, n = triangles.length; i < n; i += 3) {\n                    var t1 = triangles[i] << 1,\n                        t2 = triangles[i + 1] << 1,\n                        t3 = triangles[i + 2] << 1;\n                    var x1 = vertices[t1],\n                        y1 = vertices[t1 + 1];\n                    var x2 = vertices[t2],\n                        y2 = vertices[t2 + 1];\n                    var x3 = vertices[t3],\n                        y3 = vertices[t3 + 1];\n                    var merged = false;\n                    if (fanBaseIndex == t1) {\n                        var o = polygon.length - 4;\n                        var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n                        var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n                        if (winding1 == lastWinding && winding2 == lastWinding) {\n                            polygon.push(x3);\n                            polygon.push(y3);\n                            polygonIndices.push(t3);\n                            merged = true;\n                        }\n                    }\n                    if (!merged) {\n                        if (polygon.length > 0) {\n                            convexPolygons.push(polygon);\n                            convexPolygonsIndices.push(polygonIndices);\n                        } else {\n                            this.polygonPool.free(polygon);\n                            this.polygonIndicesPool.free(polygonIndices);\n                        }\n                        polygon = this.polygonPool.obtain();\n                        polygon.length = 0;\n                        polygon.push(x1);\n                        polygon.push(y1);\n                        polygon.push(x2);\n                        polygon.push(y2);\n                        polygon.push(x3);\n                        polygon.push(y3);\n                        polygonIndices = this.polygonIndicesPool.obtain();\n                        polygonIndices.length = 0;\n                        polygonIndices.push(t1);\n                        polygonIndices.push(t2);\n                        polygonIndices.push(t3);\n                        lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n                        fanBaseIndex = t1;\n                    }\n                }\n                if (polygon.length > 0) {\n                    convexPolygons.push(polygon);\n                    convexPolygonsIndices.push(polygonIndices);\n                }\n                for (var i = 0, n = convexPolygons.length; i < n; i++) {\n                    polygonIndices = convexPolygonsIndices[i];\n                    if (polygonIndices.length == 0) continue;\n                    var firstIndex = polygonIndices[0];\n                    var lastIndex = polygonIndices[polygonIndices.length - 1];\n                    polygon = convexPolygons[i];\n                    var o = polygon.length - 4;\n                    var prevPrevX = polygon[o],\n                        prevPrevY = polygon[o + 1];\n                    var prevX = polygon[o + 2],\n                        prevY = polygon[o + 3];\n                    var firstX = polygon[0],\n                        firstY = polygon[1];\n                    var secondX = polygon[2],\n                        secondY = polygon[3];\n                    var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n                    for (var ii = 0; ii < n; ii++) {\n                        if (ii == i) continue;\n                        var otherIndices = convexPolygonsIndices[ii];\n                        if (otherIndices.length != 3) continue;\n                        var otherFirstIndex = otherIndices[0];\n                        var otherSecondIndex = otherIndices[1];\n                        var otherLastIndex = otherIndices[2];\n                        var otherPoly = convexPolygons[ii];\n                        var x3 = otherPoly[otherPoly.length - 2],\n                            y3 = otherPoly[otherPoly.length - 1];\n                        if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\n                        var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n                        var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n                        if (winding1 == winding && winding2 == winding) {\n                            otherPoly.length = 0;\n                            otherIndices.length = 0;\n                            polygon.push(x3);\n                            polygon.push(y3);\n                            polygonIndices.push(otherLastIndex);\n                            prevPrevX = prevX;\n                            prevPrevY = prevY;\n                            prevX = x3;\n                            prevY = y3;\n                            ii = 0;\n                        }\n                    }\n                }\n                for (var i = convexPolygons.length - 1; i >= 0; i--) {\n                    polygon = convexPolygons[i];\n                    if (polygon.length == 0) {\n                        convexPolygons.splice(i, 1);\n                        this.polygonPool.free(polygon);\n                        polygonIndices = convexPolygonsIndices[i];\n                        convexPolygonsIndices.splice(i, 1);\n                        this.polygonIndicesPool.free(polygonIndices);\n                    }\n                }\n                return convexPolygons;\n            };\n            Triangulator.isConcave = function (index, vertexCount, vertices, indices) {\n                var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n                var current = indices[index] << 1;\n                var next = indices[(index + 1) % vertexCount] << 1;\n                return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\n            };\n            Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n                return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n            };\n            Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n                var px = p2x - p1x,\n                    py = p2y - p1y;\n                return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n            };\n            return Triangulator;\n        }();\n        core.Triangulator = Triangulator;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var IntSet = function () {\n            function IntSet() {\n                this.array = new Array();\n            }\n            IntSet.prototype.add = function (value) {\n                var contains = this.contains(value);\n                this.array[value | 0] = value | 0;\n                return !contains;\n            };\n            IntSet.prototype.contains = function (value) {\n                return this.array[value | 0] != undefined;\n            };\n            IntSet.prototype.remove = function (value) {\n                this.array[value | 0] = undefined;\n            };\n            IntSet.prototype.clear = function () {\n                this.array.length = 0;\n            };\n            return IntSet;\n        }();\n        core.IntSet = IntSet;\n        var Color = function () {\n            function Color(r, g, b, a) {\n                if (r === void 0) {\n                    r = 0;\n                }\n                if (g === void 0) {\n                    g = 0;\n                }\n                if (b === void 0) {\n                    b = 0;\n                }\n                if (a === void 0) {\n                    a = 0;\n                }\n                this.r = r;\n                this.g = g;\n                this.b = b;\n                this.a = a;\n            }\n            Color.prototype.set = function (r, g, b, a) {\n                this.r = r;\n                this.g = g;\n                this.b = b;\n                this.a = a;\n                this.clamp();\n                return this;\n            };\n            Color.prototype.setFromColor = function (c) {\n                this.r = c.r;\n                this.g = c.g;\n                this.b = c.b;\n                this.a = c.a;\n                return this;\n            };\n            Color.prototype.setFromString = function (hex) {\n                hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n                this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n                this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n                this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n                this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n                return this;\n            };\n            Color.prototype.add = function (r, g, b, a) {\n                this.r += r;\n                this.g += g;\n                this.b += b;\n                this.a += a;\n                this.clamp();\n                return this;\n            };\n            Color.prototype.clamp = function () {\n                if (this.r < 0) this.r = 0;else if (this.r > 1) this.r = 1;\n                if (this.g < 0) this.g = 0;else if (this.g > 1) this.g = 1;\n                if (this.b < 0) this.b = 0;else if (this.b > 1) this.b = 1;\n                if (this.a < 0) this.a = 0;else if (this.a > 1) this.a = 1;\n                return this;\n            };\n            return Color;\n        }();\n        Color.WHITE = new Color(1, 1, 1, 1);\n        Color.RED = new Color(1, 0, 0, 1);\n        Color.GREEN = new Color(0, 1, 0, 1);\n        Color.BLUE = new Color(0, 0, 1, 1);\n        Color.MAGENTA = new Color(1, 0, 1, 1);\n        core.Color = Color;\n        var MathUtils = function () {\n            function MathUtils() {}\n            MathUtils.clamp = function (value, min, max) {\n                if (value < min) return min;\n                if (value > max) return max;\n                return value;\n            };\n            MathUtils.cosDeg = function (degrees) {\n                return Math.cos(degrees * MathUtils.degRad);\n            };\n            MathUtils.sinDeg = function (degrees) {\n                return Math.sin(degrees * MathUtils.degRad);\n            };\n            MathUtils.signum = function (value) {\n                return value > 0 ? 1 : value < 0 ? -1 : 0;\n            };\n            MathUtils.toInt = function (x) {\n                return x > 0 ? Math.floor(x) : Math.ceil(x);\n            };\n            MathUtils.cbrt = function (x) {\n                var y = Math.pow(Math.abs(x), 1 / 3);\n                return x < 0 ? -y : y;\n            };\n            MathUtils.randomTriangular = function (min, max) {\n                return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n            };\n            MathUtils.randomTriangularWith = function (min, max, mode) {\n                var u = Math.random();\n                var d = max - min;\n                if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n                return max - Math.sqrt((1 - u) * d * (max - mode));\n            };\n            return MathUtils;\n        }();\n        MathUtils.PI = 3.1415927;\n        MathUtils.PI2 = MathUtils.PI * 2;\n        MathUtils.radiansToDegrees = 180 / MathUtils.PI;\n        MathUtils.radDeg = MathUtils.radiansToDegrees;\n        MathUtils.degreesToRadians = MathUtils.PI / 180;\n        MathUtils.degRad = MathUtils.degreesToRadians;\n        core.MathUtils = MathUtils;\n        var Interpolation = function () {\n            function Interpolation() {}\n            Interpolation.prototype.apply = function (start, end, a) {\n                return start + (end - start) * this.applyInternal(a);\n            };\n            return Interpolation;\n        }();\n        core.Interpolation = Interpolation;\n        var Pow = function (_super) {\n            __extends(Pow, _super);\n            function Pow(power) {\n                var _this = _super.call(this) || this;\n                _this.power = 2;\n                _this.power = power;\n                return _this;\n            }\n            Pow.prototype.applyInternal = function (a) {\n                if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n                return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n            };\n            return Pow;\n        }(Interpolation);\n        core.Pow = Pow;\n        var PowOut = function (_super) {\n            __extends(PowOut, _super);\n            function PowOut(power) {\n                return _super.call(this, power) || this;\n            }\n            PowOut.prototype.applyInternal = function (a) {\n                return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n            };\n            return PowOut;\n        }(Pow);\n        core.PowOut = PowOut;\n        var Utils = function () {\n            function Utils() {}\n            Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\n                for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n                    dest[j] = source[i];\n                }\n            };\n            Utils.setArraySize = function (array, size, value) {\n                if (value === void 0) {\n                    value = 0;\n                }\n                var oldSize = array.length;\n                if (oldSize == size) return array;\n                array.length = size;\n                if (oldSize < size) {\n                    for (var i = oldSize; i < size; i++) {\n                        array[i] = value;\n                    }\n                }\n                return array;\n            };\n            Utils.ensureArrayCapacity = function (array, size, value) {\n                if (value === void 0) {\n                    value = 0;\n                }\n                if (array.length >= size) return array;\n                return Utils.setArraySize(array, size, value);\n            };\n            Utils.newArray = function (size, defaultValue) {\n                var array = new Array(size);\n                for (var i = 0; i < size; i++) {\n                    array[i] = defaultValue;\n                }return array;\n            };\n            Utils.newFloatArray = function (size) {\n                if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                    return new Float32Array(size);\n                } else {\n                    var array = new Array(size);\n                    for (var i = 0; i < array.length; i++) {\n                        array[i] = 0;\n                    }return array;\n                }\n            };\n            Utils.newShortArray = function (size) {\n                if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                    return new Int16Array(size);\n                } else {\n                    var array = new Array(size);\n                    for (var i = 0; i < array.length; i++) {\n                        array[i] = 0;\n                    }return array;\n                }\n            };\n            Utils.toFloatArray = function (array) {\n                return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n            };\n            Utils.toSinglePrecision = function (value) {\n                return Utils.SUPPORTS_TYPED_ARRAYS ? (0, _fround2.default)(value) : value;\n            };\n            return Utils;\n        }();\n        Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== \"undefined\";\n        core.Utils = Utils;\n        var DebugUtils = function () {\n            function DebugUtils() {}\n            DebugUtils.logBones = function (skeleton) {\n                for (var i = 0; i < skeleton.bones.length; i++) {\n                    var bone = skeleton.bones[i];\n                    var mat = bone.matrix;\n                    console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\n                }\n            };\n            return DebugUtils;\n        }();\n        core.DebugUtils = DebugUtils;\n        var Pool = function () {\n            function Pool(instantiator) {\n                this.items = new Array();\n                this.instantiator = instantiator;\n            }\n            Pool.prototype.obtain = function () {\n                return this.items.length > 0 ? this.items.pop() : this.instantiator();\n            };\n            Pool.prototype.free = function (item) {\n                if (item.reset) item.reset();\n                this.items.push(item);\n            };\n            Pool.prototype.freeAll = function (items) {\n                for (var i = 0; i < items.length; i++) {\n                    if (items[i].reset) items[i].reset();\n                    this.items[i] = items[i];\n                }\n            };\n            Pool.prototype.clear = function () {\n                this.items.length = 0;\n            };\n            return Pool;\n        }();\n        core.Pool = Pool;\n        var Vector2 = function () {\n            function Vector2(x, y) {\n                if (x === void 0) {\n                    x = 0;\n                }\n                if (y === void 0) {\n                    y = 0;\n                }\n                this.x = x;\n                this.y = y;\n            }\n            Vector2.prototype.set = function (x, y) {\n                this.x = x;\n                this.y = y;\n                return this;\n            };\n            Vector2.prototype.length = function () {\n                var x = this.x;\n                var y = this.y;\n                return Math.sqrt(x * x + y * y);\n            };\n            Vector2.prototype.normalize = function () {\n                var len = this.length();\n                if (len != 0) {\n                    this.x /= len;\n                    this.y /= len;\n                }\n                return this;\n            };\n            return Vector2;\n        }();\n        core.Vector2 = Vector2;\n        var TimeKeeper = function () {\n            function TimeKeeper() {\n                this.maxDelta = 0.064;\n                this.framesPerSecond = 0;\n                this.delta = 0;\n                this.totalTime = 0;\n                this.lastTime = Date.now() / 1000;\n                this.frameCount = 0;\n                this.frameTime = 0;\n            }\n            TimeKeeper.prototype.update = function () {\n                var now = Date.now() / 1000;\n                this.delta = now - this.lastTime;\n                this.frameTime += this.delta;\n                this.totalTime += this.delta;\n                if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n                this.lastTime = now;\n                this.frameCount++;\n                if (this.frameTime > 1) {\n                    this.framesPerSecond = this.frameCount / this.frameTime;\n                    this.frameTime = 0;\n                    this.frameCount = 0;\n                }\n            };\n            return TimeKeeper;\n        }();\n        core.TimeKeeper = TimeKeeper;\n        var WindowedMean = function () {\n            function WindowedMean(windowSize) {\n                if (windowSize === void 0) {\n                    windowSize = 32;\n                }\n                this.addedValues = 0;\n                this.lastValue = 0;\n                this.mean = 0;\n                this.dirty = true;\n                this.values = new Array(windowSize);\n            }\n            WindowedMean.prototype.hasEnoughData = function () {\n                return this.addedValues >= this.values.length;\n            };\n            WindowedMean.prototype.addValue = function (value) {\n                if (this.addedValues < this.values.length) this.addedValues++;\n                this.values[this.lastValue++] = value;\n                if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n                this.dirty = true;\n            };\n            WindowedMean.prototype.getMean = function () {\n                if (this.hasEnoughData()) {\n                    if (this.dirty) {\n                        var mean = 0;\n                        for (var i = 0; i < this.values.length; i++) {\n                            mean += this.values[i];\n                        }\n                        this.mean = mean / this.values.length;\n                        this.dirty = false;\n                    }\n                    return this.mean;\n                } else {\n                    return 0;\n                }\n            };\n            return WindowedMean;\n        }();\n        core.WindowedMean = WindowedMean;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var JitterEffect = function () {\n            function JitterEffect(jitterX, jitterY) {\n                this.jitterX = 0;\n                this.jitterY = 0;\n                this.jitterX = jitterX;\n                this.jitterY = jitterY;\n            }\n            JitterEffect.prototype.begin = function (skeleton) {};\n            JitterEffect.prototype.transform = function (position, uv, light, dark) {\n                position.x += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n                position.y += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n            };\n            JitterEffect.prototype.end = function () {};\n            return JitterEffect;\n        }();\n        core.JitterEffect = JitterEffect;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    var core;\n    (function (core) {\n        var SwirlEffect = function () {\n            function SwirlEffect(radius) {\n                this.centerX = 0;\n                this.centerY = 0;\n                this.radius = 0;\n                this.angle = 0;\n                this.worldX = 0;\n                this.worldY = 0;\n                this.radius = radius;\n            }\n            SwirlEffect.prototype.begin = function (skeleton) {\n                this.worldX = skeleton.x + this.centerX;\n                this.worldY = skeleton.y + this.centerY;\n            };\n            SwirlEffect.prototype.transform = function (position, uv, light, dark) {\n                var radAngle = this.angle * core.MathUtils.degreesToRadians;\n                var x = position.x - this.worldX;\n                var y = position.y - this.worldY;\n                var dist = Math.sqrt(x * x + y * y);\n                if (dist < this.radius) {\n                    var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n                    var cos = Math.cos(theta);\n                    var sin = Math.sin(theta);\n                    position.x = cos * x - sin * y + this.worldX;\n                    position.y = sin * x + cos * y + this.worldY;\n                }\n            };\n            SwirlEffect.prototype.end = function () {};\n            return SwirlEffect;\n        }();\n        SwirlEffect.interpolation = new core.PowOut(2);\n        core.SwirlEffect = SwirlEffect;\n    })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n(function (pixi_spine) {\n    function isJson(resource) {\n        var TYPE = PIXI.loaders.Resource.TYPE;\n        if (TYPE) {\n            return resource.type === TYPE.JSON;\n        }\n        return resource.isJson;\n    }\n    function atlasParser() {\n        return function (resource, next) {\n            if (!resource.data || !isJson(resource) || !resource.data.bones) {\n                return next();\n            }\n            var metadata = resource.metadata || {};\n            var metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;\n            var metadataAtlas = metadata ? resource.metadata.spineAtlas : null;\n            if (metadataAtlas === false) {\n                return next();\n            }\n            if (metadataAtlas && metadataAtlas.pages) {\n                var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(metadataAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n                resource.spineData = skeletonData;\n                resource.spineAtlas = metadataAtlas;\n                return next();\n            }\n            var metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\n            var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\n            atlasPath = atlasPath.replace(this.baseUrl, '');\n            var atlasOptions = {\n                crossOrigin: resource.crossOrigin,\n                xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n                metadata: metadata.spineMetadata || null,\n                parentResource: resource\n            };\n            var imageOptions = {\n                crossOrigin: resource.crossOrigin,\n                metadata: metadata.imageMetadata || null,\n                parentResource: resource\n            };\n            var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n            baseUrl = baseUrl.replace(this.baseUrl, '');\n            var adapter = metadata.images ? staticImageLoader(metadata.images) : metadata.image ? staticImageLoader({ 'default': metadata.image }) : metadata.imageLoader ? metadata.imageLoader(this, resource.name + '_atlas_page_', baseUrl, imageOptions) : imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n            this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {\n                new pixi_spine.core.TextureAtlas(atlasResource.xhr.responseText, adapter, function (spineAtlas) {\n                    var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(spineAtlas));\n                    if (metadataSkeletonScale) {\n                        spineJsonParser.scale = metadataSkeletonScale;\n                    }\n                    resource.spineData = spineJsonParser.readSkeletonData(resource.data);\n                    resource.spineAtlas = spineAtlas;\n                    next();\n                });\n            });\n        };\n    }\n    pixi_spine.atlasParser = atlasParser;\n    function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {\n        if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n            baseUrl += '/';\n        }\n        return function (line, callback) {\n            var name = namePrefix + line;\n            var url = baseUrl + line;\n            loader.add(name, url, imageOptions, function (resource) {\n                callback(resource.texture.baseTexture);\n            });\n        };\n    }\n    pixi_spine.imageLoaderAdapter = imageLoaderAdapter;\n    function syncImageLoaderAdapter(baseUrl, crossOrigin) {\n        if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n            baseUrl += '/';\n        }\n        return function (line, callback) {\n            callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n        };\n    }\n    pixi_spine.syncImageLoaderAdapter = syncImageLoaderAdapter;\n    function staticImageLoader(pages) {\n        return function (line, callback) {\n            var page = pages[line] || pages['default'];\n            if (page && page.baseTexture) callback(page.baseTexture);else callback(page);\n        };\n    }\n    pixi_spine.staticImageLoader = staticImageLoader;\n    PIXI.loaders.Loader.addPixiMiddleware(atlasParser);\n    PIXI.loader.use(atlasParser());\n})(pixi_spine || (pixi_spine = {}));\n(function () {\n    if (!_fround2.default) {\n        Math.fround = Math.fround = function (array) {\n            return function (x) {\n                return array[0] = x, array[0];\n            };\n        }(new Float32Array(1));\n    }\n})();\n(function (pixi_spine) {\n    pixi_spine.core.Bone.yDown = true;\n    var tempRgb = [0, 0, 0];\n    var SpineSprite = function (_super) {\n        __extends(SpineSprite, _super);\n        function SpineSprite(tex) {\n            return _super.call(this, tex) || this;\n        }\n        return SpineSprite;\n    }(PIXI.Sprite);\n    pixi_spine.SpineSprite = SpineSprite;\n    var SpineMesh = function (_super) {\n        __extends(SpineMesh, _super);\n        function SpineMesh(texture, vertices, uvs, indices, drawMode) {\n            return _super.call(this, texture, vertices, uvs, indices, drawMode) || this;\n        }\n        return SpineMesh;\n    }(PIXI.mesh.Mesh);\n    pixi_spine.SpineMesh = SpineMesh;\n    var Spine = function (_super) {\n        __extends(Spine, _super);\n        function Spine(spineData) {\n            var _this = _super.call(this) || this;\n            _this.hackTextureBySlotName = function (slotName, texture, size) {\n                if (texture === void 0) {\n                    texture = null;\n                }\n                if (size === void 0) {\n                    size = null;\n                }\n                var index = this.skeleton.findSlotIndex(slotName);\n                if (index == -1) {\n                    return false;\n                }\n                return this.hackTextureBySlotIndex(index, texture, size);\n            };\n            if (!spineData) {\n                throw new Error('The spineData param is required.');\n            }\n            if (typeof spineData === \"string\") {\n                throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n            }\n            _this.spineData = spineData;\n            _this.skeleton = new pixi_spine.core.Skeleton(spineData);\n            _this.skeleton.updateWorldTransform();\n            _this.stateData = new pixi_spine.core.AnimationStateData(spineData);\n            _this.state = new pixi_spine.core.AnimationState(_this.stateData);\n            _this.slotContainers = [];\n            _this.tempClipContainers = [];\n            for (var i = 0, n = _this.skeleton.slots.length; i < n; i++) {\n                var slot = _this.skeleton.slots[i];\n                var attachment = slot.attachment;\n                var slotContainer = new PIXI.Container();\n                _this.slotContainers.push(slotContainer);\n                _this.addChild(slotContainer);\n                _this.tempClipContainers.push(null);\n                if (attachment instanceof pixi_spine.core.RegionAttachment) {\n                    var spriteName = attachment.region.name;\n                    var sprite = _this.createSprite(slot, attachment, spriteName);\n                    slot.currentSprite = sprite;\n                    slot.currentSpriteName = spriteName;\n                    slotContainer.addChild(sprite);\n                } else if (attachment instanceof pixi_spine.core.MeshAttachment) {\n                    var mesh = _this.createMesh(slot, attachment);\n                    slot.currentMesh = mesh;\n                    slot.currentMeshName = attachment.name;\n                    slotContainer.addChild(mesh);\n                } else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\n                    _this.createGraphics(slot, attachment);\n                    slotContainer.addChild(slot.clippingContainer);\n                    slotContainer.addChild(slot.currentGraphics);\n                } else {\n                    continue;\n                }\n            }\n            _this.autoUpdate = true;\n            _this.tintRgb = new Float32Array([1, 1, 1]);\n            return _this;\n        }\n        Object.defineProperty(Spine.prototype, \"autoUpdate\", {\n            get: function get() {\n                return this.updateTransform === Spine.prototype.autoUpdateTransform;\n            },\n            set: function set(value) {\n                this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(Spine.prototype, \"tint\", {\n            get: function get() {\n                return PIXI.utils.rgb2hex(this.tintRgb);\n            },\n            set: function set(value) {\n                this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Spine.prototype.update = function (dt) {\n            this.state.update(dt);\n            this.state.apply(this.skeleton);\n            this.skeleton.updateWorldTransform();\n            var slots = this.skeleton.slots;\n            var r0 = this.tintRgb[0];\n            var g0 = this.tintRgb[1];\n            var b0 = this.tintRgb[2];\n            for (var i = 0, n = slots.length; i < n; i++) {\n                var slot = slots[i];\n                var attachment = slot.attachment;\n                var slotContainer = this.slotContainers[i];\n                if (!attachment) {\n                    slotContainer.visible = false;\n                    continue;\n                }\n                var attColor = attachment.color;\n                if (attachment instanceof pixi_spine.core.RegionAttachment) {\n                    var region = attachment.region;\n                    if (region) {\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                            slot.currentMesh = null;\n                            slot.currentMeshName = undefined;\n                        }\n                        var ar = region;\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n                            var spriteName = ar.name;\n                            if (slot.currentSprite) {\n                                slot.currentSprite.visible = false;\n                            }\n                            slot.sprites = slot.sprites || {};\n                            if (slot.sprites[spriteName] !== undefined) {\n                                slot.sprites[spriteName].visible = true;\n                            } else {\n                                var sprite = this.createSprite(slot, attachment, spriteName);\n                                slotContainer.addChild(sprite);\n                            }\n                            slot.currentSprite = slot.sprites[spriteName];\n                            slot.currentSpriteName = spriteName;\n                        }\n                    }\n                    if (slotContainer.transform) {\n                        var transform = slotContainer.transform;\n                        var transAny = transform;\n                        var lt = null;\n                        if (transAny.matrix2d) {\n                            lt = transAny.matrix2d;\n                            transAny._dirtyVersion++;\n                            transAny.version = transAny._dirtyVersion;\n                            transAny.isStatic = true;\n                            transAny.operMode = 0;\n                        } else {\n                            if (PIXI.TransformBase) {\n                                if (transAny.position) {\n                                    transform = new PIXI.TransformBase();\n                                    slotContainer.transform = transform;\n                                }\n                                lt = transform.localTransform;\n                            } else {\n                                transAny.setFromMatrix(slot.bone.matrix);\n                            }\n                        }\n                        if (lt) {\n                            slot.bone.matrix.copy(lt);\n                        }\n                    } else {\n                        var lt = slotContainer.localTransform || new PIXI.Matrix();\n                        slot.bone.matrix.copy(lt);\n                        slotContainer.localTransform = lt;\n                        slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n                    }\n                    tempRgb[0] = r0 * slot.color.r * attColor.r;\n                    tempRgb[1] = g0 * slot.color.g * attColor.g;\n                    tempRgb[2] = b0 * slot.color.b * attColor.b;\n                    slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n                    slot.currentSprite.blendMode = slot.blendMode;\n                } else if (attachment instanceof pixi_spine.core.MeshAttachment) {\n                    if (slot.currentSprite) {\n                        slot.currentSprite.visible = false;\n                        slot.currentSprite = null;\n                        slot.currentSpriteName = undefined;\n                        if (slotContainer.transform) {\n                            slotContainer.transform = new PIXI.TransformStatic();\n                        } else {\n                            slotContainer.localTransform = new PIXI.Matrix();\n                            slotContainer.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;\n                        }\n                    }\n                    if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                        var meshName = attachment.name;\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                        }\n                        slot.meshes = slot.meshes || {};\n                        if (slot.meshes[meshName] !== undefined) {\n                            slot.meshes[meshName].visible = true;\n                        } else {\n                            var mesh = this.createMesh(slot, attachment);\n                            slotContainer.addChild(mesh);\n                        }\n                        slot.currentMesh = slot.meshes[meshName];\n                        slot.currentMeshName = meshName;\n                    }\n                    attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n                    if (PIXI.VERSION[0] !== '3') {\n                        var tintRgb = slot.currentMesh.tintRgb;\n                        tintRgb[0] = r0 * slot.color.r * attColor.r;\n                        tintRgb[1] = g0 * slot.color.g * attColor.g;\n                        tintRgb[2] = b0 * slot.color.b * attColor.b;\n                    }\n                    slot.currentMesh.blendMode = slot.blendMode;\n                } else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\n                    if (!slot.currentGraphics) {\n                        this.createGraphics(slot, attachment);\n                        slotContainer.addChild(slot.clippingContainer);\n                        slotContainer.addChild(slot.currentGraphics);\n                    }\n                    this.updateGraphics(slot, attachment);\n                } else {\n                    slotContainer.visible = false;\n                    continue;\n                }\n                slotContainer.visible = true;\n                slotContainer.alpha = slot.color.a;\n            }\n            var drawOrder = this.skeleton.drawOrder;\n            var clippingAttachment = null;\n            var clippingContainer = null;\n            for (var i = 0, n = drawOrder.length; i < n; i++) {\n                var slot = slots[drawOrder[i].data.index];\n                var slotContainer = this.slotContainers[drawOrder[i].data.index];\n                if (!clippingContainer) {\n                    if (slotContainer.parent !== this) {\n                        slotContainer.parent.removeChild(slotContainer);\n                        slotContainer.parent = this;\n                    }\n                }\n                if (slot.currentGraphics) {\n                    clippingContainer = slot.clippingContainer;\n                    clippingAttachment = slot.attachment;\n                    clippingContainer.children.length = 0;\n                    this.children[i] = slotContainer;\n                    if (clippingAttachment.endSlot == slot.data) {\n                        clippingContainer.renderable = false;\n                        clippingContainer = null;\n                        clippingAttachment = null;\n                    }\n                } else {\n                    if (clippingContainer) {\n                        var c = this.tempClipContainers[i];\n                        if (!c) {\n                            c = this.tempClipContainers[i] = new PIXI.Container();\n                            c.visible = false;\n                        }\n                        this.children[i] = c;\n                        slotContainer.parent = null;\n                        clippingContainer.addChild(slotContainer);\n                        if (clippingAttachment.endSlot == slot.data) {\n                            clippingContainer.renderable = true;\n                            clippingContainer = null;\n                            clippingAttachment = null;\n                        }\n                    } else {\n                        this.children[i] = slotContainer;\n                    }\n                }\n            }\n        };\n        ;\n        Spine.prototype.setSpriteRegion = function (attachment, sprite, region) {\n            sprite.region = region;\n            sprite.texture = region.texture;\n            if (!region.size) {\n                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n                sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n            } else {\n                sprite.scale.x = region.size.width / region.originalWidth;\n                sprite.scale.y = -region.size.height / region.originalHeight;\n            }\n        };\n        Spine.prototype.setMeshRegion = function (attachment, mesh, region) {\n            mesh.region = region;\n            mesh.texture = region.texture;\n            attachment.updateUVs(region, mesh.uvs);\n            mesh.dirty++;\n        };\n        Spine.prototype.autoUpdateTransform = function () {\n            if (Spine.globalAutoUpdate) {\n                this.lastTime = this.lastTime || Date.now();\n                var timeDelta = (Date.now() - this.lastTime) * 0.001;\n                this.lastTime = Date.now();\n                this.update(timeDelta);\n            } else {\n                this.lastTime = 0;\n            }\n            PIXI.Container.prototype.updateTransform.call(this);\n        };\n        ;\n        Spine.prototype.createSprite = function (slot, attachment, defName) {\n            var region = attachment.region;\n            if (slot.tempAttachment === attachment) {\n                region = slot.tempRegion;\n                slot.tempAttachment = null;\n                slot.tempRegion = null;\n            }\n            var texture = region.texture;\n            var sprite = new SpineSprite(texture);\n            sprite.rotation = attachment.rotation * pixi_spine.core.MathUtils.degRad;\n            sprite.anchor.x = 0.5;\n            sprite.anchor.y = 0.5;\n            sprite.position.x = attachment.x;\n            sprite.position.y = attachment.y;\n            sprite.alpha = attachment.color.a;\n            sprite.region = attachment.region;\n            this.setSpriteRegion(attachment, sprite, attachment.region);\n            slot.sprites = slot.sprites || {};\n            slot.sprites[defName] = sprite;\n            return sprite;\n        };\n        ;\n        Spine.prototype.createMesh = function (slot, attachment) {\n            var region = attachment.region;\n            if (slot.tempAttachment === attachment) {\n                region = slot.tempRegion;\n                slot.tempAttachment = null;\n                slot.tempRegion = null;\n            }\n            var strip = new SpineMesh(region.texture, new Float32Array(attachment.regionUVs.length), new Float32Array(attachment.regionUVs.length), new Uint16Array(attachment.triangles), PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n            strip.canvasPadding = 1.5;\n            strip.alpha = attachment.color.a;\n            strip.region = attachment.region;\n            this.setMeshRegion(attachment, strip, region);\n            slot.meshes = slot.meshes || {};\n            slot.meshes[attachment.name] = strip;\n            return strip;\n        };\n        ;\n        Spine.prototype.createGraphics = function (slot, clip) {\n            var graphics = new PIXI.Graphics();\n            var poly = new PIXI.Polygon([]);\n            graphics.clear();\n            graphics.beginFill(0xffffff, 1);\n            graphics.drawPolygon(poly);\n            graphics.renderable = false;\n            slot.currentGraphics = graphics;\n            slot.clippingContainer = new PIXI.Container();\n            slot.clippingContainer.mask = slot.currentGraphics;\n            return graphics;\n        };\n        Spine.prototype.updateGraphics = function (slot, clip) {\n            var vertices = slot.currentGraphics.graphicsData[0].shape.points;\n            var n = clip.worldVerticesLength;\n            vertices.length = n;\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n            slot.currentGraphics.dirty++;\n            slot.currentGraphics.clearDirty++;\n        };\n        Spine.prototype.hackTextureBySlotIndex = function (slotIndex, texture, size) {\n            if (texture === void 0) {\n                texture = null;\n            }\n            if (size === void 0) {\n                size = null;\n            }\n            var slot = this.skeleton.slots[slotIndex];\n            if (!slot) {\n                return false;\n            }\n            var attachment = slot.attachment;\n            var region = attachment.region;\n            if (texture) {\n                region = new pixi_spine.core.TextureRegion();\n                region.texture = texture;\n                region.size = size;\n            }\n            if (slot.currentSprite && slot.currentSprite.region != region) {\n                this.setSpriteRegion(attachment, slot.currentSprite, region);\n                slot.currentSprite.region = region;\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\n                this.setMeshRegion(attachment, slot.currentMesh, region);\n            } else {\n                slot.tempRegion = region;\n                slot.tempAttachment = attachment;\n            }\n            return true;\n        };\n        return Spine;\n    }(PIXI.Container);\n    Spine.globalAutoUpdate = true;\n    Spine.clippingPolygon = [];\n    pixi_spine.Spine = Spine;\n    function SlotContainerUpdateTransformV3() {\n        var pt = this.parent.worldTransform;\n        var wt = this.worldTransform;\n        var lt = this.localTransform;\n        wt.a = lt.a * pt.a + lt.b * pt.c;\n        wt.b = lt.a * pt.b + lt.b * pt.d;\n        wt.c = lt.c * pt.a + lt.d * pt.c;\n        wt.d = lt.c * pt.b + lt.d * pt.d;\n        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n        this._currentBounds = null;\n    }\n})(pixi_spine || (pixi_spine = {}));\nPIXI.spine = pixi_spine;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(75), __esModule: true };\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(76);\nmodule.exports = __webpack_require__(2).Math.fround;\n\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 20.2.2.16 Math.fround(x)\nvar $export = __webpack_require__(8);\n\n$export($export.S, 'Math', { fround: __webpack_require__(77) });\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 20.2.2.16 Math.fround(x)\nvar sign = __webpack_require__(78);\nvar pow = Math.pow;\nvar EPSILON = pow(2, -52);\nvar EPSILON32 = pow(2, -23);\nvar MAX32 = pow(2, 127) * (2 - EPSILON32);\nvar MIN32 = pow(2, -126);\n\nvar roundTiesToEven = function (n) {\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\nmodule.exports = Math.fround || function fround(x) {\n  var $abs = Math.abs(x);\n  var $sign = sign(x);\n  var a, result;\n  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n  a = (1 + EPSILON32 / EPSILON) * $abs;\n  result = a - (a - $abs);\n  // eslint-disable-next-line no-self-compare\n  if (result > MAX32 || result != result) return $sign * Infinity;\n  return $sign * result;\n};\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports) {\n\n// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(80), __esModule: true };\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(81);\nvar $Object = __webpack_require__(2).Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $export = __webpack_require__(8);\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: __webpack_require__(35) });\n\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(83), __esModule: true };\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(84);\nmodule.exports = __webpack_require__(2).Object.setPrototypeOf;\n\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = __webpack_require__(8);\n$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(85).set });\n\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __webpack_require__(6);\nvar anObject = __webpack_require__(5);\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = __webpack_require__(15)(Function.call, __webpack_require__(86).f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar pIE = __webpack_require__(39);\nvar createDesc = __webpack_require__(20);\nvar toIObject = __webpack_require__(7);\nvar toPrimitive = __webpack_require__(26);\nvar has = __webpack_require__(9);\nvar IE8_DOM_DEFINE = __webpack_require__(25);\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(3) ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _loader = __webpack_require__(53);\n\nvar _loader2 = _interopRequireDefault(_loader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar newSpine = function newSpine(spineName) {\n    var data = _loader2.default.loadSkeleton(spineName);\n    var spine = new PIXI.spine.Spine(data);\n    var setup = ysp.Spine.SETUP[spineName];\n\n    spine.update = function (dt) {\n        // hax: Container shouldn't call this without dt\n        if (dt) {\n            PIXI.spine.Spine.prototype.update.call(this, dt);\n        }\n    };\n\n    if (setup.initAnimation.autoplay) {\n        spine.state.setAnimation(0, setup.initAnimation.name, setup.initAnimation.loop);\n    }\n    spine.skeleton.setSkinByName(setup.skin);\n\n    return spine;\n};\n\nvar playAnimation = function playAnimation(spine, animationName, loop) {\n    spine.state.setAnimation(0, animationName, loop);\n};\n\nvar setSkinByName = function setSkinByName(spine, skinName) {\n    spine.skeleton.setSkinByName(skinName);\n};\n\nexports.default = {\n    newSpine: newSpine,\n    playAnimation: playAnimation,\n    setSkinByName: setSkinByName\n};\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = { \"default\": __webpack_require__(89), __esModule: true };\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(90);\n__webpack_require__(49);\n__webpack_require__(41);\n__webpack_require__(91);\n__webpack_require__(101);\n__webpack_require__(102);\nmodule.exports = __webpack_require__(2).Promise;\n\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar LIBRARY = __webpack_require__(34);\nvar global = __webpack_require__(0);\nvar ctx = __webpack_require__(15);\nvar classof = __webpack_require__(38);\nvar $export = __webpack_require__(8);\nvar isObject = __webpack_require__(6);\nvar aFunction = __webpack_require__(18);\nvar anInstance = __webpack_require__(92);\nvar forOf = __webpack_require__(93);\nvar speciesConstructor = __webpack_require__(55);\nvar task = __webpack_require__(56).set;\nvar microtask = __webpack_require__(97)();\nvar newPromiseCapabilityModule = __webpack_require__(54);\nvar perform = __webpack_require__(57);\nvar promiseResolve = __webpack_require__(58);\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[__webpack_require__(1)('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = LIBRARY ? function (a, b) {\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n} : function (a, b) {\n  return a === b;\n};\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value);\n            if (domain) domain.exit();\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  if (promise._h == 1) return false;\n  var chain = promise._a || promise._c;\n  var i = 0;\n  var reaction;\n  while (chain.length > i) {\n    reaction = chain[i++];\n    if (reaction.fail || !isUnhandled(reaction.promise)) return false;\n  } return true;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = __webpack_require__(98)($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return sameConstructor($Promise, C)\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\n__webpack_require__(29)($Promise, PROMISE);\n__webpack_require__(99)(PROMISE);\nWrapper = __webpack_require__(2)[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;\n    return promiseResolve(this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(100)(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ctx = __webpack_require__(15);\nvar call = __webpack_require__(94);\nvar isArrayIter = __webpack_require__(95);\nvar anObject = __webpack_require__(5);\nvar toLength = __webpack_require__(28);\nvar getIterFn = __webpack_require__(51);\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// call something on iterator step with safe closing on error\nvar anObject = __webpack_require__(5);\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// check on default Array iterator\nvar Iterators = __webpack_require__(10);\nvar ITERATOR = __webpack_require__(1)('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports) {\n\n// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(0);\nvar macrotask = __webpack_require__(56).set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = __webpack_require__(13)(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if (Observer) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    var promise = Promise.resolve();\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hide = __webpack_require__(4);\nmodule.exports = function (target, src, safe) {\n  for (var key in src) {\n    if (safe && target[key]) target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar global = __webpack_require__(0);\nvar core = __webpack_require__(2);\nvar dP = __webpack_require__(11);\nvar DESCRIPTORS = __webpack_require__(3);\nvar SPECIES = __webpack_require__(1)('species');\n\nmodule.exports = function (KEY) {\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ITERATOR = __webpack_require__(1)('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// https://github.com/tc39/proposal-promise-finally\n\nvar $export = __webpack_require__(8);\nvar core = __webpack_require__(2);\nvar global = __webpack_require__(0);\nvar speciesConstructor = __webpack_require__(55);\nvar promiseResolve = __webpack_require__(58);\n\n$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = speciesConstructor(this, core.Promise || global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// https://github.com/tc39/proposal-promise-try\nvar $export = __webpack_require__(8);\nvar newPromiseCapability = __webpack_require__(54);\nvar perform = __webpack_require__(57);\n\n$export($export.S, 'Promise', { 'try': function (callbackfn) {\n  var promiseCapability = newPromiseCapability.f(this);\n  var result = perform(callbackfn);\n  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n  return promiseCapability.promise;\n} });\n\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _loader = __webpack_require__(53);\n\nvar _loader2 = _interopRequireDefault(_loader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (Scene_Base) {\n    var _isReady = Scene_Base.prototype.isReady;\n    Scene_Base.prototype.isReady = function () {\n        return _isReady.call(this) && _loader2.default.isLoaded();\n    };\n};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// YSP_Spine.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 67);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6d3fbb4e27190c57ee98","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_global.js\n// module id = 0\n// module chunks = 0 1 2","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_wks.js\n// module id = 1\n// module chunks = 0 1","var core = module.exports = { version: '2.5.0' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_core.js\n// module id = 2\n// module chunks = 0 1 2","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_descriptors.js\n// module id = 3\n// module chunks = 0 1 2","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_hide.js\n// module id = 4\n// module chunks = 0 1 2","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_an-object.js\n// module id = 5\n// module chunks = 0 1 2","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_is-object.js\n// module id = 6\n// module chunks = 0 1 2","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-iobject.js\n// module id = 7\n// module chunks = 0 1 2","var global = require('./_global');\nvar core = require('./_core');\nvar ctx = require('./_ctx');\nvar hide = require('./_hide');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && key in exports) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_export.js\n// module id = 8\n// module chunks = 0 1 2","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_has.js\n// module id = 9\n// module chunks = 0 1 2","module.exports = {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iterators.js\n// module id = 10\n// module chunks = 0 1","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-dp.js\n// module id = 11\n// module chunks = 0 1 2","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-integer.js\n// module id = 12\n// module chunks = 0 1 2","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_cof.js\n// module id = 13\n// module chunks = 0 1 2","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_defined.js\n// module id = 14\n// module chunks = 0 1 2","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_ctx.js\n// module id = 15\n// module chunks = 0 1 2","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_fails.js\n// module id = 16\n// module chunks = 0 1 2","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_shared-key.js\n// module id = 17\n// module chunks = 0 1 2","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_a-function.js\n// module id = 18\n// module chunks = 0 1 2","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_dom-create.js\n// module id = 19\n// module chunks = 0 1 2","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_property-desc.js\n// module id = 20\n// module chunks = 0 1 2","var global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_shared.js\n// module id = 21\n// module chunks = 0 1 2","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_uid.js\n// module id = 22\n// module chunks = 0 1 2","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_enum-bug-keys.js\n// module id = 23\n// module chunks = 0 1 2","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iobject.js\n// module id = 24\n// module chunks = 0 1 2","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_ie8-dom-define.js\n// module id = 25\n// module chunks = 0 1 2","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-primitive.js\n// module id = 26\n// module chunks = 0 1 2","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-keys.js\n// module id = 27\n// module chunks = 0 1 2","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-length.js\n// module id = 28\n// module chunks = 0 1 2","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_set-to-string-tag.js\n// module id = 29\n// module chunks = 0 1","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-define.js\n// module id = 30\n// module chunks = 0 1","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-keys-internal.js\n// module id = 31\n// module chunks = 0 1 2","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_array-includes.js\n// module id = 32\n// module chunks = 0 1 2","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-absolute-index.js\n// module id = 33\n// module chunks = 0 1 2","module.exports = true;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_library.js\n// module id = 34\n// module chunks = 0 1","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-create.js\n// module id = 35\n// module chunks = 0 1","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_html.js\n// module id = 36\n// module chunks = 0 1","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_to-object.js\n// module id = 37\n// module chunks = 0 1","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_classof.js\n// module id = 38\n// module chunks = 0 1","exports.f = {}.propertyIsEnumerable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-pie.js\n// module id = 39\n// module chunks = 0 2","require('./es6.array.iterator');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar TO_STRING_TAG = require('./_wks')('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/web.dom.iterable.js\n// module id = 41\n// module chunks = 0 1","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.array.iterator.js\n// module id = 42\n// module chunks = 0 1","module.exports = function () { /* empty */ };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_add-to-unscopables.js\n// module id = 43\n// module chunks = 0 1","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-step.js\n// module id = 44\n// module chunks = 0 1","module.exports = require('./_hide');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_redefine.js\n// module id = 45\n// module chunks = 0 1","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-create.js\n// module id = 46\n// module chunks = 0 1","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-dps.js\n// module id = 47\n// module chunks = 0 1","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-gpo.js\n// module id = 48\n// module chunks = 0 1","'use strict';\nvar $at = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.string.iterator.js\n// module id = 49\n// module chunks = 0 1","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_string-at.js\n// module id = 50\n// module chunks = 0 1","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/core.get-iterator-method.js\n// module id = 51\n// module chunks = 0 1","let raws = {}\nlet spines = {}\nlet filesToLoad = 0\n\nconst _loadRaw = (path) => {\n    return new Promise((resolve, reject) => {\n        let xhr = new XMLHttpRequest()\n        xhr.open('GET', path)\n        xhr.onload = () => resolve(xhr.responseText)\n        xhr.onerror = () => resolve(xhr.statusText)\n        xhr.send()\n    })\n}\n\nconst _loadTexture = (path) => {\n    return new Promise((resolve, reject) => {\n        let texture = PIXI.BaseTexture.fromImage(path)\n        texture.on('loaded', (baseTexture) => resolve(baseTexture))\n        texture.on('error', (baseTexture) => reject(baseTexture))\n    })\n}\n\nconst loadAssets = (spineName) => {\n    let setup = ysp.Spine.SETUP[spineName]\n    if (raws[spineName]) {\n        return\n    }\n    raws[spineName] = {}\n    filesToLoad = filesToLoad + 3\n\n    _loadRaw(setup.json)\n        .then((res) => {\n            raws[spineName].json = JSON.parse(res)\n            filesToLoad = filesToLoad - 1\n        })\n        .catch((res) => {\n            console.log(res)\n        })\n\n    _loadRaw(setup.atlas)\n        .then((res) => {\n            raws[spineName].atlas = res\n            filesToLoad = filesToLoad - 1\n        })\n        .catch((res) => {\n            console.log(res)\n        })\n\n    _loadTexture(setup.texture)\n        .then((texture) => {\n            raws[spineName].texture = texture\n            filesToLoad = filesToLoad - 1\n        })\n        .catch((texture) => {\n            console.log(`Couldn't load: ${setup.texture}`)\n        })\n}\n\nconst loadSkeleton = (spineName) => {\n    let setup = ysp.Spine.SETUP[spineName]\n\n    if (spines[spineName]) {\n        return spines[spineName]\n    }\n\n    if (!raws[spineName]) {\n        console.log(`[Error] Spine '${spineName}' hasn't pre-loaded`)\n        return\n    }\n\n    let rawSkeletonData = raws[spineName].json\n    let rawAtlasData = raws[spineName].atlas\n\n    let spineAtlas = new PIXI.spine.core.TextureAtlas(rawAtlasData, function (line, callback) {\n        callback(raws[spineName].texture)\n    })\n\n    let spineAtlasLoader = new PIXI.spine.core.AtlasAttachmentLoader(spineAtlas)\n    let spineJsonParser = new PIXI.spine.core.SkeletonJson(spineAtlasLoader)\n\n    let spineData = spineJsonParser.readSkeletonData(rawSkeletonData)\n    spines[spineName] = spineData\n\n    return spines[spineName]\n}\n\nconst isLoaded = () => {\n    return filesToLoad === 0\n}\n\nexport default {\n    loadAssets,\n    loadSkeleton,\n    isLoaded,\n    raws,\n    spines,\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Spine/loader.js","'use strict';\n// 25.4.1.5 NewPromiseCapability(C)\nvar aFunction = require('./_a-function');\n\nfunction PromiseCapability(C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject = aFunction(reject);\n}\n\nmodule.exports.f = function (C) {\n  return new PromiseCapability(C);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_new-promise-capability.js\n// module id = 54\n// module chunks = 0","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar SPECIES = require('./_wks')('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_species-constructor.js\n// module id = 55\n// module chunks = 0","var ctx = require('./_ctx');\nvar invoke = require('./_invoke');\nvar html = require('./_html');\nvar cel = require('./_dom-create');\nvar global = require('./_global');\nvar process = global.process;\nvar setTask = global.setImmediate;\nvar clearTask = global.clearImmediate;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function () {\n  var id = +this;\n  // eslint-disable-next-line no-prototype-builtins\n  if (queue.hasOwnProperty(id)) {\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function (event) {\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!setTask || !clearTask) {\n  setTask = function setImmediate(fn) {\n    var args = [];\n    var i = 1;\n    while (arguments.length > i) args.push(arguments[i++]);\n    queue[++counter] = function () {\n      // eslint-disable-next-line no-new-func\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id) {\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if (require('./_cof')(process) == 'process') {\n    defer = function (id) {\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if (MessageChannel) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n    defer = function (id) {\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in cel('script')) {\n    defer = function (id) {\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set: setTask,\n  clear: clearTask\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_task.js\n// module id = 56\n// module chunks = 0","module.exports = function (exec) {\n  try {\n    return { e: false, v: exec() };\n  } catch (e) {\n    return { e: true, v: e };\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_perform.js\n// module id = 57\n// module chunks = 0","var newPromiseCapability = require('./_new-promise-capability');\n\nmodule.exports = function (C, x) {\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_promise-resolve.js\n// module id = 58\n// module chunks = 0","import './pixi-spine'\n\nimport spine from './spine'\nimport loader from './loader'\nimport sceneBase from './scene-base'\n\nwindow.ysp = window.ysp || {}\n\nsceneBase(Scene_Base)\n\nconst exports = {\n    spine,\n    loader,\n}\nwindow.ysp.Spine = Object.assign({}, window.ysp.Spine, exports)\n\n\n// WEBPACK FOOTER //\n// ./src/Spine/index.js","module.exports = { \"default\": require(\"core-js/library/fn/object/assign\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/object/assign.js\n// module id = 68\n// module chunks = 0","require('../../modules/es6.object.assign');\nmodule.exports = require('../../modules/_core').Object.assign;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/object/assign.js\n// module id = 69\n// module chunks = 0","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.object.assign.js\n// module id = 70\n// module chunks = 0","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nvar toObject = require('./_to-object');\nvar IObject = require('./_iobject');\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-assign.js\n// module id = 71\n// module chunks = 0","exports.f = Object.getOwnPropertySymbols;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-gops.js\n// module id = 72\n// module chunks = 0","/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Animation {\n        name: string;\n        timelines: Array<Timeline>;\n        duration: number;\n\n        constructor (name: string, timelines: Array<Timeline>, duration: number) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            if (timelines == null) throw new Error(\"timelines cannot be null.\");\n            this.name = name;\n            this.timelines = timelines;\n            this.duration = duration;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n            if (loop && this.duration != 0) {\n                time %= this.duration;\n                if (lastTime > 0) lastTime %= this.duration;\n            }\n\n            let timelines = this.timelines;\n            for (let i = 0, n = timelines.length; i < n; i++)\n                timelines[i].apply(skeleton, lastTime, time, events, alpha, pose, direction);\n        }\n\n        static binarySearch (values: ArrayLike<number>, target: number, step: number = 1) {\n            let low = 0;\n            let high = values.length / step - 2;\n            if (high == 0) return step;\n            let current = high >>> 1;\n            while (true) {\n                if (values[(current + 1) * step] <= target)\n                    low = current + 1;\n                else\n                    high = current;\n                if (low == high) return (low + 1) * step;\n                current = (low + high) >>> 1;\n            }\n        }\n\n        static linearSearch (values: ArrayLike<number>, target: number, step: number) {\n            for (let i = 0, last = values.length - step; i <= last; i += step)\n                if (values[i] > target) return i;\n            return -1;\n        }\n    }\n\n    export interface Timeline {\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection): void;\n        getPropertyId (): number;\n    }\n\n    export enum MixPose {\n        setup,\n        current,\n        currentLayered\n    }\n\n    export enum MixDirection {\n        in, out\n    }\n\n    export enum TimelineType {\n        rotate, translate, scale, shear,\n        attachment, color, deform,\n        event, drawOrder,\n        ikConstraint, transformConstraint,\n        pathConstraintPosition, pathConstraintSpacing, pathConstraintMix,\n        twoColor\n    }\n\n    export abstract class CurveTimeline implements Timeline {\n        static LINEAR = 0; static STEPPED = 1; static BEZIER = 2;\n        static BEZIER_SIZE = 10 * 2 - 1;\n\n        private curves: ArrayLike<number>; // type, x, y, ...\n\n        abstract getPropertyId(): number;\n\n        constructor (frameCount: number) {\n            if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n            this.curves = Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n        }\n\n        getFrameCount () {\n            return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n        }\n\n        setLinear (frameIndex: number) {\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n        }\n\n        setStepped (frameIndex: number) {\n            this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n        }\n\n        getCurveType (frameIndex: number): number {\n            let index = frameIndex * CurveTimeline.BEZIER_SIZE;\n            if (index == this.curves.length) return CurveTimeline.LINEAR;\n            let type = this.curves[index];\n            if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n            if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n            return CurveTimeline.BEZIER;\n        }\n\n        /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n         * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n         * the difference between the keyframe's values. */\n        setCurve (frameIndex: number, cx1: number, cy1: number, cx2: number, cy2: number) {\n            let tmpx = (-cx1 * 2 + cx2) * 0.03, tmpy = (-cy1 * 2 + cy2) * 0.03;\n            let dddfx = ((cx1 - cx2) * 3 + 1) * 0.006, dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n            let ddfx = tmpx * 2 + dddfx, ddfy = tmpy * 2 + dddfy;\n            let dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667, dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n\n            let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n            let curves = this.curves;\n            curves[i++] = CurveTimeline.BEZIER;\n\n            let x = dfx, y = dfy;\n            for (let n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                curves[i] = x;\n                curves[i + 1] = y;\n                dfx += ddfx;\n                dfy += ddfy;\n                ddfx += dddfx;\n                ddfy += dddfy;\n                x += dfx;\n                y += dfy;\n            }\n        }\n\n        getCurvePercent (frameIndex: number, percent: number) {\n            percent = MathUtils.clamp(percent, 0, 1);\n            let curves = this.curves;\n            let i = frameIndex * CurveTimeline.BEZIER_SIZE;\n            let type = curves[i];\n            if (type == CurveTimeline.LINEAR) return percent;\n            if (type == CurveTimeline.STEPPED) return 0;\n            i++;\n            let x = 0;\n            for (let start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n                x = curves[i];\n                if (x >= percent) {\n                    let prevX: number, prevY: number;\n                    if (i == start) {\n                        prevX = 0;\n                        prevY = 0;\n                    } else {\n                        prevX = curves[i - 2];\n                        prevY = curves[i - 1];\n                    }\n                    return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n                }\n            }\n            let y = curves[i - 1];\n            return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n        }\n\n        abstract apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection): void;\n    }\n\n    export class RotateTimeline extends CurveTimeline {\n        static ENTRIES = 2;\n        static PREV_TIME = -2; static PREV_ROTATION = -1;\n        static ROTATION = 1;\n\n        boneIndex: number;\n        frames: ArrayLike<number>; // time, degrees, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount << 1);\n        }\n\n        getPropertyId () {\n            return (TimelineType.rotate << 24) + this.boneIndex;\n        }\n\n        /** Sets the time and angle of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, degrees: number) {\n            frameIndex <<= 1;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        bone.rotation = bone.data.rotation;\n                        return;\n                    case MixPose.current:\n                        let r = bone.data.rotation - bone.rotation;\n                        r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                        bone.rotation += r * alpha;\n                }\n                return;\n            }\n\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) { // Time is after last frame.\n                if (pose == MixPose.setup)\n                    bone.rotation = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] * alpha;\n                else {\n                    let r = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION] - bone.rotation;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360; // Wrap within -180 and 180.\n                    bone.rotation += r * alpha;\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n            let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent((frame >> 1) - 1,\n                1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n            let r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n            r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n            r = prevRotation + r * percent;\n            if (pose == MixPose.setup) {\n                r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                bone.rotation = bone.data.rotation + r * alpha;\n            } else {\n                r = bone.data.rotation + r - bone.rotation;\n                r -= (16384 - ((16384.499999999996 - r / 360) |0)) * 360;\n                bone.rotation += r * alpha;\n            }\n        }\n    }\n\n    export class TranslateTimeline extends CurveTimeline {\n        static ENTRIES = 3;\n        static PREV_TIME = -3; static PREV_X = -2; static PREV_Y = -1;\n        static X = 1; static Y = 2;\n\n        boneIndex: number;\n        frames: ArrayLike<number>; // time, x, y, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.translate << 24) + this.boneIndex;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, x: number, y: number) {\n            frameIndex *= TranslateTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TranslateTimeline.X] = x;\n            this.frames[frameIndex + TranslateTimeline.Y] = y;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        bone.x = bone.data.x;\n                        bone.y = bone.data.y;\n                        return;\n                    case MixPose.current:\n                        bone.x += (bone.data.x - bone.x) * alpha;\n                        bone.y += (bone.data.y - bone.y) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + TranslateTimeline.PREV_X];\n                y = frames[frames.length + TranslateTimeline.PREV_Y];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n                x = frames[frame + TranslateTimeline.PREV_X];\n                y = frames[frame + TranslateTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n\n                x += (frames[frame + TranslateTimeline.X] - x) * percent;\n                y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n            }\n            if (pose == MixPose.setup) {\n                bone.x = bone.data.x + x * alpha;\n                bone.y = bone.data.y + y * alpha;\n            } else {\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n            }\n        }\n    }\n\n    export class ScaleTimeline extends TranslateTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.scale << 24) + this.boneIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        bone.scaleX = bone.data.scaleX;\n                        bone.scaleY = bone.data.scaleY;\n                        return;\n                    case MixPose.current:\n                        bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                        bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n                y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n                x = frames[frame + ScaleTimeline.PREV_X];\n                y = frames[frame + ScaleTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n\n                x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n                y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n            }\n            if (alpha == 1) {\n                bone.scaleX = x;\n                bone.scaleY = y;\n            } else {\n                let bx = 0, by = 0;\n                if (pose == MixPose.setup) {\n                    bx = bone.data.scaleX;\n                    by = bone.data.scaleY;\n                } else {\n                    bx = bone.scaleX;\n                    by = bone.scaleY;\n                }\n                // Mixing out uses sign of setup or current pose, else use sign of key.\n                if (direction == MixDirection.out) {\n                    x = Math.abs(x) * MathUtils.signum(bx);\n                    y = Math.abs(y) * MathUtils.signum(by);\n                } else {\n                    bx = Math.abs(bx) * MathUtils.signum(x);\n                    by = Math.abs(by) * MathUtils.signum(y);\n                }\n                bone.scaleX = bx + (x - bx) * alpha;\n                bone.scaleY = by + (y - by) * alpha;\n            }\n        }\n    }\n\n    export class ShearTimeline extends TranslateTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.shear << 24) + this.boneIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let bone = skeleton.bones[this.boneIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        bone.shearX = bone.data.shearX;\n                        bone.shearY = bone.data.shearY;\n                        return;\n                    case MixPose.current:\n                        bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                        bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n                }\n                return;\n            }\n\n            let x = 0, y = 0;\n            if (time >= frames[frames.length - ShearTimeline.ENTRIES]) { // Time is after last frame.\n                x = frames[frames.length + ShearTimeline.PREV_X];\n                y = frames[frames.length + ShearTimeline.PREV_Y];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n                x = frames[frame + ShearTimeline.PREV_X];\n                y = frames[frame + ShearTimeline.PREV_Y];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n\n                x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n                y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n            }\n            if (pose == MixPose.setup) {\n                bone.shearX = bone.data.shearX + x * alpha;\n                bone.shearY = bone.data.shearY + y * alpha;\n            } else {\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n            }\n        }\n    }\n\n    export class ColorTimeline extends CurveTimeline {\n        static ENTRIES = 5;\n        static PREV_TIME = -5; static PREV_R = -4; static PREV_G = -3; static PREV_B = -2; static PREV_A = -1;\n        static R = 1; static G = 2; static B = 3; static A = 4;\n\n        slotIndex: number;\n        frames: ArrayLike<number>; // time, r, g, b, a, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.color << 24) + this.slotIndex;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number) {\n            frameIndex *= ColorTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + ColorTimeline.R] = r;\n            this.frames[frameIndex + ColorTimeline.G] = g;\n            this.frames[frameIndex + ColorTimeline.B] = b;\n            this.frames[frameIndex + ColorTimeline.A] = a;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            let frames = this.frames;\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        slot.color.setFromColor(slot.data.color);\n                        return;\n                    case MixPose.current:\n                        let color = slot.color, setup = slot.data.color;\n                        color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha,\n                            (setup.a - color.a) * alpha);\n                }\n                return;\n            }\n\n            let r = 0, g = 0, b = 0, a = 0;\n            if (time >= frames[frames.length - ColorTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                r = frames[i + ColorTimeline.PREV_R];\n                g = frames[i + ColorTimeline.PREV_G];\n                b = frames[i + ColorTimeline.PREV_B];\n                a = frames[i + ColorTimeline.PREV_A];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n                r = frames[frame + ColorTimeline.PREV_R];\n                g = frames[frame + ColorTimeline.PREV_G];\n                b = frames[frame + ColorTimeline.PREV_B];\n                a = frames[frame + ColorTimeline.PREV_A];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n\n                r += (frames[frame + ColorTimeline.R] - r) * percent;\n                g += (frames[frame + ColorTimeline.G] - g) * percent;\n                b += (frames[frame + ColorTimeline.B] - b) * percent;\n                a += (frames[frame + ColorTimeline.A] - a) * percent;\n            }\n            if (alpha == 1)\n                slot.color.set(r, g, b, a);\n            else {\n                let color = slot.color;\n                if (pose == MixPose.setup) color.setFromColor(slot.data.color);\n                color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n            }\n        }\n    }\n\n    export class TwoColorTimeline extends CurveTimeline {\n        static ENTRIES = 8;\n        static PREV_TIME = -8; static PREV_R = -7; static PREV_G = -6; static PREV_B = -5; static PREV_A = -4;\n        static PREV_R2 = -3; static PREV_G2 = -2; static PREV_B2 = -1;\n        static R = 1; static G = 2; static B = 3; static A = 4; static R2 = 5; static G2 = 6; static B2 = 7;\n\n        slotIndex: number;\n        frames: ArrayLike<number>; // time, r, g, b, a, r2, g2, b2, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.twoColor << 24) + this.slotIndex;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n            frameIndex *= TwoColorTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TwoColorTimeline.R] = r;\n            this.frames[frameIndex + TwoColorTimeline.G] = g;\n            this.frames[frameIndex + TwoColorTimeline.B] = b;\n            this.frames[frameIndex + TwoColorTimeline.A] = a;\n            this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n            this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n            this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            let frames = this.frames;\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        slot.color.setFromColor(slot.data.color);\n                        slot.darkColor.setFromColor(slot.data.darkColor);\n                        return;\n                    case MixPose.current:\n                        let light = slot.color, dark = slot.darkColor, setupLight = slot.data.color, setupDark = slot.data.darkColor;\n                        light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha,\n                            (setupLight.a - light.a) * alpha);\n                        dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n                }\n                return;\n            }\n\n            let r = 0, g = 0, b = 0, a = 0, r2 = 0, g2 = 0, b2 = 0;\n            if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                r = frames[i + TwoColorTimeline.PREV_R];\n                g = frames[i + TwoColorTimeline.PREV_G];\n                b = frames[i + TwoColorTimeline.PREV_B];\n                a = frames[i + TwoColorTimeline.PREV_A];\n                r2 = frames[i + TwoColorTimeline.PREV_R2];\n                g2 = frames[i + TwoColorTimeline.PREV_G2];\n                b2 = frames[i + TwoColorTimeline.PREV_B2];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n                r = frames[frame + TwoColorTimeline.PREV_R];\n                g = frames[frame + TwoColorTimeline.PREV_G];\n                b = frames[frame + TwoColorTimeline.PREV_B];\n                a = frames[frame + TwoColorTimeline.PREV_A];\n                r2 = frames[frame + TwoColorTimeline.PREV_R2];\n                g2 = frames[frame + TwoColorTimeline.PREV_G2];\n                b2 = frames[frame + TwoColorTimeline.PREV_B2];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n\n                r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n                g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n                b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n                a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n                r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n                g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n                b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n            }\n            if (alpha == 1) {\n                slot.color.set(r, g, b, a);\n                slot.darkColor.set(r2, g2, b2, 1);\n            } else {\n                let light = slot.color, dark = slot.darkColor;\n                if (pose == MixPose.setup) {\n                    light.setFromColor(slot.data.color);\n                    dark.setFromColor(slot.data.darkColor);\n                }\n                light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n                dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n            }\n        }\n    }\n\n    export class AttachmentTimeline implements Timeline {\n        slotIndex: number;\n        frames: ArrayLike<number> // time, ...\n        attachmentNames: Array<string>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.attachmentNames = new Array<string>(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.attachment << 24) + this.slotIndex;\n        }\n\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, attachmentName: string) {\n            this.frames[frameIndex] = time;\n            this.attachmentNames[frameIndex] = attachmentName;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let slot = skeleton.slots[this.slotIndex];\n            if (direction == MixDirection.out && pose == MixPose.setup) {\n                let attachmentName = slot.data.attachmentName;\n                slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n                return;\n            }\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                if (pose == MixPose.setup) {\n                    let attachmentName = slot.data.attachmentName;\n                    slot.setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n                }\n                return;\n            }\n\n            let frameIndex = 0;\n            if (time >= frames[frames.length - 1]) // Time is after last frame.\n                frameIndex = frames.length - 1;\n            else\n                frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n\n            let attachmentName = this.attachmentNames[frameIndex];\n            skeleton.slots[this.slotIndex]\n                .setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n        }\n    }\n\n    let zeros : ArrayLike<number> = null;\n\n    export class DeformTimeline extends CurveTimeline {\n        slotIndex: number;\n        attachment: VertexAttachment;\n        frames: ArrayLike<number>; // time, ...\n        frameVertices: Array<ArrayLike<number>>;\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount);\n            this.frameVertices = new Array<ArrayLike<number>>(frameCount);\n            if (zeros == null) zeros = Utils.newFloatArray(64);\n        }\n\n        getPropertyId () {\n            return (TimelineType.deform << 27) + + this.attachment.id + this.slotIndex;\n        }\n\n        /** Sets the time of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, vertices: ArrayLike<number>) {\n            this.frames[frameIndex] = time;\n            this.frameVertices[frameIndex] = vertices;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let slot: Slot = skeleton.slots[this.slotIndex];\n            let slotAttachment: Attachment = slot.getAttachment();\n            if (!(slotAttachment instanceof VertexAttachment) || !(<VertexAttachment>slotAttachment).applyDeform(this.attachment)) return;\n\n            let verticesArray: Array<number> = slot.attachmentVertices;\n            let frameVertices = this.frameVertices;\n            let vertexCount = frameVertices[0].length;\n            let vertices: Array<number> = Utils.setArraySize(verticesArray, vertexCount);\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                let vertexAttachment = <VertexAttachment>slotAttachment;\n                switch (pose) {\n                    case MixPose.setup:\n                        let zeroVertices: ArrayLike<number>;\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions (setup pose).\n                            zeroVertices = vertexAttachment.vertices;\n                        } else {\n                            // Weighted deform offsets (zeros).\n                            zeroVertices = zeros;\n                            if (zeroVertices.length < vertexCount) zeros = zeroVertices = Utils.newFloatArray(vertexCount);\n                        }\n                        Utils.arrayCopy(zeroVertices, 0, vertices, 0, vertexCount);\n                        return;\n                    case MixPose.current:\n                        if (alpha == 1) break;\n                        if (vertexAttachment.bones == null) {\n                            // Unweighted vertex positions.\n                            let setupVertices = vertexAttachment.vertices;\n                            for (let i = 0; i < vertexCount; i++)\n                                vertices[i] += (setupVertices[i] - vertices[i]) * alpha;\n                        } else {\n                            // Weighted deform offsets.\n                            alpha = 1 - alpha;\n                            for (var i = 0; i < vertexCount; i++)\n                                vertices[i] *= alpha;\n                        }\n                }\n                return;\n            }\n\n            if (time >= frames[frames.length - 1]) { // Time is after last frame.\n                let lastVertices = frameVertices[frames.length - 1];\n                if (alpha == 1) {\n                    Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n                }else if (pose == MixPose.setup) {\n                    let vertexAttachment = slotAttachment as VertexAttachment;\n                    if (vertexAttachment.bones == null) {\n                        // Unweighted vertex positions, with alpha.\n                        let setupVertices = vertexAttachment.vertices;\n                        for (let i = 0; i < vertexCount; i++) {\n                            let setup = setupVertices[i];\n                            vertices[i] = setup + (lastVertices[i] - setup) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++)\n                            vertices[i] = lastVertices[i] * alpha;\n                    }\n                } else {\n                    for (let i = 0; i < vertexCount; i++)\n                        vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time);\n            let prevVertices = frameVertices[frame - 1];\n            let nextVertices = frameVertices[frame];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n            if (alpha == 1) {\n                for (let i = 0; i < vertexCount; i++) {\n                    let prev = prevVertices[i];\n                    vertices[i] = prev + (nextVertices[i] - prev) * percent;\n                }\n            } else if (pose == MixPose.setup) {\n                let vertexAttachment = slotAttachment as VertexAttachment;\n                if (vertexAttachment.bones == null) {\n                    // Unweighted vertex positions, with alpha.\n                    let setupVertices = vertexAttachment.vertices;\n                    for (let i = 0; i < vertexCount; i++) {\n                        let prev = prevVertices[i], setup = setupVertices[i];\n                        vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                    }\n                } else {\n                    // Weighted deform offsets, with alpha.\n                    for (let i = 0; i < vertexCount; i++) {\n                        let prev = prevVertices[i];\n                        vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                    }\n                }\n            } else {\n                // Vertex positions or deform offsets, with alpha.\n                for (let i = 0; i < vertexCount; i++) {\n                    let prev = prevVertices[i];\n                    vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n                }\n            }\n        }\n    }\n\n    export class EventTimeline implements Timeline {\n        frames: ArrayLike<number>; // time, ...\n        events: Array<Event>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.events = new Array<Event>(frameCount);\n        }\n\n        getPropertyId () {\n            return TimelineType.event << 24;\n        }\n\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time of the specified keyframe. */\n        setFrame (frameIndex: number, event: Event) {\n            this.frames[frameIndex] = event.time;\n            this.events[frameIndex] = event;\n        }\n\n        /** Fires events for frames > lastTime and <= time. */\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            if (firedEvents == null) return;\n            let frames = this.frames;\n            let frameCount = this.frames.length;\n\n            if (lastTime > time) { // Fire events after last time for looped animations.\n                this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, pose, direction);\n                lastTime = -1;\n            } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n                return;\n            if (time < frames[0]) return; // Time is before first frame.\n\n            let frame = 0;\n            if (lastTime < frames[0])\n                frame = 0;\n            else {\n                frame = Animation.binarySearch(frames, lastTime);\n                let frameTime = frames[frame];\n                while (frame > 0) { // Fire multiple events with the same frame.\n                    if (frames[frame - 1] != frameTime) break;\n                    frame--;\n                }\n            }\n            for (; frame < frameCount && time >= frames[frame]; frame++)\n                firedEvents.push(this.events[frame]);\n        }\n    }\n\n    export class DrawOrderTimeline implements Timeline {\n        frames: ArrayLike<number>; // time, ...\n        drawOrders: Array<Array<number>>;\n\n        constructor (frameCount: number) {\n            this.frames = Utils.newFloatArray(frameCount);\n            this.drawOrders = new Array<Array<number>>(frameCount);\n        }\n\n        getPropertyId () {\n            return TimelineType.drawOrder << 24;\n        }\n\n        getFrameCount () {\n            return this.frames.length;\n        }\n\n        /** Sets the time of the specified keyframe.\n         * @param drawOrder May be null to use bind pose draw order. */\n        setFrame (frameIndex: number, time: number, drawOrder: Array<number>) {\n            this.frames[frameIndex] = time;\n            this.drawOrders[frameIndex] = drawOrder;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let drawOrder: Array<Slot> = skeleton.drawOrder;\n            let slots: Array<Slot> = skeleton.slots;\n            if (direction == MixDirection.out && pose == MixPose.setup) {\n                Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                return;\n            }\n\n            let frames = this.frames;\n            if (time < frames[0]) {\n                if (pose == MixPose.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n                return;\n            }\n\n            let frame = 0;\n            if (time >= frames[frames.length - 1]) // Time is after last frame.\n                frame = frames.length - 1;\n            else\n                frame = Animation.binarySearch(frames, time) - 1;\n\n            let drawOrderToSetupIndex = this.drawOrders[frame];\n            if (drawOrderToSetupIndex == null)\n                Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);\n            else {\n                for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n                    drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n            }\n        }\n    }\n\n    export class IkConstraintTimeline extends CurveTimeline {\n        static ENTRIES = 3;\n        static PREV_TIME = -3; static PREV_MIX = -2; static PREV_BEND_DIRECTION = -1;\n        static MIX = 1; static BEND_DIRECTION = 2;\n\n        ikConstraintIndex: number;\n        frames: ArrayLike<number>; // time, mix, bendDirection, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n        }\n\n        /** Sets the time, mix and bend direction of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, mix: number, bendDirection: number) {\n            frameIndex *= IkConstraintTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n            this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.mix = constraint.data.mix;\n                        constraint.bendDirection = constraint.data.bendDirection;\n                        return;\n                    case MixPose.current:\n                        constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                        constraint.bendDirection = constraint.data.bendDirection;\n                }\n                return;\n            }\n\n            if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) { // Time is after last frame.\n                if (pose == MixPose.setup) {\n                    constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n                    constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection\n                        : frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                } else {\n                    constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n                    if (direction == MixDirection.in) constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n                }\n                return;\n            }\n\n            // Interpolate between the previous frame and the current frame.\n            let frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n            let mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n            let frameTime = frames[frame];\n            let percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1,\n                1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n            if (pose == MixPose.setup) {\n                constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n                constraint.bendDirection = direction == MixDirection.out ? constraint.data.bendDirection : frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n            } else {\n                constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n                if (direction == MixDirection.in) constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n            }\n        }\n    }\n\n    export class TransformConstraintTimeline extends CurveTimeline {\n        static ENTRIES = 5;\n        static PREV_TIME = -5; static PREV_ROTATE = -4; static PREV_TRANSLATE = -3; static PREV_SCALE = -2; static PREV_SHEAR = -1;\n        static ROTATE = 1; static TRANSLATE = 2; static SCALE = 3; static SHEAR = 4;\n\n        transformConstraintIndex: number;\n        frames: ArrayLike<number>; // time, rotate mix, translate mix, scale mix, shear mix, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n        }\n\n        /** Sets the time and mixes of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number, scaleMix: number, shearMix: number) {\n            frameIndex *= TransformConstraintTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n            this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n            this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n            this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n\n            let constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n            if (time < frames[0]) {\n                let data = constraint.data;\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.rotateMix = data.rotateMix;\n                        constraint.translateMix = data.translateMix;\n                        constraint.scaleMix = data.scaleMix;\n                        constraint.shearMix = data.shearMix;\n                        return;\n                    case MixPose.current:\n                        constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n                        constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n                        constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n                        constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n                }\n                return;\n            }\n\n            let rotate = 0, translate = 0, scale = 0, shear = 0;\n            if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) { // Time is after last frame.\n                let i = frames.length;\n                rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n                translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n                scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n                shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n                rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n                translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n                scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n                shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n\n                rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n                translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n                scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n                shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n            }\n            if (pose == MixPose.setup) {\n                let data = constraint.data;\n                constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n                constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n                constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n                constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n            } else {\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\n                constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n                constraint.shearMix += (shear - constraint.shearMix) * alpha;\n            }\n        }\n    }\n\n    export class PathConstraintPositionTimeline extends CurveTimeline {\n        static ENTRIES = 2;\n        static PREV_TIME = -2; static PREV_VALUE = -1;\n        static VALUE = 1;\n\n        pathConstraintIndex: number;\n\n        frames: ArrayLike<number>; // time, position, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n        }\n\n        /** Sets the time and value of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, value: number) {\n            frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.position = constraint.data.position;\n                        return;\n                    case MixPose.current:\n                        constraint.position += (constraint.data.position - constraint.position) * alpha;\n                }\n                return;\n            }\n\n            let position = 0;\n            if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) // Time is after last frame.\n                position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n                position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n\n                position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n            }\n            if (pose == MixPose.setup)\n                constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n            else\n                constraint.position += (position - constraint.position) * alpha;\n        }\n    }\n\n    export class PathConstraintSpacingTimeline extends PathConstraintPositionTimeline {\n        constructor (frameCount: number) {\n            super(frameCount);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.spacing = constraint.data.spacing;\n                        return;\n                    case MixPose.current:\n                        constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n                }\n                return;\n            }\n\n            let spacing = 0;\n            if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) // Time is after last frame.\n                spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n                spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n\n                spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n            }\n\n            if (pose == MixPose.setup)\n                constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n            else\n                constraint.spacing += (spacing - constraint.spacing) * alpha;\n        }\n    }\n\n    export class PathConstraintMixTimeline extends CurveTimeline {\n        static ENTRIES = 3;\n        static PREV_TIME = -3; static PREV_ROTATE = -2; static PREV_TRANSLATE = -1;\n        static ROTATE = 1; static TRANSLATE = 2;\n\n        pathConstraintIndex: number;\n\n        frames: ArrayLike<number>; // time, rotate mix, translate mix, ...\n\n        constructor (frameCount: number) {\n            super(frameCount);\n            this.frames = Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n        }\n\n        getPropertyId () {\n            return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n        }\n\n        /** Sets the time and mixes of the specified keyframe. */\n        setFrame (frameIndex: number, time: number, rotateMix: number, translateMix: number) {\n            frameIndex *= PathConstraintMixTimeline.ENTRIES;\n            this.frames[frameIndex] = time;\n            this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n            this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n        }\n\n        apply (skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, pose: MixPose, direction: MixDirection) {\n            let frames = this.frames;\n            let constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n            if (time < frames[0]) {\n                switch (pose) {\n                    case MixPose.setup:\n                        constraint.rotateMix = constraint.data.rotateMix;\n                        constraint.translateMix = constraint.data.translateMix;\n                        return;\n                    case MixPose.current:\n                        constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n                        constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n                }\n                return;\n            }\n\n            let rotate = 0, translate = 0;\n            if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) { // Time is after last frame.\n                rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n                translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n            } else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n                rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n                translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n                let frameTime = frames[frame];\n                let percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1,\n                    1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n\n                rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n                translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n            }\n\n            if (pose == MixPose.setup) {\n                constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n                constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n            } else {\n                constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n                constraint.translateMix += (translate - constraint.translateMix) * alpha;\n            }\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class AnimationState {\n        static emptyAnimation = new Animation(\"<empty>\", [], 0);\n        static SUBSEQUENT = 0;\n        static FIRST = 1;\n        static DIP = 2;\n        static DIP_MIX = 3;\n\n        data: AnimationStateData;\n        tracks = new Array<TrackEntry>();\n        events = new Array<Event>();\n        listeners = new Array<AnimationStateListener2>();\n        queue = new EventQueue(this);\n        propertyIDs = new IntSet();\n        mixingTo = new Array<TrackEntry>();\n        animationsChanged = false;\n        timeScale = 1;\n\n        trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n        constructor (data: AnimationStateData) {\n            this.data = data;\n        }\n\n        update (delta: number) {\n            delta *= this.timeScale;\n            let tracks = this.tracks;\n            for (let i = 0, n = tracks.length; i < n; i++) {\n                let current = tracks[i];\n                if (current == null) continue;\n\n                current.animationLast = current.nextAnimationLast;\n                current.trackLast = current.nextTrackLast;\n\n                let currentDelta = delta * current.timeScale;\n\n                if (current.delay > 0) {\n                    current.delay -= currentDelta;\n                    if (current.delay > 0) continue;\n                    currentDelta = -current.delay;\n                    current.delay = 0;\n                }\n\n                let next = current.next;\n                if (next != null) {\n                    // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                    let nextTime = current.trackLast - next.delay;\n                    if (nextTime >= 0) {\n                        next.delay = 0;\n                        next.trackTime = nextTime + delta * next.timeScale;\n                        current.trackTime += currentDelta;\n                        this.setCurrent(i, next, true);\n                        while (next.mixingFrom != null) {\n                            next.mixTime += currentDelta;\n                            next = next.mixingFrom;\n                        }\n                        continue;\n                    }\n                } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n                    tracks[i] = null;\n                    this.queue.end(current);\n                    this.disposeNext(current);\n                    continue;\n                }\n                if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n                    // End mixing from entries once all have completed.\n                    let from = current.mixingFrom;\n                    current.mixingFrom = null;\n                    while (from != null) {\n                        this.queue.end(from);\n                        from = from.mixingFrom;\n                    }\n                }\n\n                current.trackTime += currentDelta;\n            }\n\n            this.queue.drain();\n        }\n\n        updateMixingFrom (to: TrackEntry, delta: number): boolean {\n            let from = to.mixingFrom;\n            if (from == null) return true;\n\n            let finished = this.updateMixingFrom(from, delta);\n\n            // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n            if (to.mixTime > 0 && (to.mixTime >= to.mixDuration || to.timeScale == 0)) {\n                if (from.totalAlpha == 0) {\n                    to.mixingFrom = from.mixingFrom;\n                    to.interruptAlpha = from.interruptAlpha;\n                    this.queue.end(from);\n                }\n                return finished;\n            }\n\n            from.animationLast = from.nextAnimationLast;\n            from.trackLast = from.nextTrackLast;\n            from.trackTime += delta * from.timeScale;\n            to.mixTime += delta * to.timeScale;\n            return false;\n        }\n\n        apply (skeleton: Skeleton) : boolean {\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            if (this.animationsChanged) this._animationsChanged();\n\n            let events = this.events;\n            let tracks = this.tracks;\n            let applied = false;\n\n            for (let i = 0, n = tracks.length; i < n; i++) {\n                let current = tracks[i];\n                if (current == null || current.delay > 0) continue;\n                applied = true;\n                let currentPose = i == 0 ? MixPose.current : MixPose.currentLayered;\n\n                // Apply mixing from entries first.\n                let mix = current.alpha;\n                if (current.mixingFrom != null)\n                    mix *= this.applyMixingFrom(current, skeleton, currentPose);\n                else if (current.trackTime >= current.trackEnd && current.next == null)\n                    mix = 0;\n\n                // Apply current entry.\n                let animationLast = current.animationLast, animationTime = current.getAnimationTime();\n                let timelineCount = current.animation.timelines.length;\n                let timelines = current.animation.timelines;\n                if (mix == 1) {\n                    for (let ii = 0; ii < timelineCount; ii++)\n                        timelines[ii].apply(skeleton, animationLast, animationTime, events, 1, MixPose.setup, MixDirection.in);\n                } else {\n                    let timelineData = current.timelineData;\n\n                    let firstFrame = current.timelinesRotation.length == 0;\n                    if (firstFrame) Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n                    let timelinesRotation = current.timelinesRotation;\n\n                    for (let ii = 0; ii < timelineCount; ii++) {\n                        let timeline = timelines[ii];\n                        let pose = timelineData[ii] >= AnimationState.FIRST ? MixPose.setup : currentPose;\n                        if (timeline instanceof RotateTimeline) {\n                            this.applyRotateTimeline(timeline, skeleton, animationTime, mix, pose, timelinesRotation, ii << 1, firstFrame);\n                        } else\n                            timeline.apply(skeleton, animationLast, animationTime, events, mix, pose, MixDirection.in);\n                    }\n                }\n                this.queueEvents(current, animationTime);\n                events.length = 0;\n                current.nextAnimationLast = animationTime;\n                current.nextTrackLast = current.trackTime;\n            }\n\n            this.queue.drain();\n            return applied;\n        }\n\n        applyMixingFrom (to: TrackEntry, skeleton: Skeleton, currentPose: MixPose) {\n            let from = to.mixingFrom;\n            if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, currentPose);\n\n            let mix = 0;\n            if (to.mixDuration == 0) // Single frame mix to undo mixingFrom changes.\n                mix = 1;\n            else {\n                mix = to.mixTime / to.mixDuration;\n                if (mix > 1) mix = 1;\n            }\n\n            let events = mix < from.eventThreshold ? this.events : null;\n            let attachments = mix < from.attachmentThreshold, drawOrder = mix < from.drawOrderThreshold;\n            let animationLast = from.animationLast, animationTime = from.getAnimationTime();\n            let timelineCount = from.animation.timelines.length;\n            let timelines = from.animation.timelines;\n            let timelineData = from.timelineData;\n            let timelineDipMix = from.timelineDipMix;\n\n            let firstFrame = from.timelinesRotation.length == 0;\n            if (firstFrame) Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n            let timelinesRotation = from.timelinesRotation;\n\n            let pose: MixPose;\n            let alphaDip = from.alpha * to.interruptAlpha, alphaMix = alphaDip * (1 - mix), alpha = 0;\n            from.totalAlpha = 0;\n            for (var i = 0; i < timelineCount; i++) {\n                let timeline = timelines[i];\n                switch (timelineData[i]) {\n                    case AnimationState.SUBSEQUENT:\n                        if (!attachments && timeline instanceof AttachmentTimeline) continue;\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        pose = currentPose;\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.FIRST:\n                        pose = MixPose.setup\n                        alpha = alphaMix;\n                        break;\n                    case AnimationState.DIP:\n                        pose = MixPose.setup;\n                        alpha = alphaDip;\n                        break;\n                    default:\n                        pose = MixPose.setup;\n                        alpha = alphaDip;\n                        let dipMix = timelineDipMix[i];\n                        alpha *= Math.max(0, 1 - dipMix.mixTime / dipMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n                if (timeline instanceof RotateTimeline)\n                    this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, pose, timelinesRotation, i << 1, firstFrame);\n                else {\n                    timeline.apply(skeleton, animationLast, animationTime, events, alpha, pose, MixDirection.out);\n                }\n            }\n\n            if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n            this.events.length = 0;\n            from.nextAnimationLast = animationTime;\n            from.nextTrackLast = from.trackTime;\n\n            return mix;\n        }\n\n        applyRotateTimeline (timeline: Timeline, skeleton: Skeleton, time: number, alpha: number, pose: MixPose,\n                             timelinesRotation: Array<number>, i: number, firstFrame: boolean) {\n\n            if (firstFrame) timelinesRotation[i] = 0;\n\n            if (alpha == 1) {\n                timeline.apply(skeleton, 0, time, null, 1, pose, MixDirection.in);\n                return;\n            }\n\n            let rotateTimeline = timeline as RotateTimeline;\n            let frames = rotateTimeline.frames;\n            let bone = skeleton.bones[rotateTimeline.boneIndex];\n            if (time < frames[0]) {\n                if (pose == MixPose.setup) bone.rotation = bone.data.rotation;\n                return;\n            }\n\n            let r2 = 0;\n            if (time >= frames[frames.length - RotateTimeline.ENTRIES]) // Time is after last frame.\n                r2 = bone.data.rotation + frames[frames.length + RotateTimeline.PREV_ROTATION];\n            else {\n                // Interpolate between the previous frame and the current frame.\n                let frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n                let prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n                let frameTime = frames[frame];\n                let percent = rotateTimeline.getCurvePercent((frame >> 1) - 1,\n                    1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n\n                r2 = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n                r2 = prevRotation + r2 * percent + bone.data.rotation;\n                r2 -= (16384 - ((16384.499999999996 - r2 / 360) | 0)) * 360;\n            }\n\n            // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n            let r1 = pose == MixPose.setup ? bone.data.rotation : bone.rotation;\n            let total = 0, diff = r2 - r1;\n            if (diff == 0) {\n                total = timelinesRotation[i];\n            } else {\n                diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n                let lastTotal = 0, lastDiff = 0;\n                if (firstFrame) {\n                    lastTotal = 0;\n                    lastDiff = diff;\n                } else {\n                    lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                    lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n                }\n                let current = diff > 0, dir = lastTotal >= 0;\n                // Detect cross at 0 (not 180).\n                if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                    // A cross after a 360 rotation is a loop.\n                    if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                    dir = current;\n                }\n                total = diff + lastTotal - lastTotal % 360; // Store loops as part of lastTotal.\n                if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n                timelinesRotation[i] = total;\n            }\n            timelinesRotation[i + 1] = diff;\n            r1 += total * alpha;\n            bone.rotation = r1 - (16384 - ((16384.499999999996 - r1 / 360) | 0)) * 360;\n        }\n\n        queueEvents (entry: TrackEntry, animationTime: number) {\n            let animationStart = entry.animationStart, animationEnd = entry.animationEnd;\n            let duration = animationEnd - animationStart;\n            let trackLastWrapped = entry.trackLast % duration;\n\n            // Queue events before complete.\n            let events = this.events;\n            let i = 0, n = events.length;\n            for (; i < n; i++) {\n                let event = events[i];\n                if (event.time < trackLastWrapped) break;\n                if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n                this.queue.event(entry, event);\n            }\n\n            // Queue complete if completed a loop iteration or the animation.\n            if (entry.loop ? (trackLastWrapped > entry.trackTime % duration)\n                    : (animationTime >= animationEnd && entry.animationLast < animationEnd)) {\n                this.queue.complete(entry);\n            }\n\n            // Queue events after complete.\n            for (; i < n; i++) {\n                let event = events[i];\n                if (event.time < animationStart) continue; // Discard events outside animation start/end.\n                this.queue.event(entry, events[i]);\n            }\n        }\n\n        clearTracks () {\n            let oldDrainDisabled = this.queue.drainDisabled;\n            this.queue.drainDisabled = true;\n            for (let i = 0, n = this.tracks.length; i < n; i++)\n                this.clearTrack(i);\n            this.tracks.length = 0;\n            this.queue.drainDisabled = oldDrainDisabled;\n            this.queue.drain();\n        }\n\n        clearTrack (trackIndex: number) {\n            if (trackIndex >= this.tracks.length) return;\n            let current = this.tracks[trackIndex];\n            if (current == null) return;\n\n            this.queue.end(current);\n\n            this.disposeNext(current);\n\n            let entry = current;\n            while (true) {\n                let from = entry.mixingFrom;\n                if (from == null) break;\n                this.queue.end(from);\n                entry.mixingFrom = null;\n                entry = from;\n            }\n\n            this.tracks[current.trackIndex] = null;\n\n            this.queue.drain();\n        }\n\n        setCurrent (index: number, current: TrackEntry, interrupt: boolean) {\n            let from = this.expandToIndex(index);\n            this.tracks[index] = current;\n\n            if (from != null) {\n                if (interrupt) this.queue.interrupt(from);\n                current.mixingFrom = from;\n                current.mixTime = 0;\n\n                // Store the interrupted mix percentage.\n                if (from.mixingFrom != null && from.mixDuration > 0)\n                    current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n                from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n            }\n\n            this.queue.start(current);\n        }\n\n        setAnimation (trackIndex: number, animationName: string, loop: boolean) {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n            return this.setAnimationWith(trackIndex, animation, loop);\n        }\n\n        setAnimationWith (trackIndex: number, animation: Animation, loop: boolean) {\n            if (animation == null) throw new Error(\"animation cannot be null.\");\n            let interrupt = true;\n            let current = this.expandToIndex(trackIndex);\n            if (current != null) {\n                if (current.nextTrackLast == -1) {\n                    // Don't mix from an entry that was never applied.\n                    this.tracks[trackIndex] = current.mixingFrom;\n                    this.queue.interrupt(current);\n                    this.queue.end(current);\n                    this.disposeNext(current);\n                    current = current.mixingFrom;\n                    interrupt = false;\n                } else\n                    this.disposeNext(current);\n            }\n            let entry = this.trackEntry(trackIndex, animation, loop, current);\n            this.setCurrent(trackIndex, entry, interrupt);\n            this.queue.drain();\n            return entry;\n        }\n\n        addAnimation (trackIndex: number, animationName: string, loop: boolean, delay: number) {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n            return this.addAnimationWith(trackIndex, animation, loop, delay);\n        }\n\n        addAnimationWith (trackIndex: number, animation: Animation, loop: boolean, delay: number) {\n            if (animation == null) throw new Error(\"animation cannot be null.\");\n\n            let last = this.expandToIndex(trackIndex);\n            if (last != null) {\n                while (last.next != null)\n                    last = last.next;\n            }\n\n            let entry = this.trackEntry(trackIndex, animation, loop, last);\n\n            if (last == null) {\n                this.setCurrent(trackIndex, entry, true);\n                this.queue.drain();\n            } else {\n                last.next = entry;\n                if (delay <= 0) {\n                    let duration = last.animationEnd - last.animationStart;\n                    if (duration != 0)\n                        delay += duration * (1 + ((last.trackTime / duration) | 0)) - this.data.getMix(last.animation, animation);\n                    else\n                        delay = 0;\n                }\n            }\n\n            entry.delay = delay;\n            return entry;\n        }\n\n        setEmptyAnimation (trackIndex: number, mixDuration: number) {\n            let entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n            entry.mixDuration = mixDuration;\n            entry.trackEnd = mixDuration;\n            return entry;\n        }\n\n        addEmptyAnimation (trackIndex: number, mixDuration: number, delay: number) {\n            if (delay <= 0) delay -= mixDuration;\n            let entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n            entry.mixDuration = mixDuration;\n            entry.trackEnd = mixDuration;\n            return entry;\n        }\n\n        setEmptyAnimations (mixDuration: number) {\n            let oldDrainDisabled = this.queue.drainDisabled;\n            this.queue.drainDisabled = true;\n            for (let i = 0, n = this.tracks.length; i < n; i++) {\n                let current = this.tracks[i];\n                if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n            }\n            this.queue.drainDisabled = oldDrainDisabled;\n            this.queue.drain();\n        }\n\n        expandToIndex (index: number) {\n            if (index < this.tracks.length) return this.tracks[index];\n            Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\n            this.tracks.length = index + 1;\n            return null;\n        }\n\n        trackEntry (trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry) {\n            let entry = this.trackEntryPool.obtain();\n            entry.trackIndex = trackIndex;\n            entry.animation = animation;\n            entry.loop = loop;\n\n            entry.eventThreshold = 0;\n            entry.attachmentThreshold = 0;\n            entry.drawOrderThreshold = 0;\n\n            entry.animationStart = 0;\n            entry.animationEnd = animation.duration;\n            entry.animationLast = -1;\n            entry.nextAnimationLast = -1;\n\n            entry.delay = 0;\n            entry.trackTime = 0;\n            entry.trackLast = -1;\n            entry.nextTrackLast = -1;\n            entry.trackEnd = Number.MAX_VALUE;\n            entry.timeScale = 1;\n\n            entry.alpha = 1;\n            entry.interruptAlpha = 1;\n            entry.mixTime = 0;\n            entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n            return entry;\n        }\n\n        disposeNext (entry: TrackEntry) {\n            let next = entry.next;\n            while (next != null) {\n                this.queue.dispose(next);\n                next = next.next;\n            }\n            entry.next = null;\n        }\n\n        _animationsChanged () {\n            this.animationsChanged = false;\n\n            let propertyIDs = this.propertyIDs;\n            propertyIDs.clear();\n            let mixingTo = this.mixingTo;\n\n            let lastEntry: TrackEntry = null;\n            for (let i = 0, n = this.tracks.length; i < n; i++) {\n                let entry = this.tracks[i];\n                if (entry != null) entry.setTimelineData(null, mixingTo, propertyIDs);\n            }\n        }\n\n        getCurrent (trackIndex: number) {\n            if (trackIndex >= this.tracks.length) return null;\n            return this.tracks[trackIndex];\n        }\n\n        addListener (listener: AnimationStateListener2) {\n            if (listener == null) throw new Error(\"listener cannot be null.\");\n            this.listeners.push(listener);\n        }\n\n        /** Removes the listener added with {@link #addListener(AnimationStateListener)}. */\n        removeListener (listener: AnimationStateListener2) {\n            let index = this.listeners.indexOf(listener);\n            if (index >= 0) this.listeners.splice(index, 1);\n        }\n\n        clearListeners () {\n            this.listeners.length = 0;\n        }\n\n        clearListenerNotifications () {\n            this.queue.clear();\n        }\n\n        //deprecated stuff\n        onComplete: (trackIndex: number, loopCount: number) => any;\n        onEvent: (trackIndex: number, event: Event) => any;\n        onStart: (trackIndex: number) => any;\n        onEnd: (trackIndex: number) => any;\n\n        private static deprecatedWarning1: boolean = false;\n\n        setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n            if (!AnimationState.deprecatedWarning1) {\n                AnimationState.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n            }\n            this.setAnimation(trackIndex, animationName, loop);\n        }\n\n        private static deprecatedWarning2: boolean = false;\n\n        addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n            if (!AnimationState.deprecatedWarning2) {\n                AnimationState.deprecatedWarning2 = true;\n                console.warn(\"Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n            }\n            this.addAnimation(trackIndex, animationName, loop, delay);\n        }\n\n        private static deprecatedWarning3: boolean = false;\n\n        hasAnimation(animationName: string): boolean {\n            let animation = this.data.skeletonData.findAnimation(animationName);\n            return animation !== null;\n        }\n\n        hasAnimationByName(animationName: string): boolean {\n            if (!AnimationState.deprecatedWarning3) {\n                AnimationState.deprecatedWarning3 = true;\n                console.warn(\"Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n            }\n            return this.hasAnimation(animationName);\n        }\n    }\n\n    export class TrackEntry {\n        animation: Animation;\n        next: TrackEntry; mixingFrom: TrackEntry;\n        listener: AnimationStateListener2;\n        trackIndex: number;\n        loop: boolean;\n        eventThreshold: number; attachmentThreshold: number; drawOrderThreshold: number;\n        animationStart: number; animationEnd: number; animationLast: number; nextAnimationLast: number;\n        delay: number; trackTime: number; trackLast: number; nextTrackLast: number; trackEnd: number; timeScale: number;\n        alpha: number; mixTime: number; mixDuration: number; interruptAlpha: number; totalAlpha: number;\n        timelineData = new Array<number>();\n        timelineDipMix = new Array<TrackEntry>();\n        timelinesRotation = new Array<number>();\n\n        reset () {\n            this.next = null;\n            this.mixingFrom = null;\n            this.animation = null;\n            this.listener = null;\n            this.timelineData.length = 0;\n            this.timelineDipMix.length = 0;\n            this.timelinesRotation.length = 0;\n        }\n\n        setTimelineData (to: TrackEntry, mixingToArray: Array<TrackEntry>, propertyIDs: IntSet) : TrackEntry {\n            if (to != null) mixingToArray.push(to);\n            let lastEntry = this.mixingFrom != null ? this.mixingFrom.setTimelineData(this, mixingToArray, propertyIDs) : this;\n            if (to != null) mixingToArray.pop();\n\n            let mixingTo = mixingToArray;\n            let mixingToLast = mixingToArray.length - 1;\n            let timelines = this.animation.timelines;\n            let timelinesCount = this.animation.timelines.length;\n            let timelineData = Utils.setArraySize(this.timelineData, timelinesCount);\n            this.timelineDipMix.length = 0;\n            let timelineDipMix = Utils.setArraySize(this.timelineDipMix, timelinesCount);\n\n            outer:\n                for (var i = 0; i < timelinesCount; i++) {\n                    let id = timelines[i].getPropertyId();\n                    if (!propertyIDs.add(id))\n                        timelineData[i] = AnimationState.SUBSEQUENT;\n                    else if (to == null || !to.hasTimeline(id))\n                        timelineData[i] = AnimationState.FIRST;\n                    else {\n                        for (var ii = mixingToLast; ii >= 0; ii--) {\n                            let entry = mixingTo[ii];\n                            if (!entry.hasTimeline(id)) {\n                                if (entry.mixDuration > 0) {\n                                    timelineData[i] = AnimationState.DIP_MIX;\n                                    timelineDipMix[i] = entry;\n                                    continue outer;\n                                }\n                            }\n                        }\n                        timelineData[i] = AnimationState.DIP;\n                    }\n                }\n            return lastEntry;\n        }\n\n        hasTimeline (id: number) : boolean {\n            let timelines = this.animation.timelines;\n            for (var i = 0, n = timelines.length; i < n; i++)\n                if (timelines[i].getPropertyId() == id) return true;\n            return false;\n        }\n\n        getAnimationTime () {\n            if (this.loop) {\n                let duration = this.animationEnd - this.animationStart;\n                if (duration == 0) return this.animationStart;\n                return (this.trackTime % duration) + this.animationStart;\n            }\n            return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n        }\n\n        setAnimationLast(animationLast: number) {\n            this.animationLast = animationLast;\n            this.nextAnimationLast = animationLast;\n        }\n\n        isComplete () {\n            return this.trackTime >= this.animationEnd - this.animationStart;\n        }\n\n        resetRotationDirections () {\n            this.timelinesRotation.length = 0;\n        }\n\n        //deprecated stuff\n        onComplete: (trackIndex: number, loopCount: number) => any;\n        onEvent: (trackIndex: number, event: Event) => any;\n        onStart: (trackIndex: number) => any;\n        onEnd: (trackIndex: number) => any;\n\n        private static deprecatedWarning1: Boolean = false;\n        private static deprecatedWarning2: Boolean = false;\n\n        get time() {\n            if (!TrackEntry.deprecatedWarning1) {\n                TrackEntry.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n            }\n            return this.trackTime;\n        }\n\n        set time(value: number) {\n            if (!TrackEntry.deprecatedWarning1) {\n                TrackEntry.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n            }\n            this.trackTime = value;\n        }\n\n        get endTime() {\n            if (!TrackEntry.deprecatedWarning2) {\n                TrackEntry.deprecatedWarning2 = true;\n                console.warn(\"Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n            }\n            return this.trackTime;\n        }\n\n        set endTime(value: number) {\n            if (!TrackEntry.deprecatedWarning2) {\n                TrackEntry.deprecatedWarning2 = true;\n                console.warn(\"Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n            }\n            this.trackTime = value;\n        }\n\n        loopsCount() {\n            return Math.floor(this.trackTime / this.trackEnd);\n        }\n    }\n\n    export class EventQueue {\n        objects: Array<any> = [];\n        drainDisabled = false;\n        animState: AnimationState;\n\n        constructor(animState: AnimationState) {\n            this.animState = animState;\n        }\n\n        start (entry: TrackEntry) {\n            this.objects.push(EventType.start);\n            this.objects.push(entry);\n            this.animState.animationsChanged = true;\n        }\n\n        interrupt (entry: TrackEntry) {\n            this.objects.push(EventType.interrupt);\n            this.objects.push(entry);\n        }\n\n        end (entry: TrackEntry) {\n            this.objects.push(EventType.end);\n            this.objects.push(entry);\n            this.animState.animationsChanged = true;\n        }\n\n        dispose (entry: TrackEntry) {\n            this.objects.push(EventType.dispose);\n            this.objects.push(entry);\n        }\n\n        complete (entry: TrackEntry) {\n            this.objects.push(EventType.complete);\n            this.objects.push(entry);\n        }\n\n        event (entry: TrackEntry, event: Event) {\n            this.objects.push(EventType.event);\n            this.objects.push(entry);\n            this.objects.push(event);\n        }\n\n        private static deprecatedWarning1: Boolean = false;\n\n        deprecateStuff() {\n            if (!EventQueue.deprecatedWarning1) {\n                EventQueue.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\n            }\n            return true;\n        }\n\n        drain () {\n            if (this.drainDisabled) return;\n            this.drainDisabled = true;\n\n            let objects = this.objects;\n            let listeners = this.animState.listeners;\n\n            for (let i = 0; i < objects.length; i += 2) {\n                let type = objects[i] as EventType;\n                let entry = objects[i + 1] as TrackEntry;\n                switch (type) {\n                    case EventType.start:\n                        if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].start) listeners[ii].start(entry);\n                        //deprecation\n                        entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n                        this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n                        break;\n                    case EventType.interrupt:\n                        if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n                        break;\n                    case EventType.end:\n                        if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].end) listeners[ii].end(entry);\n                        //deprecation\n                        entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n                        this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n                    // Fall through.\n                    case EventType.dispose:\n                        if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].dispose) listeners[ii].dispose(entry);\n                        this.animState.trackEntryPool.free(entry);\n                        break;\n                    case EventType.complete:\n                        if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].complete) listeners[ii].complete(entry);\n                        //deprecation\n\n                        let count = MathUtils.toInt(entry.loopsCount()) ;\n                        entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n                        this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n                        break;\n                    case EventType.event:\n                        let event = objects[i++ + 2] as Event;\n                        if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event);\n                        for (let ii = 0; ii < listeners.length; ii++)\n                            if (listeners[ii].event) listeners[ii].event(entry, event);\n                        //deprecation\n                        entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event);\n                        this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event);\n                        break;\n                }\n            }\n            this.clear();\n\n            this.drainDisabled = false;\n        }\n\n        clear () {\n            this.objects.length = 0;\n        }\n    }\n\n    export enum EventType {\n        start, interrupt, end, dispose, complete, event\n    }\n\n    export interface AnimationStateListener2 {\n        /** Invoked when this entry has been set as the current entry. */\n        start? (entry: TrackEntry): void;\n\n        /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n         * mixing. */\n        interrupt? (entry: TrackEntry): void;\n\n        /** Invoked when this entry is no longer the current entry and will never be applied again. */\n        end? (entry: TrackEntry): void;\n\n        /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n         * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n        dispose? (entry: TrackEntry): void;\n\n        /** Invoked every time this entry's animation completes a loop. */\n        complete? (entry: TrackEntry): void;\n\n        /** Invoked when this entry's animation triggers an event. */\n        event? (entry: TrackEntry, event: Event): void;\n    }\n\n    export abstract class AnimationStateAdapter2 implements AnimationStateListener2 {\n        start (entry: TrackEntry) {\n        }\n\n        interrupt (entry: TrackEntry) {\n        }\n\n        end (entry: TrackEntry) {\n        }\n\n        dispose (entry: TrackEntry) {\n        }\n\n        complete (entry: TrackEntry) {\n        }\n\n        event (entry: TrackEntry, event: Event) {\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class AnimationStateData {\n        skeletonData: SkeletonData;\n        animationToMixTime: Map<number> = {};\n        defaultMix = 0;\n\n        constructor(skeletonData: SkeletonData) {\n            if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n            this.skeletonData = skeletonData;\n        }\n\n        setMix(fromName: string, toName: string, duration: number) {\n            let from = this.skeletonData.findAnimation(fromName);\n            if (from == null) throw new Error(\"Animation not found: \" + fromName);\n            let to = this.skeletonData.findAnimation(toName);\n            if (to == null) throw new Error(\"Animation not found: \" + toName);\n            this.setMixWith(from, to, duration);\n        }\n\n        private static deprecatedWarning1: boolean = false;\n\n        setMixByName(fromName: string, toName: string, duration: number) {\n            if (!AnimationStateData.deprecatedWarning1) {\n                AnimationStateData.deprecatedWarning1 = true;\n                console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n            }\n            this.setMix(fromName, toName, duration);\n        }\n\n        setMixWith(from: Animation, to: Animation, duration: number) {\n            if (from == null) throw new Error(\"from cannot be null.\");\n            if (to == null) throw new Error(\"to cannot be null.\");\n            let key = from.name + to.name;\n            this.animationToMixTime[key] = duration;\n        }\n\n        getMix(from: Animation, to: Animation) {\n            let key = from.name + to.name;\n            let value = this.animationToMixTime[key];\n            return value === undefined ? this.defaultMix : value;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class AtlasAttachmentLoader implements AttachmentLoader {\n        atlas: TextureAtlas;\n\n        constructor(atlas: TextureAtlas) {\n            this.atlas = atlas;\n        }\n\n        /** @return May be null to not load an attachment. */\n        newRegionAttachment(skin: Skin, name: string, path: string): RegionAttachment {\n            let region = this.atlas.findRegion(path);\n            if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n            let attachment = new RegionAttachment(name);\n            attachment.region = region;\n            return attachment;\n        }\n\n        /** @return May be null to not load an attachment. */\n        newMeshAttachment(skin: Skin, name: string, path: string): MeshAttachment {\n            let region = this.atlas.findRegion(path);\n            if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n            let attachment = new MeshAttachment(name);\n            attachment.region = region;\n            return attachment;\n        }\n\n        /** @return May be null to not load an attachment. */\n        newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n            return new BoundingBoxAttachment(name);\n        }\n\n        /** @return May be null to not load an attachment */\n        newPathAttachment(skin: Skin, name: string): PathAttachment {\n            return new PathAttachment(name);\n        }\n\n        newPointAttachment(skin: Skin, name: string): PointAttachment {\n            return new PointAttachment(name);\n        }\n\n        newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n            return new ClippingAttachment(name);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export abstract class Attachment {\n        name: string;\n\n        constructor(name: string) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n    }\n\n    export abstract class VertexAttachment extends Attachment {\n        private static nextID = 0;\n\n        id = (VertexAttachment.nextID++ & 65535) << 11;\n        bones: Array<number>;\n        vertices: ArrayLike<number>;\n        worldVerticesLength = 0;\n\n        constructor(name: string) {\n            super(name);\n        }\n\n        computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n            this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n        }\n\n        /** Transforms local vertices to world coordinates.\n         * @param start The index of the first local vertex value to transform. Each vertex has 2 values, x and y.\n         * @param count The number of world vertex values to output. Must be <= {@link #getWorldVerticesLength()} - start.\n         * @param worldVertices The output world vertices. Must have a length >= offset + count.\n         * @param offset The worldVertices index to begin writing values. */\n        computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n            count = offset + (count >> 1) * stride;\n            let skeleton = slot.bone.skeleton;\n            let deformArray = slot.attachmentVertices;\n            let vertices = this.vertices;\n            let bones = this.bones;\n            if (bones == null) {\n                if (deformArray.length > 0) vertices = deformArray;\n                let mat = slot.bone.matrix;\n                let x = mat.tx;\n                let y = mat.ty;\n                let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n                for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                    let vx = vertices[v], vy = vertices[v + 1];\n                    worldVertices[w] = vx * a + vy * b + x;\n                    worldVertices[w + 1] = vx * c + vy * d + y;\n                }\n                return;\n            }\n            let v = 0, skip = 0;\n            for (let i = 0; i < start; i += 2) {\n                let n = bones[v];\n                v += n + 1;\n                skip += n;\n            }\n            let skeletonBones = skeleton.bones;\n            if (deformArray.length == 0) {\n                for (let w = offset, b = skip * 3; w < count; w += stride) {\n                    let wx = 0, wy = 0;\n                    let n = bones[v++];\n                    n += v;\n                    for (; v < n; v++, b += 3) {\n                        let mat = skeletonBones[bones[v]].matrix;\n                        let vx = vertices[b], vy = vertices[b + 1], weight = vertices[b + 2];\n                        wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                        wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                    }\n                    worldVertices[w] = wx;\n                    worldVertices[w + 1] = wy;\n                }\n            } else {\n                let deform = deformArray;\n                for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                    let wx = 0, wy = 0;\n                    let n = bones[v++];\n                    n += v;\n                    for (; v < n; v++, b += 3, f += 2) {\n                        let mat = skeletonBones[bones[v]].matrix;\n                        let vx = vertices[b] + deform[f], vy = vertices[b + 1] + deform[f + 1],\n                            weight = vertices[b + 2];\n                        wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                        wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                    }\n                    worldVertices[w] = wx;\n                    worldVertices[w + 1] = wy;\n                }\n            }\n        }\n\n        /** Returns true if a deform originally applied to the specified attachment should be applied to this attachment. */\n        applyDeform(sourceAttachment: VertexAttachment) {\n            return this == sourceAttachment;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface AttachmentLoader {\n        /** @return May be null to not load an attachment. */\n        newRegionAttachment (skin: Skin, name: string, path: string): RegionAttachment;\n\n        /** @return May be null to not load an attachment. */\n        newMeshAttachment (skin: Skin, name: string, path: string): MeshAttachment;\n\n        /** @return May be null to not load an attachment. */\n        newBoundingBoxAttachment (skin: Skin, name: string): BoundingBoxAttachment;\n\n        /** @return May be null to not load an attachment */\n        newPathAttachment(skin: Skin, name: string): PathAttachment;\n\n        /** @return May be null to not load an attachment */\n        newPointAttachment(skin: Skin, name: string): PointAttachment;\n\n        /** @return May be null to not load an attachment */\n        newClippingAttachment(skin: Skin, name: string): ClippingAttachment;\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export enum AttachmentType {\n        Region, BoundingBox, Mesh, LinkedMesh, Path, Point\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class BoundingBoxAttachment extends VertexAttachment {\n        color = new Color(1, 1, 1, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class ClippingAttachment extends VertexAttachment {\n        endSlot: SlotData;\n\n        // Nonessential.\n        color = new Color(0.2275, 0.2275, 0.8078, 1); // ce3a3aff\n\n        constructor(name: string) {\n            super(name);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class MeshAttachment extends VertexAttachment {\n        region: TextureRegion;\n        path: string;\n        regionUVs: ArrayLike<number>; uvs: ArrayLike<number>;\n        triangles: Array<number>;\n        color = new Color(1, 1, 1, 1);\n        hullLength: number;\n        private parentMesh: MeshAttachment;\n        inheritDeform = false;\n        tempColor = new Color(0, 0, 0, 0);\n\n        constructor (name: string) {\n            super(name);\n        }\n\n        updateUVs(region: TextureRegion, uvs: ArrayLike<number>): ArrayLike<number> {\n            let regionUVs = this.regionUVs;\n            let n = regionUVs.length;\n            if (!uvs || uvs.length != n) {\n                uvs = Utils.newFloatArray(n);\n            }\n\n            if (region == null) {\n                return;\n            }\n\n            let texture = region.texture;\n            let r = (texture as any)._uvs;\n            let w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n            let x = region.offsetX, y = region.pixiOffsetY;\n\n            for (let i = 0; i < n; i += 2) {\n                let u = this.regionUVs[i], v = this.regionUVs[i + 1];\n                u = (u * w2 - x) / w1;\n                v = (v * h2 - y) / h1;\n                uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1 - v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n                uvs[i + 1] = (r.y0 * (1 - u) + r.y1 * u) * (1 - v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n            }\n\n            return uvs;\n        }\n\n        applyDeform (sourceAttachment: VertexAttachment): boolean {\n            return this == sourceAttachment || (this.inheritDeform && this.parentMesh == sourceAttachment);\n        }\n\n        getParentMesh () {\n            return this.parentMesh;\n        }\n\n        /** @param parentMesh May be null. */\n        setParentMesh (parentMesh: MeshAttachment) {\n            this.parentMesh = parentMesh;\n            if (parentMesh != null) {\n                this.bones = parentMesh.bones;\n                this.vertices = parentMesh.vertices;\n                this.worldVerticesLength = parentMesh.worldVerticesLength;\n                this.regionUVs = parentMesh.regionUVs;\n                this.triangles = parentMesh.triangles;\n                this.hullLength = parentMesh.hullLength;\n                this.worldVerticesLength = parentMesh.worldVerticesLength\n            }\n        }\n\n        //computeWorldVerticesWith(slot, 0, this.worldVerticesLength, worldVertices, 0);\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class PathAttachment extends VertexAttachment {\n        lengths: Array<number>;\n        closed = false;\n        constantSpeed = false;\n        color = new Color(1, 1, 1, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class PointAttachment extends VertexAttachment {\n        x: number;\n        y: number;\n        rotation: number;\n        color = new Color(0.38, 0.94, 0, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n\n        computeWorldPosition(bone: Bone, point: Vector2) {\n            const mat = bone.matrix;\n            point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n            point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n            return point;\n        }\n\n        computeWorldRotation(bone: Bone) {\n            const mat = bone.matrix;\n            let cos = MathUtils.cosDeg(this.rotation), sin = MathUtils.sinDeg(this.rotation);\n            let x = cos * mat.a + sin * mat.c;\n            let y = cos * mat.b + sin * mat.d;\n            return Math.atan2(y, x) * MathUtils.radDeg;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class RegionAttachment extends Attachment {\n        static OX1 = 0;\n        static OY1 = 1;\n        static OX2 = 2;\n        static OY2 = 3;\n        static OX3 = 4;\n        static OY3 = 5;\n        static OX4 = 6;\n        static OY4 = 7;\n\n        static X1 = 0;\n        static Y1 = 1;\n        static C1R = 2;\n        static C1G = 3;\n        static C1B = 4;\n        static C1A = 5;\n        static U1 = 6;\n        static V1 = 7;\n\n        static X2 = 8;\n        static Y2 = 9;\n        static C2R = 10;\n        static C2G = 11;\n        static C2B = 12;\n        static C2A = 13;\n        static U2 = 14;\n        static V2 = 15;\n\n        static X3 = 16;\n        static Y3 = 17;\n        static C3R = 18;\n        static C3G = 19;\n        static C3B = 20;\n        static C3A = 21;\n        static U3 = 22;\n        static V3 = 23;\n\n        static X4 = 24;\n        static Y4 = 25;\n        static C4R = 26;\n        static C4G = 27;\n        static C4B = 28;\n        static C4A = 29;\n        static U4 = 30;\n        static V4 = 31;\n\n        x = 0;\n        y = 0;\n        scaleX = 1;\n        scaleY = 1;\n        rotation = 0;\n        width = 0;\n        height = 0;\n        color = new Color(1, 1, 1, 1);\n\n        path: string;\n        rendererObject: any;\n        region: TextureRegion;\n\n        offset = Utils.newFloatArray(8);\n        uvs = Utils.newFloatArray(8);\n\n        tempColor = new Color(1, 1, 1, 1);\n\n        constructor(name: string) {\n            super(name);\n        }\n\n        updateOffset(): void {\n            let regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n            let regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n            let localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n            let localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n            let localX2 = localX + this.region.width * regionScaleX;\n            let localY2 = localY + this.region.height * regionScaleY;\n            let radians = this.rotation * Math.PI / 180;\n            let cos = Math.cos(radians);\n            let sin = Math.sin(radians);\n            let localXCos = localX * cos + this.x;\n            let localXSin = localX * sin;\n            let localYCos = localY * cos + this.y;\n            let localYSin = localY * sin;\n            let localX2Cos = localX2 * cos + this.x;\n            let localX2Sin = localX2 * sin;\n            let localY2Cos = localY2 * cos + this.y;\n            let localY2Sin = localY2 * sin;\n            let offset = this.offset;\n            offset[RegionAttachment.OX1] = localXCos - localYSin;\n            offset[RegionAttachment.OY1] = localYCos + localXSin;\n            offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n            offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n            offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n            offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n            offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n            offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n        }\n\n        setRegion(region: TextureRegion): void {\n            this.region = region;\n            let uvs = this.uvs;\n            if (region.rotate) {\n                uvs[2] = region.u;\n                uvs[3] = region.v2;\n                uvs[4] = region.u;\n                uvs[5] = region.v;\n                uvs[6] = region.u2;\n                uvs[7] = region.v;\n                uvs[0] = region.u2;\n                uvs[1] = region.v2;\n            } else {\n                uvs[0] = region.u;\n                uvs[1] = region.v2;\n                uvs[2] = region.u;\n                uvs[3] = region.v;\n                uvs[4] = region.u2;\n                uvs[5] = region.v;\n                uvs[6] = region.u2;\n                uvs[7] = region.v2;\n            }\n        }\n\n        computeWorldVertices(bone: Bone, worldVertices: ArrayLike<number>, offset: number, stride: number) {\n            let vertexOffset = this.offset;\n            let mat = bone.matrix;\n            let x = mat.tx, y = mat.ty;\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n            let offsetX = 0, offsetY = 0;\n\n            offsetX = vertexOffset[RegionAttachment.OX1];\n            offsetY = vertexOffset[RegionAttachment.OY1];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // br\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX2];\n            offsetY = vertexOffset[RegionAttachment.OY2];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // bl\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX3];\n            offsetY = vertexOffset[RegionAttachment.OY3];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // ul\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n            offset += stride;\n\n            offsetX = vertexOffset[RegionAttachment.OX4];\n            offsetY = vertexOffset[RegionAttachment.OY4];\n            worldVertices[offset] = offsetX * a + offsetY * b + x; // ur\n            worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export enum BlendMode {\n        Normal = 0,\n        Additive = 1,\n        Multiply = 2,\n        Screen = 3\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Bone implements Updatable {\n        static yDown: boolean = false;\n        //be careful! Spine b,c is c,b in pixi matrix\n        matrix = new PIXI.Matrix();\n\n        get worldX(): number {\n            return this.matrix.tx;\n        }\n\n        get worldY(): number {\n            return this.matrix.ty;\n        }\n\n        data: BoneData;\n        skeleton: Skeleton;\n        parent: Bone;\n        children = new Array<Bone>();\n        x = 0;\n        y = 0;\n        rotation = 0;\n        scaleX = 0;\n        scaleY = 0;\n        shearX = 0;\n        shearY = 0;\n        ax = 0;\n        ay = 0;\n        arotation = 0;\n        ascaleX = 0;\n        ascaleY = 0;\n        ashearX = 0;\n        ashearY = 0;\n        appliedValid = false;\n\n        sorted = false;\n\n        /** @param parent May be null. */\n        constructor(data: BoneData, skeleton: Skeleton, parent: Bone) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.skeleton = skeleton;\n            this.parent = parent;\n            this.setToSetupPose();\n        }\n\n        /** Same as {@link #updateWorldTransform()}. This method exists for Bone to implement {@link Updatable}. */\n        update() {\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n        }\n\n        /** Computes the world transform using the parent bone and this bone's local transform. */\n        updateWorldTransform() {\n            this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n        }\n\n        /** Computes the world transform using the parent bone and the specified local transform. */\n        updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n            this.ax = x;\n            this.ay = y;\n            this.arotation = rotation;\n            this.ascaleX = scaleX;\n            this.ascaleY = scaleY;\n            this.ashearX = shearX;\n            this.ashearY = shearY;\n            this.appliedValid = true;\n\n            let parent = this.parent;\n            let m = this.matrix;\n            if (parent == null) { // Root bone.\n                let rotationY = rotation + 90 + shearY;\n                let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                let lb = MathUtils.cosDeg(rotationY) * scaleY;\n                let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                let ld = MathUtils.sinDeg(rotationY) * scaleY;\n                let skeleton = this.skeleton;\n                if (skeleton.flipX) {\n                    x = -x;\n                    la = -la;\n                    lb = -lb;\n                }\n                if (skeleton.flipY !== Bone.yDown) {\n                    y = -y;\n                    lc = -lc;\n                    ld = -ld;\n                }\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n                m.tx = x + skeleton.x;\n                m.ty = y + skeleton.y;\n                return;\n            }\n\n            let pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n            m.tx = pa * x + pb * y + parent.matrix.tx;\n            m.ty = pc * x + pd * y + parent.matrix.ty;\n            switch (this.data.transformMode) {\n                case TransformMode.Normal: {\n                    let rotationY = rotation + 90 + shearY;\n                    let la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    let lb = MathUtils.cosDeg(rotationY) * scaleY;\n                    let lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    let ld = MathUtils.sinDeg(rotationY) * scaleY;\n                    m.a = pa * la + pb * lc;\n                    m.c = pa * lb + pb * ld;\n                    m.b = pc * la + pd * lc;\n                    m.d = pc * lb + pd * ld;\n                    return;\n                }\n                case TransformMode.OnlyTranslation: {\n                    let rotationY = rotation + 90 + shearY;\n                    m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                    m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                    m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                    m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                    break;\n                }\n                case TransformMode.NoRotationOrReflection: {\n                    let s = pa * pa + pc * pc;\n                    let prx = 0;\n                    if (s > 0.0001) {\n                        s = Math.abs(pa * pd - pb * pc) / s;\n                        pb = pc * s;\n                        pd = pa * s;\n                        prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                    } else {\n                        pa = 0;\n                        pc = 0;\n                        prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                    }\n                    let rx = rotation + shearX - prx;\n                    let ry = rotation + shearY - prx + 90;\n                    let la = MathUtils.cosDeg(rx) * scaleX;\n                    let lb = MathUtils.cosDeg(ry) * scaleY;\n                    let lc = MathUtils.sinDeg(rx) * scaleX;\n                    let ld = MathUtils.sinDeg(ry) * scaleY;\n                    m.a = pa * la - pb * lc;\n                    m.c = pa * lb - pb * ld;\n                    m.b = pc * la + pd * lc;\n                    m.d = pc * lb + pd * ld;\n                    break;\n                }\n                case TransformMode.NoScale:\n                case TransformMode.NoScaleOrReflection: {\n                    let cos = MathUtils.cosDeg(rotation);\n                    let sin = MathUtils.sinDeg(rotation);\n                    let za = pa * cos + pb * sin;\n                    let zc = pc * cos + pd * sin;\n                    let s = Math.sqrt(za * za + zc * zc);\n                    if (s > 0.00001) s = 1 / s;\n                    za *= s;\n                    zc *= s;\n                    s = Math.sqrt(za * za + zc * zc);\n                    let r = Math.PI / 2 + Math.atan2(zc, za);\n                    let zb = Math.cos(r) * s;\n                    let zd = Math.sin(r) * s;\n                    let la = MathUtils.cosDeg(shearX) * scaleX;\n                    let lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                    let lc = MathUtils.sinDeg(shearX) * scaleX;\n                    let ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n                    m.a = za * la + zb * lc;\n                    m.c = za * lb + zb * ld;\n                    m.b = zc * la + zd * lc;\n                    m.d = zc * lb + zd * ld;\n                    if (this.data.transformMode != TransformMode.NoScaleOrReflection ? pa * pd - pb * pc < 0 : ((this.skeleton.flipX != this.skeleton.flipY) != Bone.yDown)) {\n                        m.c = -m.c;\n                        m.d = -m.d;\n                    }\n                    return;\n                }\n            }\n            if (this.skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (this.skeleton.flipY != Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n\n        setToSetupPose() {\n            let data = this.data;\n            this.x = data.x;\n            this.y = data.y;\n            this.rotation = data.rotation;\n            this.scaleX = data.scaleX;\n            this.scaleY = data.scaleY;\n            this.shearX = data.shearX;\n            this.shearY = data.shearY;\n        }\n\n        getWorldRotationX() {\n            return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n        }\n\n        getWorldRotationY() {\n            return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n        }\n\n        getWorldScaleX() {\n            let m = this.matrix;\n            return Math.sqrt(m.a * m.a + m.c * m.c);\n        }\n\n        getWorldScaleY() {\n            let m = this.matrix;\n            return Math.sqrt(m.b * m.b + m.d * m.d);\n        }\n\n        /** Computes the individual applied transform values from the world transform. This can be useful to perform processing using\n         * the applied transform after the world transform has been modified directly (eg, by a constraint).\n         * <p>\n         * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. */\n        updateAppliedTransform() {\n            this.appliedValid = true;\n            let parent = this.parent;\n            let m = this.matrix;\n            if (parent == null) {\n                this.ax = m.tx;\n                this.ay = m.ty;\n                this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n                this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n                this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n                this.ashearX = 0;\n                this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n                return;\n            }\n            let pm = parent.matrix;\n            let pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n            let dx = m.tx - pm.tx, dy = m.ty - pm.ty;\n            this.ax = (dx * pm.d * pid - dy * pm.c * pid);\n            this.ay = (dy * pm.a * pid - dx * pm.b * pid);\n            let ia = pid * pm.d;\n            let id = pid * pm.a;\n            let ib = pid * pm.c;\n            let ic = pid * pm.b;\n            let ra = ia * m.a - ib * m.b;\n            let rb = ia * m.c - ib * m.d;\n            let rc = id * m.b - ic * m.a;\n            let rd = id * m.d - ic * m.c;\n            this.ashearX = 0;\n            this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n            if (this.ascaleX > 0.0001) {\n                let det = ra * rd - rb * rc;\n                this.ascaleY = det / this.ascaleX;\n                this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n                this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n            } else {\n                this.ascaleX = 0;\n                this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n                this.ashearY = 0;\n                this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n            }\n        }\n\n        worldToLocal(world: Vector2) {\n            let m = this.matrix;\n            let a = m.a, b = m.c, c = m.b, d = m.d;\n            let invDet = 1 / (a * d - b * c);\n            let x = world.x - m.tx, y = world.y - m.ty;\n            world.x = (x * d * invDet - y * b * invDet);\n            world.y = (y * a * invDet - x * c * invDet);\n            return world;\n        }\n\n        localToWorld(local: Vector2) {\n            let m = this.matrix;\n            let x = local.x, y = local.y;\n            local.x = x * m.a + y * m.c + m.tx;\n            local.y = x * m.b + y * m.d + m.ty;\n            return local;\n        }\n\n        worldToLocalRotation (worldRotation: number) {\n            let sin = MathUtils.sinDeg(worldRotation), cos = MathUtils.cosDeg(worldRotation);\n            let mat = this.matrix;\n            return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n        }\n\n        localToWorldRotation (localRotation: number) {\n            let sin = MathUtils.sinDeg(localRotation), cos = MathUtils.cosDeg(localRotation);\n            let mat = this.matrix;\n            return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n        }\n\n        rotateWorld (degrees: number) {\n            let mat = this.matrix;\n            let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n            let cos = MathUtils.cosDeg(degrees), sin = MathUtils.sinDeg(degrees);\n            mat.a = cos * a - sin * c;\n            mat.c = cos * b - sin * d;\n            mat.b = sin * a + cos * c;\n            mat.d = sin * b + cos * d;\n            this.appliedValid = false;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class BoneData {\n        index: number;\n        name: string;\n        parent: BoneData;\n        length: number;\n        x = 0;\n        y = 0;\n        rotation = 0;\n        scaleX = 1;\n        scaleY = 1;\n        shearX = 0;\n        shearY = 0;\n        transformMode = TransformMode.Normal;\n\n        constructor(index: number, name: string, parent: BoneData) {\n            if (index < 0) throw new Error(\"index must be >= 0.\");\n            if (name == null) throw new Error(\"name cannot be null.\");\n            this.index = index;\n            this.name = name;\n            this.parent = parent;\n        }\n    }\n\n    export enum TransformMode {\n        Normal, OnlyTranslation, NoRotationOrReflection, NoScale, NoScaleOrReflection\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface Constraint extends Updatable {\n        getOrder(): number;\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Event {\n        data: EventData;\n        intValue: number;\n        floatValue: number;\n        stringValue: string;\n        time: number;\n\n        constructor(time: number, data: EventData) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            this.time = time;\n            this.data = data;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class EventData {\n        name: string;\n        intValue: number;\n        floatValue: number;\n        stringValue: string;\n\n        constructor (name: string) {\n            this.name = name;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class IkConstraint implements Constraint {\n        data: IkConstraintData;\n        bones: Array<Bone>;\n        target: Bone;\n        mix = 1;\n        bendDirection = 0;\n\n        constructor (data: IkConstraintData, skeleton: Skeleton) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.mix = data.mix;\n            this.bendDirection = data.bendDirection;\n\n            this.bones = new Array<Bone>();\n            for (let i = 0; i < data.bones.length; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findBone(data.target.name);\n        }\n\n        getOrder () {\n            return this.data.order;\n        }\n\n        apply () {\n            this.update();\n        }\n\n        update () {\n            let target = this.target;\n            let bones = this.bones;\n            switch (bones.length) {\n                case 1:\n                    this.apply1(bones[0], target.worldX, target.worldY, this.mix);\n                    break;\n                case 2:\n                    this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n                    break;\n            }\n        }\n\n        /** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n         * coordinate system. */\n        apply1 (bone: Bone, targetX: number, targetY: number, alpha: number) {\n            if (!bone.appliedValid) bone.updateAppliedTransform();\n            let p = bone.parent.matrix;\n            let id = 1 / (p.a * p.d - p.b * p.c);\n            let x = targetX - p.tx, y = targetY - p.ty;\n            let tx = (x * p.d - y * p.c) * id - bone.ax, ty = (y * p.a - x * p.b) * id - bone.ay;\n            let rotationIK = Math.atan2(ty, tx) * MathUtils.radDeg - bone.ashearX - bone.arotation;\n            if (bone.ascaleX < 0) rotationIK += 180;\n            if (rotationIK > 180)\n                rotationIK -= 360;\n            else if (rotationIK < -180) rotationIK += 360;\n            bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, bone.ascaleX, bone.ascaleY, bone.ashearX,\n                bone.ashearY);\n        }\n\n        /** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n         * target is specified in the world coordinate system.\n         * @param child A direct descendant of the parent bone. */\n        apply2 (parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, alpha: number) {\n            if (alpha == 0) {\n                child.updateWorldTransform();\n                return;\n            }\n            if (!parent.appliedValid) parent.updateAppliedTransform();\n            if (!child.appliedValid) child.updateAppliedTransform();\n            let px = parent.ax, py = parent.ay, psx = parent.ascaleX, psy = parent.ascaleY, csx = child.ascaleX;\n            let pmat = parent.matrix;\n            let os1 = 0, os2 = 0, s2 = 0;\n            if (psx < 0) {\n                psx = -psx;\n                os1 = 180;\n                s2 = -1;\n            } else {\n                os1 = 0;\n                s2 = 1;\n            }\n            if (psy < 0) {\n                psy = -psy;\n                s2 = -s2;\n            }\n            if (csx < 0) {\n                csx = -csx;\n                os2 = 180;\n            } else\n                os2 = 0;\n            let cx = child.ax, cy = 0, cwx = 0, cwy = 0, a = pmat.a, b = pmat.c, c = pmat.b, d = pmat.d;\n            let u = Math.abs(psx - psy) <= 0.0001;\n            if (!u) {\n                cy = 0;\n                cwx = a * cx + pmat.tx;\n                cwy = c * cx + pmat.ty;\n            } else {\n                cy = child.ay;\n                cwx = a * cx + b * cy + pmat.tx;\n                cwy = c * cx + d * cy + pmat.ty;\n            }\n            let pp = parent.parent.matrix;\n            a = pp.a;\n            b = pp.c;\n            c = pp.b;\n            d = pp.d;\n            let id = 1 / (a * d - b * c), x = targetX - pp.tx, y = targetY - pp.ty;\n            let tx = (x * d - y * b) * id - px, ty = (y * a - x * c) * id - py;\n            x = cwx - pp.tx;\n            y = cwy - pp.ty;\n            let dx = (x * d - y * b) * id - px, dy = (y * a - x * c) * id - py;\n            let l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1 = 0, a2 = 0;\n            outer:\n                if (u) {\n                    l2 *= psx;\n                    let cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n                    if (cos < -1)\n                        cos = -1;\n                    else if (cos > 1) cos = 1;\n                    a2 = Math.acos(cos) * bendDir;\n                    a = l1 + l2 * cos;\n                    b = l2 * Math.sin(a2);\n                    a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n                } else {\n                    a = psx * l2;\n                    b = psy * l2;\n                    let aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);\n                    c = bb * l1 * l1 + aa * dd - aa * bb;\n                    let c1 = -2 * bb * l1, c2 = bb - aa;\n                    d = c1 * c1 - 4 * c2 * c;\n                    if (d >= 0) {\n                        let q = Math.sqrt(d);\n                        if (c1 < 0) q = -q;\n                        q = -(c1 + q) / 2;\n                        let r0 = q / c2, r1 = c / q;\n                        let r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                        if (r * r <= dd) {\n                            y = Math.sqrt(dd - r * r) * bendDir;\n                            a1 = ta - Math.atan2(y, r);\n                            a2 = Math.atan2(y / psy, (r - l1) / psx);\n                            break outer;\n                        }\n                    }\n                    let minAngle = MathUtils.PI, minX = l1 - a, minDist = minX * minX, minY = 0;\n                    let maxAngle = 0, maxX = l1 + a, maxDist = maxX * maxX, maxY = 0;\n                    c = -a * l1 / (aa - bb);\n                    if (c >= -1 && c <= 1) {\n                        c = Math.acos(c);\n                        x = a * Math.cos(c) + l1;\n                        y = b * Math.sin(c);\n                        d = x * x + y * y;\n                        if (d < minDist) {\n                            minAngle = c;\n                            minDist = d;\n                            minX = x;\n                            minY = y;\n                        }\n                        if (d > maxDist) {\n                            maxAngle = c;\n                            maxDist = d;\n                            maxX = x;\n                            maxY = y;\n                        }\n                    }\n                    if (dd <= (minDist + maxDist) / 2) {\n                        a1 = ta - Math.atan2(minY * bendDir, minX);\n                        a2 = minAngle * bendDir;\n                    } else {\n                        a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                        a2 = maxAngle * bendDir;\n                    }\n                }\n            let os = Math.atan2(cy, cx) * s2;\n            let rotation = parent.arotation;\n            a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n            if (a1 > 180)\n                a1 -= 360;\n            else if (a1 < -180) a1 += 360;\n            parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, parent.ascaleX, parent.ascaleY, 0, 0);\n            rotation = child.arotation;\n            a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n            if (a2 > 180)\n                a2 -= 360;\n            else if (a2 < -180) a2 += 360;\n            child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class IkConstraintData {\n        name: string;\n        order = 0;\n        bones = new Array<BoneData>();\n        target: BoneData;\n        bendDirection = 1;\n        mix = 1;\n\n        constructor(name: string) {\n            this.name = name;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class PathConstraint implements Constraint {\n        static NONE = -1; static BEFORE = -2; static AFTER = -3;\n\n        data: PathConstraintData;\n        bones: Array<Bone>;\n        target: Slot;\n        position = 0; spacing = 0; rotateMix = 0; translateMix = 0;\n\n        spaces = new Array<number>(); positions = new Array<number>();\n        world = new Array<number>(); curves = new Array<number>(); lengths = new Array<number>();\n        segments = new Array<number>();\n\n        constructor (data: PathConstraintData, skeleton: Skeleton) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.bones = new Array<Bone>();\n            for (let i = 0, n = data.bones.length; i < n; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findSlot(data.target.name);\n            this.position = data.position;\n            this.spacing = data.spacing;\n            this.rotateMix = data.rotateMix;\n            this.translateMix = data.translateMix;\n        }\n\n        apply () {\n            this.update();\n        }\n\n        update () {\n            let attachment = this.target.getAttachment();\n            if (!(attachment instanceof PathAttachment)) return;\n\n            let rotateMix = this.rotateMix, translateMix = this.translateMix;\n            let translate = translateMix > 0, rotate = rotateMix > 0;\n            if (!translate && !rotate) return;\n\n            let data = this.data;\n            let spacingMode = data.spacingMode;\n            let lengthSpacing = spacingMode == SpacingMode.Length;\n            let rotateMode = data.rotateMode;\n            let tangents = rotateMode == RotateMode.Tangent, scale = rotateMode == RotateMode.ChainScale;\n            let boneCount = this.bones.length, spacesCount = tangents ? boneCount : boneCount + 1;\n            let bones = this.bones;\n            let spaces = Utils.setArraySize(this.spaces, spacesCount), lengths: Array<number> = null;\n            let spacing = this.spacing;\n            if (scale || lengthSpacing) {\n                if (scale) lengths = Utils.setArraySize(this.lengths, boneCount);\n                for (let i = 0, n = spacesCount - 1; i < n;) {\n                    let bone = bones[i];\n                    let setupLength = bone.data.length, x = setupLength * bone.matrix.a, y = setupLength * bone.matrix.b;\n                    let length = Math.sqrt(x * x + y * y);\n                    if (scale) lengths[i] = length;\n                    spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n                }\n            } else {\n                for (let i = 1; i < spacesCount; i++)\n                    spaces[i] = spacing;\n            }\n\n            let positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents,\n                data.positionMode == PositionMode.Percent, spacingMode == SpacingMode.Percent);\n            let boneX = positions[0], boneY = positions[1], offsetRotation = data.offsetRotation;\n            let tip = false;\n            if (offsetRotation == 0)\n                tip = rotateMode == RotateMode.Chain;\n            else {\n                tip = false;\n                let p = this.target.bone.matrix;\n                offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n            }\n            for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n                let bone = bones[i];\n                let mat = bone.matrix;\n                mat.tx += (boneX - mat.tx) * translateMix;\n                mat.ty += (boneY - mat.ty) * translateMix;\n                let x = positions[p], y = positions[p + 1], dx = x - boneX, dy = y - boneY;\n                if (scale) {\n                    let length = lengths[i];\n                    if (length != 0) {\n                        let s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * rotateMix + 1;\n                        mat.a *= s;\n                        mat.b *= s;\n                    }\n                }\n                boneX = x;\n                boneY = y;\n                if (rotate) {\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d, r = 0, cos = 0, sin = 0;\n                    if (tangents)\n                        r = positions[p - 1];\n                    else if (spaces[i + 1] == 0)\n                        r = positions[p + 2];\n                    else\n                        r = Math.atan2(dy, dx);\n                    r -= Math.atan2(c, a);\n                    if (tip) {\n                        cos = Math.cos(r);\n                        sin = Math.sin(r);\n                        let length = bone.data.length;\n                        boneX += (length * (cos * a - sin * c) - dx) * rotateMix;\n                        boneY += (length * (sin * a + cos * c) - dy) * rotateMix;\n                    } else {\n                        r += offsetRotation;\n                    }\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI) //\n                        r += MathUtils.PI2;\n                    r *= rotateMix;\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    mat.a = cos * a - sin * c;\n                    mat.c = cos * b - sin * d;\n                    mat.b = sin * a + cos * c;\n                    mat.d = sin * b + cos * d;\n                }\n                bone.appliedValid = false;\n            }\n        }\n\n        computeWorldPositions (path: PathAttachment, spacesCount: number, tangents: boolean, percentPosition: boolean,\n                               percentSpacing: boolean) {\n            let target = this.target;\n            let position = this.position;\n            let spaces = this.spaces, out = Utils.setArraySize(this.positions, spacesCount * 3 + 2), world: Array<number> = null;\n            let closed = path.closed;\n            let verticesLength = path.worldVerticesLength, curveCount = verticesLength / 6, prevCurve = PathConstraint.NONE;\n\n            if (!path.constantSpeed) {\n                let lengths = path.lengths;\n                curveCount -= closed ? 1 : 2;\n                let pathLength = lengths[curveCount];\n                if (percentPosition) position *= pathLength;\n                if (percentSpacing) {\n                    for (let i = 0; i < spacesCount; i++)\n                        spaces[i] *= pathLength;\n                }\n                world = Utils.setArraySize(this.world, 8);\n                for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                    let space = spaces[i];\n                    position += space;\n                    let p = position;\n\n                    if (closed) {\n                        p %= pathLength;\n                        if (p < 0) p += pathLength;\n                        curve = 0;\n                    } else if (p < 0) {\n                        if (prevCurve != PathConstraint.BEFORE) {\n                            prevCurve = PathConstraint.BEFORE;\n                            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                        }\n                        this.addBeforePosition(p, world, 0, out, o);\n                        continue;\n                    } else if (p > pathLength) {\n                        if (prevCurve != PathConstraint.AFTER) {\n                            prevCurve = PathConstraint.AFTER;\n                            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                        }\n                        this.addAfterPosition(p - pathLength, world, 0, out, o);\n                        continue;\n                    }\n\n                    // Determine curve containing position.\n                    for (;; curve++) {\n                        let length = lengths[curve];\n                        if (p > length) continue;\n                        if (curve == 0)\n                            p /= length;\n                        else {\n                            let prev = lengths[curve - 1];\n                            p = (p - prev) / (length - prev);\n                        }\n                        break;\n                    }\n                    if (curve != prevCurve) {\n                        prevCurve = curve;\n                        if (closed && curve == curveCount) {\n                            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                        } else\n                            path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                    }\n                    this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o,\n                        tangents || (i > 0 && space == 0));\n                }\n                return out;\n            }\n\n            // World vertices.\n            if (closed) {\n                verticesLength += 2;\n                world = Utils.setArraySize(this.world, verticesLength);\n                path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n                path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n                world[verticesLength - 2] = world[0];\n                world[verticesLength - 1] = world[1];\n            } else {\n                curveCount--;\n                verticesLength -= 4;\n                world = Utils.setArraySize(this.world, verticesLength);\n                path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n            }\n\n            // Curve lengths.\n            let curves = Utils.setArraySize(this.curves, curveCount);\n            let pathLength = 0;\n            let x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;\n            let tmpx = 0, tmpy = 0, dddfx = 0, dddfy = 0, ddfx = 0, ddfy = 0, dfx = 0, dfy = 0;\n            for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n                cx1 = world[w];\n                cy1 = world[w + 1];\n                cx2 = world[w + 2];\n                cy2 = world[w + 3];\n                x2 = world[w + 4];\n                y2 = world[w + 5];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx;\n                dfy += ddfy;\n                ddfx += dddfx;\n                ddfy += dddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx;\n                dfy += ddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                curves[i] = pathLength;\n                x1 = x2;\n                y1 = y2;\n            }\n            if (percentPosition) position *= pathLength;\n            if (percentSpacing) {\n                for (let i = 0; i < spacesCount; i++)\n                    spaces[i] *= pathLength;\n            }\n\n            let segments = this.segments;\n            let curveLength = 0;\n            for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n                let space = spaces[i];\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (;; curve++) {\n                    let length = curves[curve];\n                    if (p > length) continue;\n                    if (curve == 0)\n                        p /= length;\n                    else {\n                        let prev = curves[curve - 1];\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n\n                // Curve segment lengths.\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    let ii = curve * 6;\n                    x1 = world[ii];\n                    y1 = world[ii + 1];\n                    cx1 = world[ii + 2];\n                    cy1 = world[ii + 3];\n                    cx2 = world[ii + 4];\n                    cy2 = world[ii + 5];\n                    x2 = world[ii + 6];\n                    y2 = world[ii + 7];\n                    tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                    tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                    dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                    dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                    ddfx = tmpx * 2 + dddfx;\n                    ddfy = tmpy * 2 + dddfy;\n                    dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                    dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                    curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[0] = curveLength;\n                    for (ii = 1; ii < 8; ii++) {\n                        dfx += ddfx;\n                        dfy += ddfy;\n                        ddfx += dddfx;\n                        ddfy += dddfy;\n                        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                        segments[ii] = curveLength;\n                    }\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[8] = curveLength;\n                    dfx += ddfx + dddfx;\n                    dfy += ddfy + dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[9] = curveLength;\n                    segment = 0;\n                }\n\n                // Weight by segment length.\n                p *= curveLength;\n                for (;; segment++) {\n                    let length = segments[segment];\n                    if (p > length) continue;\n                    if (segment == 0)\n                        p /= length;\n                    else {\n                        let prev = segments[segment - 1];\n                        p = segment + (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n            }\n            return out;\n        }\n\n        addBeforePosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n            let x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);\n            out[o] = x1 + p * Math.cos(r);\n            out[o + 1] = y1 + p * Math.sin(r);\n            out[o + 2] = r;\n        }\n\n        addAfterPosition (p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n            let x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);\n            out[o] = x1 + p * Math.cos(r);\n            out[o + 1] = y1 + p * Math.sin(r);\n            out[o + 2] = r;\n        }\n\n        addCurvePosition (p: number, x1: number, y1: number, cx1: number, cy1: number, cx2: number, cy2: number, x2: number, y2: number,\n                          out: Array<number>, o: number, tangents: boolean) {\n            if (p == 0 || isNaN(p)) p = 0.0001;\n            let tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;\n            let ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;\n            let x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n            out[o] = x;\n            out[o + 1] = y;\n            if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n        }\n\n        getOrder () {\n            return this.data.order;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class PathConstraintData {\n        name: string;\n        order = 0;\n        bones = new Array<BoneData>();\n        target: SlotData;\n        positionMode: PositionMode;\n        spacingMode: SpacingMode;\n        rotateMode: RotateMode;\n        offsetRotation: number;\n        position: number;\n        spacing: number;\n        rotateMix: number;\n        translateMix: number;\n\n        constructor(name: string) {\n            this.name = name;\n        }\n    }\n\n    export enum PositionMode {\n        Fixed, Percent\n    }\n\n    export enum SpacingMode {\n        Length, Fixed, Percent\n    }\n\n    export enum RotateMode {\n        Tangent, Chain, ChainScale\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Skeleton {\n        data: SkeletonData;\n        bones: Array<Bone>;\n        slots: Array<Slot>;\n        drawOrder: Array<Slot>;\n        ikConstraints: Array<IkConstraint>;\n        transformConstraints: Array<TransformConstraint>;\n        pathConstraints: Array<PathConstraint>;\n        _updateCache = new Array<Updatable>();\n        updateCacheReset = new Array<Updatable>();\n        skin: Skin;\n        color: Color;\n        time = 0;\n        flipX = false; flipY = false;\n        x = 0; y = 0;\n\n        constructor (data: SkeletonData) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            this.data = data;\n\n            this.bones = new Array<Bone>();\n            for (let i = 0; i < data.bones.length; i++) {\n                let boneData = data.bones[i];\n                let bone: Bone;\n                if (boneData.parent == null)\n                    bone = new Bone(boneData, this, null);\n                else {\n                    let parent = this.bones[boneData.parent.index];\n                    bone = new Bone(boneData, this, parent);\n                    parent.children.push(bone);\n                }\n                this.bones.push(bone);\n            }\n\n            this.slots = new Array<Slot>();\n            this.drawOrder = new Array<Slot>();\n            for (let i = 0; i < data.slots.length; i++) {\n                let slotData = data.slots[i];\n                let bone = this.bones[slotData.boneData.index];\n                let slot = new Slot(slotData, bone);\n                this.slots.push(slot);\n                this.drawOrder.push(slot);\n            }\n\n            this.ikConstraints = new Array<IkConstraint>();\n            for (let i = 0; i < data.ikConstraints.length; i++) {\n                let ikConstraintData = data.ikConstraints[i];\n                this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n            }\n\n            this.transformConstraints = new Array<TransformConstraint>();\n            for (let i = 0; i < data.transformConstraints.length; i++) {\n                let transformConstraintData = data.transformConstraints[i];\n                this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n            }\n\n            this.pathConstraints = new Array<PathConstraint>();\n            for (let i = 0; i < data.pathConstraints.length; i++) {\n                let pathConstraintData = data.pathConstraints[i];\n                this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n            }\n\n            this.color = new Color(1, 1, 1, 1);\n            this.updateCache();\n        }\n\n        updateCache () {\n            let updateCache = this._updateCache;\n            updateCache.length = 0;\n            this.updateCacheReset.length = 0;\n\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++)\n                bones[i].sorted = false;\n\n            // IK first, lowest hierarchy depth first.\n            let ikConstraints = this.ikConstraints;\n            let transformConstraints = this.transformConstraints;\n            let pathConstraints = this.pathConstraints;\n            let ikCount = ikConstraints.length, transformCount = transformConstraints.length, pathCount = pathConstraints.length;\n            let constraintCount = ikCount + transformCount + pathCount;\n\n            outer:\n                for (let i = 0; i < constraintCount; i++) {\n                    for (let ii = 0; ii < ikCount; ii++) {\n                        let constraint = ikConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortIkConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                    for (let ii = 0; ii < transformCount; ii++) {\n                        let constraint = transformConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortTransformConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                    for (let ii = 0; ii < pathCount; ii++) {\n                        let constraint = pathConstraints[ii];\n                        if (constraint.data.order == i) {\n                            this.sortPathConstraint(constraint);\n                            continue outer;\n                        }\n                    }\n                }\n\n            for (let i = 0, n = bones.length; i < n; i++)\n                this.sortBone(bones[i]);\n        }\n\n        sortIkConstraint (constraint: IkConstraint) {\n            let target = constraint.target;\n            this.sortBone(target);\n\n            let constrained = constraint.bones;\n            let parent = constrained[0];\n            this.sortBone(parent);\n\n            if (constrained.length > 1) {\n                let child = constrained[constrained.length - 1];\n                if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n            }\n\n            this._updateCache.push(constraint);\n\n            this.sortReset(parent.children);\n            constrained[constrained.length - 1].sorted = true;\n        }\n\n        sortPathConstraint (constraint: PathConstraint) {\n            let slot = constraint.target;\n            let slotIndex = slot.data.index;\n            let slotBone = slot.bone;\n            if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n            if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin)\n                this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n            for (let i = 0, n = this.data.skins.length; i < n; i++)\n                this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n            let attachment = slot.getAttachment();\n            if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n            let constrained = constraint.bones;\n            let boneCount = constrained.length;\n            for (let i = 0; i < boneCount; i++)\n                this.sortBone(constrained[i]);\n\n            this._updateCache.push(constraint);\n\n            for (let i = 0; i < boneCount; i++)\n                this.sortReset(constrained[i].children);\n            for (let i = 0; i < boneCount; i++)\n                constrained[i].sorted = true;\n        }\n\n        sortTransformConstraint (constraint: TransformConstraint) {\n            this.sortBone(constraint.target);\n\n            let constrained = constraint.bones;\n            let boneCount = constrained.length;\n            if (constraint.data.local) {\n                for (let i = 0; i < boneCount; i++) {\n                    let child = constrained[i];\n                    this.sortBone(child.parent);\n                    if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n                }\n            } else {\n                for (let i = 0; i < boneCount; i++) {\n                    this.sortBone(constrained[i]);\n                }\n            }\n\n            this._updateCache.push(constraint);\n\n            for (let ii = 0; ii < boneCount; ii++)\n                this.sortReset(constrained[ii].children);\n            for (let ii = 0; ii < boneCount; ii++)\n                constrained[ii].sorted = true;\n        }\n\n        sortPathConstraintAttachment (skin: Skin, slotIndex: number, slotBone: Bone) {\n            let attachments = skin.attachments[slotIndex];\n            if (!attachments) return;\n            for (let key in attachments) {\n                this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n            }\n        }\n\n        sortPathConstraintAttachmentWith (attachment: Attachment, slotBone: Bone) {\n            if (!(attachment instanceof PathAttachment)) return;\n            let pathBones = (<PathAttachment>attachment).bones;\n            if (pathBones == null)\n                this.sortBone(slotBone);\n            else {\n                let bones = this.bones;\n                let i = 0;\n                while (i < pathBones.length) {\n                    let boneCount = pathBones[i++];\n                    for (let n = i + boneCount; i < n; i++) {\n                        let boneIndex = pathBones[i];\n                        this.sortBone(bones[boneIndex]);\n                    }\n                }\n            }\n        }\n\n        sortBone (bone: Bone) {\n            if (bone.sorted) return;\n            let parent = bone.parent;\n            if (parent != null) this.sortBone(parent);\n            bone.sorted = true;\n            this._updateCache.push(bone);\n        }\n\n        sortReset (bones: Array<Bone>) {\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (bone.sorted) this.sortReset(bone.children);\n                bone.sorted = false;\n            }\n        }\n\n        /** Updates the world transform for each bone and applies constraints. */\n        updateWorldTransform () {\n            let updateCacheReset = this.updateCacheReset;\n            for (let i = 0, n = updateCacheReset.length; i < n; i++) {\n                let bone = updateCacheReset[i] as Bone;\n                bone.ax = bone.x;\n                bone.ay = bone.y;\n                bone.arotation = bone.rotation;\n                bone.ascaleX = bone.scaleX;\n                bone.ascaleY = bone.scaleY;\n                bone.ashearX = bone.shearX;\n                bone.ashearY = bone.shearY;\n                bone.appliedValid = true;\n            }\n            let updateCache = this._updateCache;\n            for (let i = 0, n = updateCache.length; i < n; i++)\n                updateCache[i].update();\n        }\n\n        /** Sets the bones, constraints, and slots to their setup pose values. */\n        setToSetupPose () {\n            this.setBonesToSetupPose();\n            this.setSlotsToSetupPose();\n        }\n\n        /** Sets the bones and constraints to their setup pose values. */\n        setBonesToSetupPose () {\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++)\n                bones[i].setToSetupPose();\n\n            let ikConstraints = this.ikConstraints;\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\n                let constraint = ikConstraints[i];\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.mix = constraint.data.mix;\n            }\n\n            let transformConstraints = this.transformConstraints;\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\n                let constraint = transformConstraints[i];\n                let data = constraint.data;\n                constraint.rotateMix = data.rotateMix;\n                constraint.translateMix = data.translateMix;\n                constraint.scaleMix = data.scaleMix;\n                constraint.shearMix = data.shearMix;\n            }\n\n            let pathConstraints = this.pathConstraints;\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\n                let constraint = pathConstraints[i];\n                let data = constraint.data;\n                constraint.position = data.position;\n                constraint.spacing = data.spacing;\n                constraint.rotateMix = data.rotateMix;\n                constraint.translateMix = data.translateMix;\n            }\n        }\n\n        setSlotsToSetupPose () {\n            let slots = this.slots;\n            Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n            for (let i = 0, n = slots.length; i < n; i++)\n                slots[i].setToSetupPose();\n        }\n\n        /** @return May return null. */\n        getRootBone () {\n            if (this.bones.length == 0) return null;\n            return this.bones[0];\n        }\n\n        /** @return May be null. */\n        findBone (boneName: string) {\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (bone.data.name == boneName) return bone;\n            }\n            return null;\n        }\n\n        /** @return -1 if the bone was not found. */\n        findBoneIndex (boneName: string) {\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++)\n                if (bones[i].data.name == boneName) return i;\n            return -1;\n        }\n\n        /** @return May be null. */\n        findSlot (slotName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++) {\n                let slot = slots[i];\n                if (slot.data.name == slotName) return slot;\n            }\n            return null;\n        }\n\n        /** @return -1 if the bone was not found. */\n        findSlotIndex (slotName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++)\n                if (slots[i].data.name == slotName) return i;\n            return -1;\n        }\n\n        /** Sets a skin by name.\n         * @see #setSkin(Skin) */\n        setSkinByName (skinName: string) {\n            let skin = this.data.findSkin(skinName);\n            if (skin == null) throw new Error(\"Skin not found: \" + skinName);\n            this.setSkin(skin);\n        }\n\n        /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n         * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n         * old skin, each slot's setup mode attachment is attached from the new skin.\n         * @param newSkin May be null. */\n        setSkin (newSkin: Skin) {\n            if (newSkin != null) {\n                if (this.skin != null)\n                    newSkin.attachAll(this, this.skin);\n                else {\n                    let slots = this.slots;\n                    for (let i = 0, n = slots.length; i < n; i++) {\n                        let slot = slots[i];\n                        let name = slot.data.attachmentName;\n                        if (name != null) {\n                            let attachment: Attachment = newSkin.getAttachment(i, name);\n                            if (attachment != null) slot.setAttachment(attachment);\n                        }\n                    }\n                }\n            }\n            this.skin = newSkin;\n        }\n\n        /** @return May be null. */\n        getAttachmentByName (slotName: string, attachmentName: string): Attachment {\n            return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n        }\n\n        /** @return May be null. */\n        getAttachment (slotIndex: number, attachmentName: string): Attachment {\n            if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\n            if (this.skin != null) {\n                let attachment: Attachment = this.skin.getAttachment(slotIndex, attachmentName);\n                if (attachment != null) return attachment;\n            }\n            if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n            return null;\n        }\n\n        /** @param attachmentName May be null. */\n        setAttachment (slotName: string, attachmentName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++) {\n                let slot = slots[i];\n                if (slot.data.name == slotName) {\n                    let attachment: Attachment = null;\n                    if (attachmentName != null) {\n                        attachment = this.getAttachment(i, attachmentName);\n                        if (attachment == null)\n                            throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n                    }\n                    slot.setAttachment(attachment);\n                    return;\n                }\n            }\n            throw new Error(\"Slot not found: \" + slotName);\n        }\n\n        /** @return May be null. */\n        findIkConstraint (constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let ikConstraints = this.ikConstraints;\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\n                let ikConstraint = ikConstraints[i];\n                if (ikConstraint.data.name == constraintName) return ikConstraint;\n            }\n            return null;\n        }\n\n        /** @return May be null. */\n        findTransformConstraint (constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let transformConstraints = this.transformConstraints;\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\n                let constraint = transformConstraints[i];\n                if (constraint.data.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        /** @return May be null. */\n        findPathConstraint (constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let pathConstraints = this.pathConstraints;\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\n                let constraint = pathConstraints[i];\n                if (constraint.data.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n         * @param offset The distance from the skeleton origin to the bottom left corner of the AABB.\n         * @param size The width and height of the AABB.\n         * @param temp Working memory */\n        getBounds (offset: Vector2, size: Vector2, temp: Array<number>) {\n            if (offset == null) throw new Error(\"offset cannot be null.\");\n            if (size == null) throw new Error(\"size cannot be null.\");\n            let drawOrder = this.drawOrder;\n            let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n            for (let i = 0, n = drawOrder.length; i < n; i++) {\n                let slot = drawOrder[i];\n                let verticesLength = 0;\n                let vertices: ArrayLike<number> = null;\n                let attachment = slot.getAttachment();\n                if (attachment instanceof RegionAttachment) {\n                    verticesLength = 8;\n                    vertices = Utils.setArraySize(temp, verticesLength, 0);\n                    (<RegionAttachment>attachment).computeWorldVertices(slot.bone, vertices, 0, 2);\n                }else if (attachment instanceof MeshAttachment) {\n                    let mesh = (<MeshAttachment>attachment);\n                    verticesLength = mesh.worldVerticesLength;\n                    vertices = Utils.setArraySize(temp, verticesLength, 0);\n                    mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n                }\n                if (vertices != null) {\n                    for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                        let x = vertices[ii], y = vertices[ii + 1];\n                        minX = Math.min(minX, x);\n                        minY = Math.min(minY, y);\n                        maxX = Math.max(maxX, x);\n                        maxY = Math.max(maxY, y);\n                    }\n                }\n            }\n            offset.set(minX, minY);\n            size.set(maxX - minX, maxY - minY);\n        }\n\n        update (delta: number) {\n            this.time += delta;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class SkeletonBounds {\n        minX = 0; minY = 0; maxX = 0; maxY = 0;\n        boundingBoxes = new Array<BoundingBoxAttachment>();\n        polygons = new Array<ArrayLike<number>>();\n        private polygonPool = new Pool<ArrayLike<number>>(() => {\n            return Utils.newFloatArray(16);\n        });\n\n        update (skeleton: Skeleton, updateAabb: boolean) {\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            let boundingBoxes = this.boundingBoxes;\n            let polygons = this.polygons;\n            let polygonPool = this.polygonPool;\n            let slots = skeleton.slots;\n            let slotCount = slots.length;\n\n            boundingBoxes.length = 0;\n            polygonPool.freeAll(polygons);\n            polygons.length = 0;\n\n            for (let i = 0; i < slotCount; i++) {\n                let slot = slots[i];\n                let attachment = slot.getAttachment();\n                if (attachment instanceof BoundingBoxAttachment) {\n                    let boundingBox = attachment as BoundingBoxAttachment;\n                    boundingBoxes.push(boundingBox);\n\n                    let polygon = polygonPool.obtain();\n                    if (polygon.length != boundingBox.worldVerticesLength) {\n                        polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n                    }\n                    polygons.push(polygon);\n                    boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n                }\n            }\n\n            if (updateAabb) {\n                this.aabbCompute();\n            } else {\n                this.minX = Number.POSITIVE_INFINITY;\n                this.minY = Number.POSITIVE_INFINITY;\n                this.maxX = Number.NEGATIVE_INFINITY;\n                this.maxY = Number.NEGATIVE_INFINITY;\n            }\n        }\n\n        aabbCompute () {\n            let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;\n            let polygons = this.polygons;\n            for (let i = 0, n = polygons.length; i < n; i++) {\n                let polygon = polygons[i];\n                let vertices = polygon;\n                for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                    let x = vertices[ii];\n                    let y = vertices[ii + 1];\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n            this.minX = minX;\n            this.minY = minY;\n            this.maxX = maxX;\n            this.maxY = maxY;\n        }\n\n        /** Returns true if the axis aligned bounding box contains the point. */\n        aabbContainsPoint (x: number, y: number) {\n            return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n        }\n\n        /** Returns true if the axis aligned bounding box intersects the line segment. */\n        aabbIntersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n            let minX = this.minX;\n            let minY = this.minY;\n            let maxX = this.maxX;\n            let maxY = this.maxY;\n            if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n                return false;\n            let m = (y2 - y1) / (x2 - x1);\n            let y = m * (minX - x1) + y1;\n            if (y > minY && y < maxY) return true;\n            y = m * (maxX - x1) + y1;\n            if (y > minY && y < maxY) return true;\n            let x = (minY - y1) / m + x1;\n            if (x > minX && x < maxX) return true;\n            x = (maxY - y1) / m + x1;\n            if (x > minX && x < maxX) return true;\n            return false;\n        }\n\n        /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n        aabbIntersectsSkeleton (bounds: SkeletonBounds) {\n            return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n        }\n\n        /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n         * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n        containsPoint (x: number, y: number): BoundingBoxAttachment {\n            let polygons = this.polygons;\n            for (let i = 0, n = polygons.length; i < n; i++)\n                if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n            return null;\n        }\n\n        /** Returns true if the polygon contains the point. */\n        containsPointPolygon (polygon: ArrayLike<number>, x: number, y: number) {\n            let vertices = polygon;\n            let nn = polygon.length;\n\n            let prevIndex = nn - 2;\n            let inside = false;\n            for (let ii = 0; ii < nn; ii += 2) {\n                let vertexY = vertices[ii + 1];\n                let prevY = vertices[prevIndex + 1];\n                if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n                    let vertexX = vertices[ii];\n                    if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n                }\n                prevIndex = ii;\n            }\n            return inside;\n        }\n\n        /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n         * is usually more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns\n         * true. */\n        intersectsSegment (x1: number, y1: number, x2: number, y2: number) {\n            let polygons = this.polygons;\n            for (let i = 0, n = polygons.length; i < n; i++)\n                if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n            return null;\n        }\n\n        /** Returns true if the polygon contains any part of the line segment. */\n        intersectsSegmentPolygon (polygon: ArrayLike<number>, x1: number, y1: number, x2: number, y2: number) {\n            let vertices = polygon;\n            let nn = polygon.length;\n\n            let width12 = x1 - x2, height12 = y1 - y2;\n            let det1 = x1 * y2 - y1 * x2;\n            let x3 = vertices[nn - 2], y3 = vertices[nn - 1];\n            for (let ii = 0; ii < nn; ii += 2) {\n                let x4 = vertices[ii], y4 = vertices[ii + 1];\n                let det2 = x3 * y4 - y3 * x4;\n                let width34 = x3 - x4, height34 = y3 - y4;\n                let det3 = width12 * height34 - height12 * width34;\n                let x = (det1 * width34 - width12 * det2) / det3;\n                if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n                    let y = (det1 * height34 - height12 * det2) / det3;\n                    if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n                }\n                x3 = x4;\n                y3 = y4;\n            }\n            return false;\n        }\n\n        /** Returns the polygon for the specified bounding box, or null. */\n        getPolygon (boundingBox: BoundingBoxAttachment) {\n            if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\n            let index = this.boundingBoxes.indexOf(boundingBox);\n            return index == -1 ? null : this.polygons[index];\n        }\n\n        getWidth () {\n            return this.maxX - this.minX;\n        }\n\n        getHeight () {\n            return this.maxY - this.minY;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport class SkeletonClipping {\n\t\tprivate triangulator = new Triangulator();\n\t\tprivate clippingPolygon = new Array<number>();\n\t\tprivate clipOutput = new Array<number>();\n\t\tclippedVertices = new Array<number>();\n\t\tclippedTriangles = new Array<number>();\n\t\tprivate scratch = new Array<number>();\n\n\t\tprivate clipAttachment: ClippingAttachment;\n\t\tprivate clippingPolygons: Array<Array<number>>;\n\n\t\tclipStart (slot: Slot, clip: ClippingAttachment): number {\n\t\t\tif (this.clipAttachment != null) return 0;\n\t\t\tthis.clipAttachment = clip;\n\n\t\t\tlet n = clip.worldVerticesLength;\n\t\t\tlet vertices = Utils.setArraySize(this.clippingPolygon, n);\n\t\t\tclip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n\t\t\tlet clippingPolygon = this.clippingPolygon;\n\t\t\tSkeletonClipping.makeClockwise(clippingPolygon);\n\t\t\tlet clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n\t\t\tfor (let i = 0, n = clippingPolygons.length; i < n; i++) {\n\t\t\t\tlet polygon = clippingPolygons[i];\n\t\t\t\tSkeletonClipping.makeClockwise(polygon);\n\t\t\t\tpolygon.push(polygon[0]);\n\t\t\t\tpolygon.push(polygon[1]);\n\t\t\t}\n\n\t\t\treturn clippingPolygons.length;\n\t\t}\n\n\t\tclipEndWithSlot (slot: Slot) {\n\t\t\tif (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd();\n\t\t}\n\n\t\tclipEnd () {\n\t\t\tif (this.clipAttachment == null) return;\n\t\t\tthis.clipAttachment = null;\n\t\t\tthis.clippingPolygons = null;\n\t\t\tthis.clippedVertices.length = 0;\n\t\t\tthis.clippedTriangles.length = 0;\n\t\t\tthis.clippingPolygon.length = 0;\n\t\t}\n\n\t\tisClipping (): boolean {\n\t\t\treturn this.clipAttachment != null;\n\t\t}\n\n\t\tclipTriangles (vertices: ArrayLike<number>, verticesLength: number, triangles: ArrayLike<number>, trianglesLength: number, uvs: ArrayLike<number>,\n\t\t\tlight: Color, dark: Color, twoColor: boolean) {\n\n\t\t\tlet clipOutput = this.clipOutput, clippedVertices = this.clippedVertices;\n\t\t\tlet clippedTriangles = this.clippedTriangles;\n\t\t\tlet polygons = this.clippingPolygons;\n\t\t\tlet polygonsCount = this.clippingPolygons.length;\n\t\t\tlet vertexSize = twoColor ? 12 : 8;\n\n\t\t\tlet index = 0;\n\t\t\tclippedVertices.length = 0;\n\t\t\tclippedTriangles.length = 0;\n\t\t\touter:\n\t\t\tfor (let i = 0; i < trianglesLength; i += 3) {\n\t\t\t\tlet vertexOffset = triangles[i] << 1;\n\t\t\t\tlet x1 = vertices[vertexOffset], y1 = vertices[vertexOffset + 1];\n\t\t\t\tlet u1 = uvs[vertexOffset], v1 = uvs[vertexOffset + 1];\n\n\t\t\t\tvertexOffset = triangles[i + 1] << 1;\n\t\t\t\tlet x2 = vertices[vertexOffset], y2 = vertices[vertexOffset + 1];\n\t\t\t\tlet u2 = uvs[vertexOffset], v2 = uvs[vertexOffset + 1];\n\n\t\t\t\tvertexOffset = triangles[i + 2] << 1;\n\t\t\t\tlet x3 = vertices[vertexOffset], y3 = vertices[vertexOffset + 1];\n\t\t\t\tlet u3 = uvs[vertexOffset], v3 = uvs[vertexOffset + 1];\n\n\t\t\t\tfor (let p = 0; p < polygonsCount; p++) {\n\t\t\t\t\tlet s = clippedVertices.length;\n\t\t\t\t\tif (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n\t\t\t\t\t\tlet clipOutputLength = clipOutput.length;\n\t\t\t\t\t\tif (clipOutputLength == 0) continue;\n\t\t\t\t\t\tlet d0 = y2 - y3, d1 = x3 - x2, d2 = x1 - x3, d4 = y3 - y1;\n\t\t\t\t\t\tlet d = 1 / (d0 * d2 + d1 * (y1 - y3));\n\n\t\t\t\t\t\tlet clipOutputCount = clipOutputLength >> 1;\n\t\t\t\t\t\tlet clipOutputItems = this.clipOutput;\n\t\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n\t\t\t\t\t\tfor (let ii = 0; ii < clipOutputLength; ii += 2) {\n\t\t\t\t\t\t\tlet x = clipOutputItems[ii], y = clipOutputItems[ii + 1];\n\t\t\t\t\t\t\tclippedVerticesItems[s] = x;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 1] = y;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\t\t\tlet c0 = x - x3, c1 = y - y3;\n\t\t\t\t\t\t\tlet a = (d0 * c0 + d1 * c1) * d;\n\t\t\t\t\t\t\tlet b = (d4 * c0 + d2 * c1) * d;\n\t\t\t\t\t\t\tlet c = 1 - a - b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n\t\t\t\t\t\t\tif (twoColor) {\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts += vertexSize;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n\t\t\t\t\t\tclipOutputCount--;\n\t\t\t\t\t\tfor (let ii = 1; ii < clipOutputCount; ii++) {\n\t\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + ii);\n\t\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + ii + 1);\n\t\t\t\t\t\t\ts += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tindex += clipOutputCount + 1;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet clippedVerticesItems = Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n\t\t\t\t\t\tclippedVerticesItems[s] = x1;\n\t\t\t\t\t\tclippedVerticesItems[s + 1] = y1;\n\t\t\t\t\t\tclippedVerticesItems[s + 2] = light.r;\n\t\t\t\t\t\tclippedVerticesItems[s + 3] = light.g;\n\t\t\t\t\t\tclippedVerticesItems[s + 4] = light.b;\n\t\t\t\t\t\tclippedVerticesItems[s + 5] = light.a;\n\t\t\t\t\t\tif (!twoColor) {\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = x2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = y2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = u2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = v2;\n\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = x3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = y3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = u3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = v3;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclippedVerticesItems[s + 6] = u1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 7] = v1;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 8] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 9] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 10] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 11] = dark.a;\n\n\t\t\t\t\t\t\tclippedVerticesItems[s + 12] = x2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 13] = y2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 14] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 15] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 16] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 17] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 18] = u2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 19] = v2;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 20] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 21] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 22] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 23] = dark.a;\n\n\t\t\t\t\t\t\tclippedVerticesItems[s + 24] = x3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 25] = y3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 26] = light.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 27] = light.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 28] = light.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 29] = light.a;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 30] = u3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 31] = v3;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 32] = dark.r;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 33] = dark.g;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 34] = dark.b;\n\t\t\t\t\t\t\tclippedVerticesItems[s + 35] = dark.a;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts = clippedTriangles.length;\n\t\t\t\t\t\tlet clippedTrianglesItems = Utils.setArraySize(clippedTriangles, s + 3);\n\t\t\t\t\t\tclippedTrianglesItems[s] = index;\n\t\t\t\t\t\tclippedTrianglesItems[s + 1] = (index + 1);\n\t\t\t\t\t\tclippedTrianglesItems[s + 2] = (index + 2);\n\t\t\t\t\t\tindex += 3;\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** Clips the input triangle against the convex, clockwise clipping area. If the triangle lies entirely within the clipping\n\t\t * area, false is returned. The clipping area must duplicate the first vertex at the end of the vertices list. */\n\t\tclip (x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, clippingArea: Array<number>, output: Array<number>) {\n\t\t\tlet originalOutput = output;\n\t\t\tlet clipped = false;\n\n\t\t\t// Avoid copy at the end.\n\t\t\tlet input: Array<number> = null;\n\t\t\tif (clippingArea.length % 4 >= 2) {\n\t\t\t\tinput = output;\n\t\t\t\toutput = this.scratch;\n\t\t\t} else\n\t\t\t\tinput = this.scratch;\n\n\t\t\tinput.length = 0;\n\t\t\tinput.push(x1);\n\t\t\tinput.push(y1);\n\t\t\tinput.push(x2);\n\t\t\tinput.push(y2);\n\t\t\tinput.push(x3);\n\t\t\tinput.push(y3);\n\t\t\tinput.push(x1);\n\t\t\tinput.push(y1);\n\t\t\toutput.length = 0;\n\n\t\t\tlet clippingVertices = clippingArea;\n\t\t\tlet clippingVerticesLast = clippingArea.length - 4;\n\t\t\tfor (let i = 0;; i += 2) {\n\t\t\t\tlet edgeX = clippingVertices[i], edgeY = clippingVertices[i + 1];\n\t\t\t\tlet edgeX2 = clippingVertices[i + 2], edgeY2 = clippingVertices[i + 3];\n\t\t\t\tlet deltaX = edgeX - edgeX2, deltaY = edgeY - edgeY2;\n\n\t\t\t\tlet inputVertices = input;\n\t\t\t\tlet inputVerticesLength = input.length - 2, outputStart = output.length;\n\t\t\t\tfor (let ii = 0; ii < inputVerticesLength; ii += 2) {\n\t\t\t\t\tlet inputX = inputVertices[ii], inputY = inputVertices[ii + 1];\n\t\t\t\t\tlet inputX2 = inputVertices[ii + 2], inputY2 = inputVertices[ii + 3];\n\t\t\t\t\tlet side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n\t\t\t\t\tif (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n\t\t\t\t\t\tif (side2) { // v1 inside, v2 inside\n\t\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// v1 inside, v2 outside\n\t\t\t\t\t\tlet c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n\t\t\t\t\t\tlet ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\n\t\t\t\t\t} else if (side2) { // v1 outside, v2 inside\n\t\t\t\t\t\tlet c0 = inputY2 - inputY, c2 = inputX2 - inputX;\n\t\t\t\t\t\tlet ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n\t\t\t\t\t\toutput.push(edgeX + (edgeX2 - edgeX) * ua);\n\t\t\t\t\t\toutput.push(edgeY + (edgeY2 - edgeY) * ua);\n\t\t\t\t\t\toutput.push(inputX2);\n\t\t\t\t\t\toutput.push(inputY2);\n\t\t\t\t\t}\n\t\t\t\t\tclipped = true;\n\t\t\t\t}\n\n\t\t\t\tif (outputStart == output.length) { // All edges outside.\n\t\t\t\t\toriginalOutput.length = 0;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\toutput.push(output[0]);\n\t\t\t\toutput.push(output[1]);\n\n\t\t\t\tif (i == clippingVerticesLast) break;\n\t\t\t\tlet temp = output;\n\t\t\t\toutput = input;\n\t\t\t\toutput.length = 0;\n\t\t\t\tinput = temp;\n\t\t\t}\n\n\t\t\tif (originalOutput != output) {\n\t\t\t\toriginalOutput.length = 0;\n\t\t\t\tfor (let i = 0, n = output.length - 2; i < n; i++)\n\t\t\t\t\toriginalOutput[i] = output[i];\n\t\t\t} else\n\t\t\t\toriginalOutput.length = originalOutput.length - 2;\n\n\t\t\treturn clipped;\n\t\t}\n\n\t\tpublic static makeClockwise (polygon: ArrayLike<number>) {\n\t\t\tlet vertices = polygon;\n\t\t\tlet verticeslength = polygon.length;\n\n\t\t\tlet area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1], p1x = 0, p1y = 0, p2x = 0, p2y = 0;\n\t\t\tfor (let i = 0, n = verticeslength - 3; i < n; i += 2) {\n\t\t\t\tp1x = vertices[i];\n\t\t\t\tp1y = vertices[i + 1];\n\t\t\t\tp2x = vertices[i + 2];\n\t\t\t\tp2y = vertices[i + 3];\n\t\t\t\tarea += p1x * p2y - p2x * p1y;\n\t\t\t}\n\t\t\tif (area < 0) return;\n\n\t\t\tfor (let i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n\t\t\t\tlet x = vertices[i], y = vertices[i + 1];\n\t\t\t\tlet other = lastX - i;\n\t\t\t\tvertices[i] = vertices[other];\n\t\t\t\tvertices[i + 1] = vertices[other + 1];\n\t\t\t\tvertices[other] = x;\n\t\t\t\tvertices[other + 1] = y;\n\t\t\t}\n\t\t}\n\t}\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class SkeletonData {\n        name: string;\n        bones = new Array<BoneData>(); // Ordered parents first.\n        slots = new Array<SlotData>(); // Setup pose draw order.\n        skins = new Array<Skin>();\n        defaultSkin: Skin;\n        events = new Array<EventData>();\n        animations = new Array<Animation>();\n        ikConstraints = new Array<IkConstraintData>();\n        transformConstraints = new Array<TransformConstraintData>();\n        pathConstraints = new Array<PathConstraintData>();\n        width: number;\n        height: number;\n        version: string;\n        hash: string;\n\n        // Nonessential\n        fps = 0;\n        imagesPath: string;\n\n        findBone(boneName: string) {\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (bone.name == boneName) return bone;\n            }\n            return null;\n        }\n\n        findBoneIndex(boneName: string) {\n            if (boneName == null) throw new Error(\"boneName cannot be null.\");\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++)\n                if (bones[i].name == boneName) return i;\n            return -1;\n        }\n\n        findSlot(slotName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++) {\n                let slot = slots[i];\n                if (slot.name == slotName) return slot;\n            }\n            return null;\n        }\n\n        findSlotIndex(slotName: string) {\n            if (slotName == null) throw new Error(\"slotName cannot be null.\");\n            let slots = this.slots;\n            for (let i = 0, n = slots.length; i < n; i++)\n                if (slots[i].name == slotName) return i;\n            return -1;\n        }\n\n        findSkin(skinName: string) {\n            if (skinName == null) throw new Error(\"skinName cannot be null.\");\n            let skins = this.skins;\n            for (let i = 0, n = skins.length; i < n; i++) {\n                let skin = skins[i];\n                if (skin.name == skinName) return skin;\n            }\n            return null;\n        }\n\n        findEvent(eventDataName: string) {\n            if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\n            let events = this.events;\n            for (let i = 0, n = events.length; i < n; i++) {\n                let event = events[i];\n                if (event.name == eventDataName) return event;\n            }\n            return null;\n        }\n\n        findAnimation(animationName: string) {\n            if (animationName == null) throw new Error(\"animationName cannot be null.\");\n            let animations = this.animations;\n            for (let i = 0, n = animations.length; i < n; i++) {\n                let animation = animations[i];\n                if (animation.name == animationName) return animation;\n            }\n            return null;\n        }\n\n        findIkConstraint(constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let ikConstraints = this.ikConstraints;\n            for (let i = 0, n = ikConstraints.length; i < n; i++) {\n                let constraint = ikConstraints[i];\n                if (constraint.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        findTransformConstraint(constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let transformConstraints = this.transformConstraints;\n            for (let i = 0, n = transformConstraints.length; i < n; i++) {\n                let constraint = transformConstraints[i];\n                if (constraint.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        findPathConstraint(constraintName: string) {\n            if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n            let pathConstraints = this.pathConstraints;\n            for (let i = 0, n = pathConstraints.length; i < n; i++) {\n                let constraint = pathConstraints[i];\n                if (constraint.name == constraintName) return constraint;\n            }\n            return null;\n        }\n\n        findPathConstraintIndex(pathConstraintName: string) {\n            if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n            let pathConstraints = this.pathConstraints;\n            for (let i = 0, n = pathConstraints.length; i < n; i++)\n                if (pathConstraints[i].name == pathConstraintName) return i;\n            return -1;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class SkeletonJson {\n        attachmentLoader: AttachmentLoader;\n        scale = 1;\n        private linkedMeshes = new Array<LinkedMesh>();\n\n        constructor (attachmentLoader: AttachmentLoader) {\n            this.attachmentLoader = attachmentLoader;\n        }\n\n        readSkeletonData (json: string | any): SkeletonData {\n            let scale = this.scale;\n            let skeletonData = new SkeletonData();\n            let root = typeof(json) === \"string\" ? JSON.parse(json) : json;\n\n            // Skeleton\n            let skeletonMap = root.skeleton;\n            if (skeletonMap != null) {\n                skeletonData.hash = skeletonMap.hash;\n                skeletonData.version = skeletonMap.spine;\n                skeletonData.width = skeletonMap.width;\n                skeletonData.height = skeletonMap.height;\n                skeletonData.fps = skeletonMap.fps;\n                skeletonData.imagesPath = skeletonMap.images;\n            }\n\n            // Bones\n            if (root.bones) {\n                for (let i = 0; i < root.bones.length; i++) {\n                    let boneMap = root.bones[i];\n\n                    let parent: BoneData = null;\n                    let parentName: string = this.getValue(boneMap, \"parent\", null);\n                    if (parentName != null) {\n                        parent = skeletonData.findBone(parentName);\n                        if (parent == null) throw new Error(\"Parent bone not found: \" + parentName);\n                    }\n                    let data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n                    data.length = this.getValue(boneMap, \"length\", 0) * scale;\n                    data.x = this.getValue(boneMap, \"x\", 0) * scale;\n                    data.y = this.getValue(boneMap, \"y\", 0) * scale;\n                    data.rotation = this.getValue(boneMap, \"rotation\", 0);\n                    data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n                    data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n                    data.shearX = this.getValue(boneMap, \"shearX\", 0);\n                    data.shearY = this.getValue(boneMap, \"shearY\", 0);\n                    data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n\n                    skeletonData.bones.push(data);\n                }\n            }\n\n            // Slots.\n            if (root.slots) {\n                for (let i = 0; i < root.slots.length; i++) {\n                    let slotMap = root.slots[i];\n                    let slotName: string = slotMap.name;\n                    let boneName: string = slotMap.bone;\n                    let boneData = skeletonData.findBone(boneName);\n                    if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n                    let data = new SlotData(skeletonData.slots.length, slotName, boneData);\n\n                    let color: string = this.getValue(slotMap, \"color\", null);\n                    if (color != null) data.color.setFromString(color);\n\n                    let dark: string = this.getValue(slotMap, \"dark\", null);\n                    if (dark != null) {\n                        data.darkColor = new Color(1, 1, 1, 1);\n                        data.darkColor.setFromString(dark);\n                    }\n\n                    data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n                    data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n                    skeletonData.slots.push(data);\n                }\n            }\n\n            // IK constraints\n            if (root.ik) {\n                for (let i = 0; i < root.ik.length; i++) {\n                    let constraintMap = root.ik[i];\n                    let data = new IkConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\n                        let boneName = constraintMap.bones[j];\n                        let bone = skeletonData.findBone(boneName);\n                        if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n\n                    let targetName: string = constraintMap.target;\n                    data.target = skeletonData.findBone(targetName);\n                    if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\n\n                    data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n                    data.mix = this.getValue(constraintMap, \"mix\", 1);\n\n                    skeletonData.ikConstraints.push(data);\n                }\n            }\n\n            // Transform constraints.\n            if (root.transform) {\n                for (let i = 0; i < root.transform.length; i++) {\n                    let constraintMap = root.transform[i];\n                    let data = new TransformConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\n                        let boneName = constraintMap.bones[j];\n                        let bone = skeletonData.findBone(boneName);\n                        if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n\n                    let targetName: string = constraintMap.target;\n                    data.target = skeletonData.findBone(targetName);\n                    if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n\n                    data.local = this.getValue(constraintMap, \"local\", false);\n                    data.relative = this.getValue(constraintMap, \"relative\", false);\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                    data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n                    data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n                    data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n                    data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n                    data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n                    data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n                    data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n\n                    skeletonData.transformConstraints.push(data);\n                }\n            }\n\n            // Path constraints.\n            if (root.path) {\n                for (let i = 0; i < root.path.length; i++) {\n                    let constraintMap = root.path[i];\n                    let data = new PathConstraintData(constraintMap.name);\n                    data.order = this.getValue(constraintMap, \"order\", 0);\n\n                    for (let j = 0; j < constraintMap.bones.length; j++) {\n                        let boneName = constraintMap.bones[j];\n                        let bone = skeletonData.findBone(boneName);\n                        if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n                        data.bones.push(bone);\n                    }\n\n                    let targetName: string = constraintMap.target;\n                    data.target = skeletonData.findSlot(targetName);\n                    if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n\n                    data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n                    data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n                    data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n                    data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n                    data.position = this.getValue(constraintMap, \"position\", 0);\n                    if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                    data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n                    if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                    data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n                    data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n\n                    skeletonData.pathConstraints.push(data);\n                }\n            }\n\n            // Skins.\n            if (root.skins) {\n                for (let skinName in root.skins) {\n                    let skinMap = root.skins[skinName]\n                    let skin = new Skin(skinName);\n                    for (let slotName in skinMap) {\n                        let slotIndex = skeletonData.findSlotIndex(slotName);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                        let slotMap = skinMap[slotName];\n                        for (let entryName in slotMap) {\n                            let attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n                            if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n                        }\n                    }\n                    skeletonData.skins.push(skin);\n                    if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n                }\n            }\n\n            // Linked meshes.\n            for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n                let linkedMesh = this.linkedMeshes[i];\n                let skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n                if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n                let parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n                if (parent == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n                linkedMesh.mesh.setParentMesh(<MeshAttachment> parent);\n                //linkedMesh.mesh.updateUVs();\n            }\n            this.linkedMeshes.length = 0;\n\n            // Events.\n            if (root.events) {\n                for (let eventName in root.events) {\n                    let eventMap = root.events[eventName];\n                    let data = new EventData(eventName);\n                    data.intValue = this.getValue(eventMap, \"int\", 0);\n                    data.floatValue = this.getValue(eventMap, \"float\", 0);\n                    data.stringValue = this.getValue(eventMap, \"string\", \"\");\n                    skeletonData.events.push(data);\n                }\n            }\n\n            // Animations.\n            if (root.animations) {\n                for (let animationName in root.animations) {\n                    let animationMap = root.animations[animationName];\n                    this.readAnimation(animationMap, animationName, skeletonData);\n                }\n            }\n\n            return skeletonData;\n        }\n\n        readAttachment (map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment {\n            let scale = this.scale;\n            name = this.getValue(map, \"name\", name);\n\n            let type = this.getValue(map, \"type\", \"region\");\n\n            switch (type) {\n                case \"region\": {\n                    let path = this.getValue(map, \"path\", name);\n                    let region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n                    if (region == null) return null;\n                    region.path = path;\n                    region.x = this.getValue(map, \"x\", 0) * scale;\n                    region.y = this.getValue(map, \"y\", 0) * scale;\n                    region.scaleX = this.getValue(map, \"scaleX\", 1);\n                    region.scaleY = this.getValue(map, \"scaleY\", 1);\n                    region.rotation = this.getValue(map, \"rotation\", 0);\n                    region.width = map.width * scale;\n                    region.height = map.height * scale;\n\n                    let color: string = this.getValue(map, \"color\", null);\n                    if (color != null) region.color.setFromString(color);\n\n                    //region.updateOffset();\n                    return region;\n                }\n                case \"boundingbox\": {\n                    let box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n                    if (box == null) return null;\n                    this.readVertices(map, box, map.vertexCount << 1);\n                    let color: string = this.getValue(map, \"color\", null);\n                    if (color != null) box.color.setFromString(color);\n                    return box;\n                }\n                case \"mesh\":\n                case \"linkedmesh\": {\n                    let path = this.getValue(map, \"path\", name);\n                    let mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n                    if (mesh == null) return null;\n                    mesh.path = path;\n\n                    let color = this.getValue(map, \"color\", null);\n                    if (color != null) mesh.color.setFromString(color);\n\n                    let parent: string = this.getValue(map, \"parent\", null);\n                    if (parent != null) {\n                        mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                        this.linkedMeshes.push(new LinkedMesh(mesh, <string> this.getValue(map, \"skin\", null), slotIndex, parent));\n                        return mesh;\n                    }\n\n                    let uvs: Array<number> = map.uvs;\n                    this.readVertices(map, mesh, uvs.length);\n                    mesh.triangles = map.triangles;\n                    mesh.regionUVs = uvs;\n                    //mesh.updateUVs();\n\n                    mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n                    return mesh;\n                }\n                case \"path\": {\n                    let path = this.attachmentLoader.newPathAttachment(skin, name);\n                    if (path == null) return null;\n                    path.closed = this.getValue(map, \"closed\", false);\n                    path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n\n                    let vertexCount = map.vertexCount;\n                    this.readVertices(map, path, vertexCount << 1);\n\n                    let lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n                    for (let i = 0; i < map.lengths.length; i++)\n                        lengths[i] = map.lengths[i] * scale;\n                    path.lengths = lengths;\n\n                    let color: string = this.getValue(map, \"color\", null);\n                    if (color != null) path.color.setFromString(color);\n                    return path;\n                }\n                case \"point\": {\n                    let point = this.attachmentLoader.newPointAttachment(skin, name);\n                    if (point == null) return null;\n                    point.x = this.getValue(map, \"x\", 0) * scale;\n                    point.y = this.getValue(map, \"y\", 0) * scale;\n                    point.rotation = this.getValue(map, \"rotation\", 0);\n\n                    let color = this.getValue(map, \"color\", null);\n                    if (color != null) point.color.setFromString(color);\n                    return point;\n                }\n                case \"clipping\": {\n                    let clip = this.attachmentLoader.newClippingAttachment(skin, name);\n                    if (clip == null) return null;\n\n                    let end = this.getValue(map, \"end\", null);\n                    if (end != null) {\n                        let slot = skeletonData.findSlot(end);\n                        if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\n                        clip.endSlot = slot;\n                    }\n\n                    let vertexCount = map.vertexCount;\n                    this.readVertices(map, clip, vertexCount << 1);\n\n                    let color: string = this.getValue(map, \"color\", null);\n                    if (color != null) clip.color.setFromString(color);\n                    return clip;\n                }\n            }\n            return null;\n        }\n\n        readVertices (map: any, attachment: VertexAttachment, verticesLength: number) {\n            let scale = this.scale;\n            attachment.worldVerticesLength = verticesLength;\n            let vertices: Array<number> = map.vertices;\n            if (verticesLength == vertices.length) {\n                let scaledVertices = Utils.toFloatArray(vertices);\n                if (scale != 1) {\n                    for (let i = 0, n = vertices.length; i < n; i++)\n                        scaledVertices[i] *= scale;\n                }\n                attachment.vertices = scaledVertices;\n                return;\n            }\n            let weights = new Array<number>();\n            let bones = new Array<number>();\n            for (let i = 0, n = vertices.length; i < n;) {\n                let boneCount = vertices[i++];\n                bones.push(boneCount);\n                for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                    bones.push(vertices[i]);\n                    weights.push(vertices[i + 1] * scale);\n                    weights.push(vertices[i + 2] * scale);\n                    weights.push(vertices[i + 3]);\n                }\n            }\n            attachment.bones = bones;\n            attachment.vertices = Utils.toFloatArray(weights);\n        }\n\n        readAnimation (map: any, name: string, skeletonData: SkeletonData) {\n            let scale = this.scale;\n            let timelines = new Array<Timeline>();\n            let duration = 0;\n\n            // Slot timelines.\n            if (map.slots) {\n                for (let slotName in map.slots) {\n                    let slotMap = map.slots[slotName];\n                    let slotIndex = skeletonData.findSlotIndex(slotName);\n                    if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n                    for (let timelineName in slotMap) {\n                        let timelineMap = slotMap[timelineName];\n                        if (timelineName == \"attachment\") {\n                            let timeline = new AttachmentTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                        } else if (timelineName == \"color\") {\n                            let timeline = new ColorTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                let color = new Color();\n                                color.setFromString(valueMap.color);\n                                timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * ColorTimeline.ENTRIES]);\n\n                        } else if (timelineName == \"twoColor\") {\n                            let timeline = new TwoColorTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                let light = new Color();\n                                let dark = new Color();\n                                light.setFromString(valueMap.light);\n                                dark.setFromString(valueMap.dark);\n                                timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TwoColorTimeline.ENTRIES]);\n\n                        } else\n                            throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n                    }\n                }\n            }\n\n            // Bone timelines.\n            if (map.bones) {\n                for (let boneName in map.bones) {\n                    let boneMap = map.bones[boneName];\n                    let boneIndex = skeletonData.findBoneIndex(boneName);\n                    if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n                    for (let timelineName in boneMap) {\n                        let timelineMap = boneMap[timelineName];\n                        if (timelineName === \"rotate\") {\n                            let timeline = new RotateTimeline(timelineMap.length);\n                            timeline.boneIndex = boneIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * RotateTimeline.ENTRIES]);\n\n                        } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                            let timeline: TranslateTimeline = null;\n                            let timelineScale = 1;\n                            if (timelineName === \"scale\")\n                                timeline = new ScaleTimeline(timelineMap.length);\n                            else if (timelineName === \"shear\")\n                                timeline = new ShearTimeline(timelineMap.length);\n                            else {\n                                timeline = new TranslateTimeline(timelineMap.length);\n                                timelineScale = scale;\n                            }\n                            timeline.boneIndex = boneIndex;\n\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                let x = this.getValue(valueMap, \"x\", 0), y = this.getValue(valueMap, \"y\", 0);\n                                timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * TranslateTimeline.ENTRIES]);\n\n                        } else\n                            throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n                    }\n                }\n            }\n\n            // IK constraint timelines.\n            if (map.ik) {\n                for (let constraintName in map.ik) {\n                    let constraintMap = map.ik[constraintName];\n                    let constraint = skeletonData.findIkConstraint(constraintName);\n                    let timeline = new IkConstraintTimeline(constraintMap.length);\n                    timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                    let frameIndex = 0;\n                    for (let i = 0; i < constraintMap.length; i++) {\n                        let valueMap = constraintMap[i];\n                        timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1),\n                            this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1);\n                        this.readCurve(valueMap, timeline, frameIndex);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * IkConstraintTimeline.ENTRIES]);\n                }\n            }\n\n            // Transform constraint timelines.\n            if (map.transform) {\n                for (let constraintName in map.transform) {\n                    let constraintMap = map.transform[constraintName];\n                    let constraint = skeletonData.findTransformConstraint(constraintName);\n                    let timeline = new TransformConstraintTimeline(constraintMap.length);\n                    timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                    let frameIndex = 0;\n                    for (let i = 0; i < constraintMap.length; i++) {\n                        let valueMap = constraintMap[i];\n                        timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                            this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n                        this.readCurve(valueMap, timeline, frameIndex);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration,\n                        timeline.frames[(timeline.getFrameCount() - 1) * TransformConstraintTimeline.ENTRIES]);\n                }\n            }\n\n            // Path constraint timelines.\n            if (map.paths) {\n                for (let constraintName in map.paths) {\n                    let constraintMap = map.paths[constraintName];\n                    let index = skeletonData.findPathConstraintIndex(constraintName);\n                    if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n                    let data = skeletonData.pathConstraints[index];\n                    for (let timelineName in constraintMap) {\n                        let timelineMap = constraintMap[timelineName];\n                        if (timelineName === \"position\" || timelineName === \"spacing\") {\n                            let timeline: PathConstraintPositionTimeline = null;\n                            let timelineScale = 1;\n                            if (timelineName === \"spacing\") {\n                                timeline = new PathConstraintSpacingTimeline(timelineMap.length);\n                                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) timelineScale = scale;\n                            } else {\n                                timeline = new PathConstraintPositionTimeline(timelineMap.length);\n                                if (data.positionMode == PositionMode.Fixed) timelineScale = scale;\n                            }\n                            timeline.pathConstraintIndex = index;\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration,\n                                timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintPositionTimeline.ENTRIES]);\n                        } else if (timelineName === \"mix\") {\n                            let timeline = new PathConstraintMixTimeline(timelineMap.length);\n                            timeline.pathConstraintIndex = index;\n                            let frameIndex = 0;\n                            for (let i = 0; i < timelineMap.length; i++) {\n                                let valueMap = timelineMap[i];\n                                timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1),\n                                    this.getValue(valueMap, \"translateMix\", 1));\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration,\n                                timeline.frames[(timeline.getFrameCount() - 1) * PathConstraintMixTimeline.ENTRIES]);\n                        }\n                    }\n                }\n            }\n\n            // Deform timelines.\n            if (map.deform) {\n                for (let deformName in map.deform) {\n                    let deformMap = map.deform[deformName];\n                    let skin = skeletonData.findSkin(deformName);\n                    if (skin == null) throw new Error(\"Skin not found: \" + deformName);\n                    for (let slotName in deformMap) {\n                        let slotMap = deformMap[slotName];\n                        let slotIndex = skeletonData.findSlotIndex(slotName);\n                        if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n                        for (let timelineName in slotMap) {\n                            let timelineMap = slotMap[timelineName];\n                            let attachment = <VertexAttachment>skin.getAttachment(slotIndex, timelineName);\n                            if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                            let weighted = attachment.bones != null;\n                            let vertices = attachment.vertices;\n                            let deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n\n                            let timeline = new DeformTimeline(timelineMap.length);\n                            timeline.slotIndex = slotIndex;\n                            timeline.attachment = attachment;\n\n                            let frameIndex = 0;\n                            for (let j = 0; j < timelineMap.length; j++) {\n                                let valueMap = timelineMap[j];\n                                let deform: ArrayLike<number>;\n                                let verticesValue: Array<Number> = this.getValue(valueMap, \"vertices\", null);\n                                if (verticesValue == null)\n                                    deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                                else {\n                                    deform = Utils.newFloatArray(deformLength);\n                                    let start = <number>this.getValue(valueMap, \"offset\", 0);\n                                    Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                    if (scale != 1) {\n                                        for (let i = start, n = i + verticesValue.length; i < n; i++)\n                                            deform[i] *= scale;\n                                    }\n                                    if (!weighted) {\n                                        for (let i = 0; i < deformLength; i++)\n                                            deform[i] += vertices[i];\n                                    }\n                                }\n\n                                timeline.setFrame(frameIndex, valueMap.time, deform);\n                                this.readCurve(valueMap, timeline, frameIndex);\n                                frameIndex++;\n                            }\n                            timelines.push(timeline);\n                            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                        }\n                    }\n                }\n            }\n\n            // Draw order timeline.\n            let drawOrderNode = map.drawOrder;\n            if (drawOrderNode == null) drawOrderNode = map.draworder;\n            if (drawOrderNode != null) {\n                let timeline = new DrawOrderTimeline(drawOrderNode.length);\n                let slotCount = skeletonData.slots.length;\n                let frameIndex = 0;\n                for (let j = 0; j < drawOrderNode.length; j++) {\n                    let drawOrderMap = drawOrderNode[j];\n                    let drawOrder: Array<number> = null;\n                    let offsets = this.getValue(drawOrderMap, \"offsets\", null);\n                    if (offsets != null) {\n                        drawOrder = Utils.newArray<number>(slotCount, -1);\n                        let unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                        let originalIndex = 0, unchangedIndex = 0;\n                        for (let i = 0; i < offsets.length; i++) {\n                            let offsetMap = offsets[i];\n                            let slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                            if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\n                            // Collect unchanged items.\n                            while (originalIndex != slotIndex)\n                                unchanged[unchangedIndex++] = originalIndex++;\n                            // Set changed items.\n                            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                        }\n                        // Collect remaining unchanged items.\n                        while (originalIndex < slotCount)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Fill in unchanged items.\n                        for (let i = slotCount - 1; i >= 0; i--)\n                            if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n                    }\n                    timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n            }\n\n            // Event timeline.\n            if (map.events) {\n                let timeline = new EventTimeline(map.events.length);\n                let frameIndex = 0;\n                for (let i = 0; i < map.events.length; i++) {\n                    let eventMap = map.events[i];\n                    let eventData = skeletonData.findEvent(eventMap.name);\n                    if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\n                    let event = new Event(Utils.toSinglePrecision(eventMap.time), eventData);\n                    event.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n                    event.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n                    event.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n                    timeline.setFrame(frameIndex++, event);\n                }\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n            }\n\n            if (isNaN(duration)) {\n                throw new Error(\"Error while parsing animation, duration is NaN\");\n            }\n\n            skeletonData.animations.push(new Animation(name, timelines, duration));\n        }\n\n        readCurve (map: any, timeline: CurveTimeline, frameIndex: number) {\n            if (!map.curve) return;\n            if (map.curve === \"stepped\")\n                timeline.setStepped(frameIndex);\n            else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n                let curve: Array<number> = map.curve;\n                timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n            }\n        }\n\n        getValue (map: any, prop: string, defaultValue: any) {\n            return map[prop] !== undefined ? map[prop] : defaultValue;\n        }\n\n        static blendModeFromString (str: string) {\n            str = str.toLowerCase();\n            if (str == \"normal\") return BlendMode.Normal;\n            if (str == \"additive\") return BlendMode.Additive;\n            if (str == \"multiply\") return BlendMode.Multiply;\n            if (str == \"screen\") return BlendMode.Screen;\n            throw new Error(`Unknown blend mode: ${str}`);\n        }\n\n        static positionModeFromString (str: string) {\n            str = str.toLowerCase();\n            if (str == \"fixed\") return PositionMode.Fixed;\n            if (str == \"percent\") return PositionMode.Percent;\n            throw new Error(`Unknown position mode: ${str}`);\n        }\n\n        static spacingModeFromString (str: string) {\n            str = str.toLowerCase();\n            if (str == \"length\") return SpacingMode.Length;\n            if (str == \"fixed\") return SpacingMode.Fixed;\n            if (str == \"percent\") return SpacingMode.Percent;\n            throw new Error(`Unknown position mode: ${str}`);\n        }\n\n        static rotateModeFromString (str: string) {\n            str = str.toLowerCase();\n            if (str == \"tangent\") return RotateMode.Tangent;\n            if (str == \"chain\") return RotateMode.Chain;\n            if (str == \"chainscale\") return RotateMode.ChainScale;\n            throw new Error(`Unknown rotate mode: ${str}`);\n        }\n\n        static transformModeFromString(str: string) {\n            str = str.toLowerCase();\n            if (str == \"normal\") return TransformMode.Normal;\n            if (str == \"onlytranslation\") return TransformMode.OnlyTranslation;\n            if (str == \"norotationorreflection\") return TransformMode.NoRotationOrReflection;\n            if (str == \"noscale\") return TransformMode.NoScale;\n            if (str == \"noscaleorreflection\") return TransformMode.NoScaleOrReflection;\n            throw new Error(`Unknown transform mode: ${str}`);\n        }\n    }\n\n    class LinkedMesh {\n        parent: string; skin: string;\n        slotIndex: number;\n        mesh: MeshAttachment;\n\n        constructor (mesh: MeshAttachment, skin: string, slotIndex: number, parent: string) {\n            this.mesh = mesh;\n            this.skin = skin;\n            this.slotIndex = slotIndex;\n            this.parent = parent;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Skin {\n        name: string;\n        attachments = new Array<Map<Attachment>>();\n\n        constructor(name: string) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n\n        addAttachment(slotIndex: number, name: string, attachment: Attachment) {\n            if (attachment == null) throw new Error(\"attachment cannot be null.\");\n            let attachments = this.attachments;\n            if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n            if (!attachments[slotIndex]) attachments[slotIndex] = {};\n            attachments[slotIndex][name] = attachment;\n        }\n\n        /** @return May be null. */\n        getAttachment(slotIndex: number, name: string): Attachment {\n            let dictionary = this.attachments[slotIndex];\n            return dictionary ? dictionary[name] : null;\n        }\n\n        /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n        attachAll(skeleton: Skeleton, oldSkin: Skin) {\n            let slotIndex = 0;\n            for (let i = 0; i < skeleton.slots.length; i++) {\n                let slot = skeleton.slots[i];\n                let slotAttachment = slot.getAttachment();\n                if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                    let dictionary = oldSkin.attachments[slotIndex];\n                    for (let key in dictionary) {\n                        let skinAttachment: Attachment = dictionary[key];\n                        if (slotAttachment == skinAttachment) {\n                            let attachment = this.getAttachment(slotIndex, name);\n                            if (attachment != null) slot.setAttachment(attachment);\n                            break;\n                        }\n                    }\n                }\n                slotIndex++;\n            }\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class Slot {\n        //this is for PIXI\n        currentMesh: any;\n        currentSprite: any;\n        currentGraphics: any;\n        clippingContainer: any;\n\n        meshes: any;\n        currentMeshName: string;\n        sprites: any;\n        currentSpriteName: string;\n\n        blendMode: number;\n        //assign hack region a bit later\n        tempRegion: TextureRegion;\n        tempAttachment: Attachment;\n\n        //this is canon\n        data: SlotData;\n        bone: Bone;\n        color: Color;\n        darkColor: Color;\n        attachment: Attachment;\n        private attachmentTime: number;\n        attachmentVertices = new Array<number>();\n\n        constructor (data: SlotData, bone: Bone) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (bone == null) throw new Error(\"bone cannot be null.\");\n            this.data = data;\n            this.bone = bone;\n            this.color = new Color();\n            this.darkColor = data.darkColor == null ? null : new Color();\n            this.setToSetupPose();\n\n            this.blendMode = this.data.blendMode;\n        }\n\n        /** @return May be null. */\n        getAttachment (): Attachment {\n            return this.attachment;\n        }\n\n        /** Sets the attachment and if it changed, resets {@link #getAttachmentTime()} and clears {@link #getAttachmentVertices()}.\n         * @param attachment May be null. */\n        setAttachment (attachment: Attachment) {\n            if (this.attachment == attachment) return;\n            this.attachment = attachment;\n            this.attachmentTime = this.bone.skeleton.time;\n            this.attachmentVertices.length = 0;\n        }\n\n        setAttachmentTime (time: number) {\n            this.attachmentTime = this.bone.skeleton.time - time;\n        }\n\n        /** Returns the time since the attachment was set. */\n        getAttachmentTime (): number {\n            return this.bone.skeleton.time - this.attachmentTime;\n        }\n\n        setToSetupPose () {\n            this.color.setFromColor(this.data.color);\n            if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n            if (this.data.attachmentName == null)\n                this.attachment = null;\n            else {\n                this.attachment = null;\n                this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n            }\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class SlotData {\n        index: number;\n        name: string;\n        boneData: BoneData;\n        color = new Color(1, 1, 1, 1);\n        darkColor: Color;\n        attachmentName: string;\n        blendMode: BlendMode;\n\n        constructor (index: number, name: string, boneData: BoneData) {\n            if (index < 0) throw new Error(\"index must be >= 0.\");\n            if (name == null) throw new Error(\"name cannot be null.\");\n            if (boneData == null) throw new Error(\"boneData cannot be null.\");\n            this.index = index;\n            this.name = name;\n            this.boneData = boneData;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export abstract class Texture {\n        protected _image: HTMLImageElement;\n\n        constructor (image: HTMLImageElement) {\n            this._image = image;\n        }\n\n        getImage (): HTMLImageElement {\n            return this._image;\n        }\n\n        abstract setFilters (minFilter: TextureFilter, magFilter: TextureFilter): void;\n        abstract setWraps (uWrap: TextureWrap, vWrap: TextureWrap): void;\n        abstract dispose (): void;\n\n\n        public static filterFromString (text: string): TextureFilter {\n            switch (text.toLowerCase()) {\n                case \"nearest\": return TextureFilter.Nearest;\n                case \"linear\": return TextureFilter.Linear;\n                case \"mipmap\": return TextureFilter.MipMap;\n                case \"mipmapnearestnearest\": return TextureFilter.MipMapNearestNearest;\n                case \"mipmaplinearnearest\": return TextureFilter.MipMapLinearNearest;\n                case \"mipmapnearestlinear\": return TextureFilter.MipMapNearestLinear;\n                case \"mipmaplinearlinear\": return TextureFilter.MipMapLinearLinear;\n                default: throw new Error(`Unknown texture filter ${text}`);\n            }\n        }\n\n        public static wrapFromString (text: string): TextureWrap {\n            switch (text.toLowerCase()) {\n                case \"mirroredtepeat\": return TextureWrap.MirroredRepeat;\n                case \"clamptoedge\": return TextureWrap.ClampToEdge;\n                case \"repeat\": return TextureWrap.Repeat;\n                default: throw new Error(`Unknown texture wrap ${text}`);\n            }\n        }\n    }\n\n    export enum TextureFilter {\n        Nearest = 9728, // WebGLRenderingContext.NEAREST\n        Linear = 9729, // WebGLRenderingContext.LINEAR\n        MipMap = 9987, // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n        MipMapNearestNearest = 9984, // WebGLRenderingContext.NEAREST_MIPMAP_NEAREST\n        MipMapLinearNearest = 9985, // WebGLRenderingContext.LINEAR_MIPMAP_NEAREST\n        MipMapNearestLinear = 9986, // WebGLRenderingContext.NEAREST_MIPMAP_LINEAR\n        MipMapLinearLinear = 9987 // WebGLRenderingContext.LINEAR_MIPMAP_LINEAR\n    }\n\n    export enum TextureWrap {\n        MirroredRepeat = 33648, // WebGLRenderingContext.MIRRORED_REPEAT\n        ClampToEdge = 33071, // WebGLRenderingContext.CLAMP_TO_EDGE\n        Repeat = 10497 // WebGLRenderingContext.REPEAT\n    }\n\n    export class TextureRegion {\n        texture: PIXI.Texture;\n\n        //thats for overrides\n        size: PIXI.Rectangle = null;\n\n        get width(): number {\n            const tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return (tex as any).crop.width;\n            }\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.orig.width;\n        }\n\n        get height(): number {\n            const tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return (tex as any).crop.height;\n            }\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.orig.height;\n        }\n\n        get u(): number {\n            return (this.texture as any)._uvs.x0;\n        }\n\n        get v(): number {\n            return (this.texture as any)._uvs.y0;\n        }\n\n        get u2(): number {\n            return (this.texture as any)._uvs.x2;\n        }\n\n        get v2(): number {\n            return (this.texture as any)._uvs.y2;\n        }\n\n        get offsetX(): number {\n            const tex = this.texture;\n            return tex.trim ? tex.trim.x : 0;\n        }\n\n        get offsetY(): number {\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n            return this.spineOffsetY;\n        }\n\n        get pixiOffsetY(): number {\n            const tex = this.texture;\n            return tex.trim ? tex.trim.y : 0;\n        }\n\n        get spineOffsetY(): number {\n            var tex = this.texture;\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n        }\n\n        get originalWidth(): number {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.width;\n                }\n                return (tex as any).crop.width;\n            }\n            return tex.orig.width;\n        }\n\n        get originalHeight(): number {\n            const tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.height;\n                }\n                return (tex as any).crop.height;\n            }\n            return tex.orig.height;\n        }\n\n        get x(): number {\n            return this.texture.frame.x;\n        }\n\n        get y(): number {\n            return this.texture.frame.y;\n        }\n\n        get rotate(): boolean {\n            return this.texture.rotate !== 0;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class TextureAtlas implements Disposable {\n        pages = new Array<TextureAtlasPage>();\n        regions = new Array<TextureAtlasRegion>();\n\n        constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\n            if (atlasText) {\n                this.addSpineAtlas(atlasText, textureLoader, callback);\n            }\n        }\n\n        addTexture(name: string, texture: PIXI.Texture) {\n            let pages = this.pages;\n            let page: TextureAtlasPage = null;\n            for (var i = 0; i < pages.length; i++) {\n                if (pages[i].baseTexture === texture.baseTexture) {\n                    page = pages[i];\n                    break;\n                }\n            }\n            if (page === null) {\n                page = new TextureAtlasPage();\n                page.name = 'texturePage';\n                var baseTexture = texture.baseTexture;\n                page.width = baseTexture.realWidth;\n                page.height = baseTexture.realHeight;\n                page.baseTexture = baseTexture;\n                //those fields are not relevant in Pixi\n                page.minFilter = page.magFilter = TextureFilter.Nearest;\n                page.uWrap = TextureWrap.ClampToEdge;\n                page.vWrap = TextureWrap.ClampToEdge;\n                pages.push(page);\n            }\n            var region = new TextureAtlasRegion();\n            region.name = name;\n            region.page = page;\n            region.texture = texture;\n            region.index = -1;\n            this.regions.push(region);\n            return region;\n        }\n\n        addTextureHash(textures: Map<PIXI.Texture>, stripExtension: boolean) {\n            for (var key in textures) {\n                if (textures.hasOwnProperty(key)) {\n                    this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n                }\n            }\n        }\n\n        public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture)  => any) => any, callback: (obj: TextureAtlas) => any) {\n            return this.load(atlasText, textureLoader, callback);\n        }\n\n        private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: PIXI.BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n            if (textureLoader == null)\n                throw new Error(\"textureLoader cannot be null.\");\n\n            let reader = new TextureAtlasReader(atlasText);\n            let tuple = new Array<string>(4);\n            let page: TextureAtlasPage = null;\n\n            let iterateParser = () => {\n                while (true) {\n                    let line = reader.readLine();\n                    if (line == null) {\n                        return callback && callback(this);\n                    }\n                    line = line.trim();\n                    if (line.length == 0)\n                        page = null;\n                    else if (!page) {\n                        page = new TextureAtlasPage();\n                        page.name = line;\n\n                        if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\n                            page.width = parseInt(tuple[0]);\n                            page.height = parseInt(tuple[1]);\n                            reader.readTuple(tuple);\n                        }\n                        // page.format = Format[tuple[0]]; we don't need format in WebGL\n\n                        reader.readTuple(tuple);\n                        page.minFilter = Texture.filterFromString(tuple[0]);\n                        page.magFilter = Texture.filterFromString(tuple[1]);\n\n                        let direction = reader.readValue();\n                        page.uWrap = TextureWrap.ClampToEdge;\n                        page.vWrap = TextureWrap.ClampToEdge;\n                        if (direction == \"x\")\n                            page.uWrap = TextureWrap.Repeat;\n                        else if (direction == \"y\")\n                            page.vWrap = TextureWrap.Repeat;\n                        else if (direction == \"xy\")\n                            page.uWrap = page.vWrap = TextureWrap.Repeat;\n\n                        textureLoader(line, (texture: PIXI.BaseTexture) => {\n                            page.baseTexture = texture;\n                            if (!texture.hasLoaded) {\n                                texture.width = page.width;\n                                texture.height = page.height;\n                            }\n                            this.pages.push(page);\n                            page.setFilters();\n\n                            if (!page.width || !page.height) {\n                                page.width = texture.realWidth;\n                                page.height = texture.realHeight;\n                                if (!page.width || !page.height) {\n                                    console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                                }\n                            }\n                            iterateParser();\n                        });\n                        this.pages.push(page);\n                        break;\n                    } else {\n                        let region: TextureAtlasRegion = new TextureAtlasRegion();\n                        region.name = line;\n                        region.page = page;\n\n                        let rotate: number = reader.readValue() == \"true\" ? 6 : 0;\n\n                        reader.readTuple(tuple);\n                        let x = parseInt(tuple[0]);\n                        let y = parseInt(tuple[1]);\n\n                        reader.readTuple(tuple);\n                        let width = parseInt(tuple[0]);\n                        let height = parseInt(tuple[1]);\n\n                        let resolution = page.baseTexture.resolution;\n                        x /= resolution;\n                        y /= resolution;\n                        width /= resolution;\n                        height /= resolution;\n\n                        let frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n\n                        if (reader.readTuple(tuple) == 4) { // split is optional\n                            // region.splits = new Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\n\n                            if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n                                //region.pads = Vector.<int>(parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3]));\n\n                                reader.readTuple(tuple);\n                            }\n                        }\n\n                        let originalWidth = parseInt(tuple[0]) / resolution;\n                        let originalHeight = parseInt(tuple[1]) / resolution;\n                        reader.readTuple(tuple);\n                        let offsetX = parseInt(tuple[0]) / resolution;\n                        let offsetY = parseInt(tuple[1]) / resolution;\n\n                        let orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n                        let trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n\n                        //TODO: pixiv3 uses different frame/crop/trim\n\n                        if (PIXI.VERSION[0] != '3') {\n                            // pixi v4 or v5\n                            region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\n                        } else {\n                            // pixi v3.0.11\n                            var frame2 = new PIXI.Rectangle(x, y, width, height);\n                            var crop = frame2.clone();\n                            trim.width = originalWidth;\n                            trim.height = originalHeight;\n                            region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\n                        }\n\n                        region.index = parseInt(reader.readValue());\n                        (region.texture as any)._updateUvs();\n\n                        this.regions.push(region);\n                    }\n                }\n            }\n\n            iterateParser();\n        }\n\n        findRegion(name: string): TextureAtlasRegion {\n            for (let i = 0; i < this.regions.length; i++) {\n                if (this.regions[i].name == name) {\n                    return this.regions[i];\n                }\n            }\n            return null;\n        }\n\n        dispose() {\n            for (let i = 0; i < this.pages.length; i++) {\n                this.pages[i].baseTexture.dispose();\n            }\n        }\n    }\n\n    class TextureAtlasReader {\n        lines: Array<string>;\n        index: number = 0;\n\n        constructor(text: string) {\n            this.lines = text.split(/\\r\\n|\\r|\\n/);\n        }\n\n        readLine(): string {\n            if (this.index >= this.lines.length)\n                return null;\n            return this.lines[this.index++];\n        }\n\n        readValue(): string {\n            let line = this.readLine();\n            let colon = line.indexOf(\":\");\n            if (colon == -1)\n                throw new Error(\"Invalid line: \" + line);\n            return line.substring(colon + 1).trim();\n        }\n\n        readTuple(tuple: Array<string>): number {\n            let line = this.readLine();\n            let colon = line.indexOf(\":\");\n            if (colon == -1)\n                throw new Error(\"Invalid line: \" + line);\n            let i = 0, lastMatch = colon + 1;\n            for (; i < 3; i++) {\n                let comma = line.indexOf(\",\", lastMatch);\n                if (comma == -1) break;\n                tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n                lastMatch = comma + 1;\n            }\n            tuple[i] = line.substring(lastMatch).trim();\n            return i + 1;\n        }\n    }\n\n    export class TextureAtlasPage {\n        name: string;\n        minFilter: TextureFilter;\n        magFilter: TextureFilter;\n        uWrap: TextureWrap;\n        vWrap: TextureWrap;\n        baseTexture: PIXI.BaseTexture;\n        width: number;\n        height: number;\n\n        public setFilters() {\n            let tex = this.baseTexture;\n            let filter = this.minFilter;\n            if (filter == TextureFilter.Linear) {\n                tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n            } else if (this.minFilter == TextureFilter.Nearest) {\n                tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n            } else {\n                tex.mipmap = true;\n                if (filter == TextureFilter.MipMapNearestNearest) {\n                    tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n                } else {\n                    tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n                }\n            }\n        }\n    }\n\n    export class TextureAtlasRegion extends TextureRegion {\n        page: TextureAtlasPage;\n        name: string;\n        index: number;\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class TransformConstraint implements Constraint {\n        data: TransformConstraintData;\n        bones: Array<Bone>;\n        target: Bone;\n        rotateMix = 0;\n        translateMix = 0;\n        scaleMix = 0;\n        shearMix = 0;\n        temp = new Vector2();\n\n        constructor(data: TransformConstraintData, skeleton: Skeleton) {\n            if (data == null) throw new Error(\"data cannot be null.\");\n            if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n            this.data = data;\n            this.rotateMix = data.rotateMix;\n            this.translateMix = data.translateMix;\n            this.scaleMix = data.scaleMix;\n            this.shearMix = data.shearMix;\n            this.bones = new Array<Bone>();\n            for (let i = 0; i < data.bones.length; i++)\n                this.bones.push(skeleton.findBone(data.bones[i].name));\n            this.target = skeleton.findBone(data.target.name);\n        }\n\n        apply() {\n            this.update();\n        }\n\n        update() {\n            if (this.data.local) {\n                if (this.data.relative)\n                    this.applyRelativeLocal();\n                else\n                    this.applyAbsoluteLocal();\n\n            } else {\n                if (this.data.relative)\n                    this.applyRelativeWorld();\n                else\n                    this.applyAbsoluteWorld();\n            }\n        }\n\n        applyAbsoluteWorld() {\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\n                shearMix = this.shearMix;\n            let target = this.target;\n            let targetMat = target.matrix;\n            let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\n            let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n            let offsetRotation = this.data.offsetRotation * degRadReflect;\n            let offsetShearY = this.data.offsetShearY * degRadReflect;\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                let modified = false;\n                let mat = bone.matrix;\n\n                if (rotateMix != 0) {\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n                    let r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI)\n                        r += MathUtils.PI2;\n                    r *= rotateMix;\n                    let cos = Math.cos(r), sin = Math.sin(r);\n                    mat.a = cos * a - sin * c;\n                    mat.c = cos * b - sin * d;\n                    mat.b = sin * a + cos * c;\n                    mat.d = sin * b + cos * d;\n                    modified = true;\n                }\n\n                if (translateMix != 0) {\n                    let temp = this.temp;\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                    mat.tx += (temp.x - mat.tx) * translateMix;\n                    mat.ty += (temp.y - mat.ty) * translateMix;\n                    modified = true;\n                }\n\n                if (scaleMix > 0) {\n                    let s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n                    let ts = Math.sqrt(ta * ta + tc * tc);\n                    if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n                    mat.a *= s;\n                    mat.b *= s;\n                    s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n                    ts = Math.sqrt(tb * tb + td * td);\n                    if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n                    mat.c *= s;\n                    mat.d *= s;\n                    modified = true;\n                }\n\n                if (shearMix > 0) {\n                    let b = mat.c, d = mat.d;\n                    let by = Math.atan2(d, b);\n                    let r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI)\n                        r += MathUtils.PI2;\n                    r = by + (r + offsetShearY) * shearMix;\n                    let s = Math.sqrt(b * b + d * d);\n                    mat.c = Math.cos(r) * s;\n                    mat.d = Math.sin(r) * s;\n                    modified = true;\n                }\n\n                if (modified) bone.appliedValid = false;\n            }\n        }\n\n        applyRelativeWorld() {\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\n                shearMix = this.shearMix;\n            let target = this.target;\n            let targetMat = target.matrix;\n            let ta = targetMat.a, tb = targetMat.c, tc = targetMat.b, td = targetMat.d;\n            let degRadReflect = ta * td - tb * tc > 0 ? MathUtils.degRad : -MathUtils.degRad;\n            let offsetRotation = this.data.offsetRotation * degRadReflect,\n                offsetShearY = this.data.offsetShearY * degRadReflect;\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                let modified = false;\n                let mat = bone.matrix;\n\n                if (rotateMix != 0) {\n                    let a = mat.a, b = mat.c, c = mat.b, d = mat.d;\n                    let r = Math.atan2(tc, ta) + offsetRotation;\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                    r *= rotateMix;\n                    let cos = Math.cos(r), sin = Math.sin(r);\n                    mat.a = cos * a - sin * c;\n                    mat.c = cos * b - sin * d;\n                    mat.b = sin * a + cos * c;\n                    mat.d = sin * b + cos * d;\n                    modified = true;\n                }\n\n                if (translateMix != 0) {\n                    let temp = this.temp;\n                    target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n                    mat.tx += temp.x * translateMix;\n                    mat.ty += temp.y * translateMix;\n                    modified = true;\n                }\n\n                if (scaleMix > 0) {\n                    let s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n                    mat.a *= s;\n                    mat.b *= s;\n                    s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n                    mat.c *= s;\n                    mat.d *= s;\n                    modified = true;\n                }\n\n                if (shearMix > 0) {\n                    let r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n                    if (r > MathUtils.PI)\n                        r -= MathUtils.PI2;\n                    else if (r < -MathUtils.PI) r += MathUtils.PI2;\n                    let b = mat.c, d = mat.d;\n                    r = Math.atan2(d, b) + (r - MathUtils.PI / 2 + offsetShearY) * shearMix;\n                    let s = Math.sqrt(b * b + d * d);\n                    mat.c = Math.cos(r) * s;\n                    mat.d = Math.sin(r) * s;\n                    modified = true;\n                }\n\n                if (modified) bone.appliedValid = false;\n            }\n        }\n\n        applyAbsoluteLocal() {\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\n                shearMix = this.shearMix;\n            let target = this.target;\n            if (!target.appliedValid) target.updateAppliedTransform();\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (!bone.appliedValid) bone.updateAppliedTransform();\n\n                let rotation = bone.arotation;\n                if (rotateMix != 0) {\n                    let r = target.arotation - rotation + this.data.offsetRotation;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                    rotation += r * rotateMix;\n                }\n\n                let x = bone.ax, y = bone.ay;\n                if (translateMix != 0) {\n                    x += (target.ax - x + this.data.offsetX) * translateMix;\n                    y += (target.ay - y + this.data.offsetY) * translateMix;\n                }\n\n                let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n                if (scaleMix > 0) {\n                    if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n                    if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n                }\n\n                let shearY = bone.ashearY;\n                if (shearMix > 0) {\n                    let r = target.ashearY - shearY + this.data.offsetShearY;\n                    r -= (16384 - ((16384.499999999996 - r / 360) | 0)) * 360;\n                    bone.shearY += r * shearMix;\n                }\n\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n            }\n        }\n\n        applyRelativeLocal() {\n            let rotateMix = this.rotateMix, translateMix = this.translateMix, scaleMix = this.scaleMix,\n                shearMix = this.shearMix;\n            let target = this.target;\n            if (!target.appliedValid) target.updateAppliedTransform();\n            let bones = this.bones;\n            for (let i = 0, n = bones.length; i < n; i++) {\n                let bone = bones[i];\n                if (!bone.appliedValid) bone.updateAppliedTransform();\n\n                let rotation = bone.arotation;\n                if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n\n                let x = bone.ax, y = bone.ay;\n                if (translateMix != 0) {\n                    x += (target.ax + this.data.offsetX) * translateMix;\n                    y += (target.ay + this.data.offsetY) * translateMix;\n                }\n\n                let scaleX = bone.ascaleX, scaleY = bone.ascaleY;\n                if (scaleMix > 0) {\n                    if (scaleX > 0.00001) scaleX *= ((target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix) + 1;\n                    if (scaleY > 0.00001) scaleY *= ((target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix) + 1;\n                }\n\n                let shearY = bone.ashearY;\n                if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n\n                bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n            }\n        }\n\n        getOrder() {\n            return this.data.order;\n        }\n    }\n\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export class TransformConstraintData {\n        name: string;\n        order = 0;\n        bones = new Array<BoneData>();\n        target: BoneData;\n        rotateMix = 0; translateMix = 0; scaleMix = 0; shearMix = 0;\n        offsetRotation = 0; offsetX = 0; offsetY = 0; offsetScaleX = 0; offsetScaleY = 0; offsetShearY = 0;\n        relative = false;\n        local = false;\n\n        constructor (name: string) {\n            if (name == null) throw new Error(\"name cannot be null.\");\n            this.name = name;\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport class Triangulator {\n\t\tprivate convexPolygons = new Array<Array<number>>();\n\t\tprivate convexPolygonsIndices = new Array<Array<number>>();\n\n\t\tprivate indicesArray = new Array<number>();\n\t\tprivate isConcaveArray = new Array<boolean>();\n\t\tprivate triangles = new Array<number>();\n\n\t\tprivate polygonPool = new Pool<Array<number>>(() => {\n\t\t\treturn new Array<number>();\n\t\t});\n\n\t\tprivate polygonIndicesPool = new Pool<Array<number>>(() => {\n\t\t\treturn new Array<number>();\n\t\t});\n\n\t\tpublic triangulate (verticesArray: ArrayLike<number>): Array<number> {\n\t\t\tlet vertices = verticesArray;\n\t\t\tlet vertexCount = verticesArray.length >> 1;\n\n\t\t\tlet indices = this.indicesArray;\n\t\t\tindices.length = 0;\n\t\t\tfor (let i = 0; i < vertexCount; i++)\n\t\t\t\tindices[i] = i;\n\n\t\t\tlet isConcave = this.isConcaveArray;\n\t\t\tisConcave.length = 0;\n\t\t\tfor (let i = 0, n = vertexCount; i < n; ++i)\n\t\t\t\tisConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n\n\t\t\tlet triangles = this.triangles;\n\t\t\ttriangles.length = 0;\n\n\t\t\twhile (vertexCount > 3) {\n\t\t\t\t// Find ear tip.\n\t\t\t\tlet previous = vertexCount - 1, i = 0, next = 1;\n\t\t\t\twhile (true) {\n\t\t\t\t\touter:\n\t\t\t\t\tif (!isConcave[i]) {\n\t\t\t\t\t\tlet p1 = indices[previous] << 1, p2 = indices[i] << 1, p3 = indices[next] << 1;\n\t\t\t\t\t\tlet p1x = vertices[p1], p1y = vertices[p1 + 1];\n\t\t\t\t\t\tlet p2x = vertices[p2], p2y = vertices[p2 + 1];\n\t\t\t\t\t\tlet p3x = vertices[p3], p3y = vertices[p3 + 1];\n\t\t\t\t\t\tfor (let ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n\t\t\t\t\t\t\tif (!isConcave[ii]) continue;\n\t\t\t\t\t\t\tlet v = indices[ii] << 1;\n\t\t\t\t\t\t\tlet vx = vertices[v], vy = vertices[v + 1];\n\t\t\t\t\t\t\tif (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n\t\t\t\t\t\t\t\t\tif (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (next == 0) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tif (!isConcave[i]) break;\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t} while (i > 0);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tprevious = i;\n\t\t\t\t\ti = next;\n\t\t\t\t\tnext = (next + 1) % vertexCount;\n\t\t\t\t}\n\n\t\t\t\t// Cut ear tip.\n\t\t\t\ttriangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n\t\t\t\ttriangles.push(indices[i]);\n\t\t\t\ttriangles.push(indices[(i + 1) % vertexCount]);\n\t\t\t\tindices.splice(i, 1);\n\t\t\t\tisConcave.splice(i, 1);\n\t\t\t\tvertexCount--;\n\n\t\t\t\tlet previousIndex = (vertexCount + i - 1) % vertexCount;\n\t\t\t\tlet nextIndex = i == vertexCount ? 0 : i;\n\t\t\t\tisConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n\t\t\t\tisConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n\t\t\t}\n\n\t\t\tif (vertexCount == 3) {\n\t\t\t\ttriangles.push(indices[2]);\n\t\t\t\ttriangles.push(indices[0]);\n\t\t\t\ttriangles.push(indices[1]);\n\t\t\t}\n\n\t\t\treturn triangles;\n\t\t}\n\n\t\tdecompose (verticesArray: Array<number>, triangles: Array<number>) : Array<Array<number>> {\n\t\t\tlet vertices = verticesArray;\n\t\t\tlet convexPolygons = this.convexPolygons;\n\t\t\tthis.polygonPool.freeAll(convexPolygons);\n\t\t\tconvexPolygons.length = 0;\n\n\t\t\tlet convexPolygonsIndices = this.convexPolygonsIndices;\n\t\t\tthis.polygonIndicesPool.freeAll(convexPolygonsIndices);\n\t\t\tconvexPolygonsIndices.length = 0;\n\n\t\t\tlet polygonIndices = this.polygonIndicesPool.obtain();\n\t\t\tpolygonIndices.length = 0;\n\n\t\t\tlet polygon = this.polygonPool.obtain();\n\t\t\tpolygon.length = 0;\n\n\t\t\t// Merge subsequent triangles if they form a triangle fan.\n\t\t\tlet fanBaseIndex = -1, lastWinding = 0;\n\t\t\tfor (let i = 0, n = triangles.length; i < n; i += 3) {\n\t\t\t\tlet t1 = triangles[i] << 1, t2 = triangles[i + 1] << 1, t3 = triangles[i + 2] << 1;\n\t\t\t\tlet x1 = vertices[t1], y1 = vertices[t1 + 1];\n\t\t\t\tlet x2 = vertices[t2], y2 = vertices[t2 + 1];\n\t\t\t\tlet x3 = vertices[t3], y3 = vertices[t3 + 1];\n\n\t\t\t\t// If the base of the last triangle is the same as this triangle, check if they form a convex polygon (triangle fan).\n\t\t\t\tlet merged = false;\n\t\t\t\tif (fanBaseIndex == t1) {\n\t\t\t\t\tlet o = polygon.length - 4;\n\t\t\t\t\tlet winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n\t\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n\t\t\t\t\tif (winding1 == lastWinding && winding2 == lastWinding) {\n\t\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\t\t\tmerged = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Otherwise make this triangle the new base.\n\t\t\t\tif (!merged) {\n\t\t\t\t\tif (polygon.length > 0) {\n\t\t\t\t\t\tconvexPolygons.push(polygon);\n\t\t\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.polygonPool.free(polygon)\n\t\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t\t\t}\n\t\t\t\t\tpolygon = this.polygonPool.obtain();\n\t\t\t\t\tpolygon.length = 0;\n\t\t\t\t\tpolygon.push(x1);\n\t\t\t\t\tpolygon.push(y1);\n\t\t\t\t\tpolygon.push(x2);\n\t\t\t\t\tpolygon.push(y2);\n\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\tpolygonIndices = this.polygonIndicesPool.obtain();\n\t\t\t\t\tpolygonIndices.length = 0;\n\t\t\t\t\tpolygonIndices.push(t1);\n\t\t\t\t\tpolygonIndices.push(t2);\n\t\t\t\t\tpolygonIndices.push(t3);\n\t\t\t\t\tlastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n\t\t\t\t\tfanBaseIndex = t1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (polygon.length > 0) {\n\t\t\t\tconvexPolygons.push(polygon);\n\t\t\t\tconvexPolygonsIndices.push(polygonIndices);\n\t\t\t}\n\n\t\t\t// Go through the list of polygons and try to merge the remaining triangles with the found triangle fans.\n\t\t\tfor (let i = 0, n = convexPolygons.length; i < n; i++) {\n\t\t\t\tpolygonIndices = convexPolygonsIndices[i];\n\t\t\t\tif (polygonIndices.length == 0) continue;\n\t\t\t\tlet firstIndex = polygonIndices[0];\n\t\t\t\tlet lastIndex = polygonIndices[polygonIndices.length - 1];\n\n\t\t\t\tpolygon = convexPolygons[i];\n\t\t\t\tlet o = polygon.length - 4;\n\t\t\t\tlet prevPrevX = polygon[o], prevPrevY = polygon[o + 1];\n\t\t\t\tlet prevX = polygon[o + 2], prevY = polygon[o + 3];\n\t\t\t\tlet firstX = polygon[0], firstY = polygon[1];\n\t\t\t\tlet secondX = polygon[2], secondY = polygon[3];\n\t\t\t\tlet winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n\n\t\t\t\tfor (let ii = 0; ii < n; ii++) {\n\t\t\t\t\tif (ii == i) continue;\n\t\t\t\t\tlet otherIndices = convexPolygonsIndices[ii];\n\t\t\t\t\tif (otherIndices.length != 3) continue;\n\t\t\t\t\tlet otherFirstIndex = otherIndices[0];\n\t\t\t\t\tlet otherSecondIndex = otherIndices[1];\n\t\t\t\t\tlet otherLastIndex = otherIndices[2];\n\n\t\t\t\t\tlet otherPoly = convexPolygons[ii];\n\t\t\t\t\tlet x3 = otherPoly[otherPoly.length - 2], y3 = otherPoly[otherPoly.length - 1];\n\n\t\t\t\t\tif (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\n\t\t\t\t\tlet winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n\t\t\t\t\tlet winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n\t\t\t\t\tif (winding1 == winding && winding2 == winding) {\n\t\t\t\t\t\totherPoly.length = 0;\n\t\t\t\t\t\totherIndices.length = 0;\n\t\t\t\t\t\tpolygon.push(x3);\n\t\t\t\t\t\tpolygon.push(y3);\n\t\t\t\t\t\tpolygonIndices.push(otherLastIndex);\n\t\t\t\t\t\tprevPrevX = prevX;\n\t\t\t\t\t\tprevPrevY = prevY;\n\t\t\t\t\t\tprevX = x3;\n\t\t\t\t\t\tprevY = y3;\n\t\t\t\t\t\tii = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove empty polygons that resulted from the merge step above.\n\t\t\tfor (let i = convexPolygons.length - 1; i >= 0; i--) {\n\t\t\t\tpolygon = convexPolygons[i];\n\t\t\t\tif (polygon.length == 0) {\n\t\t\t\t\tconvexPolygons.splice(i, 1);\n\t\t\t\t\tthis.polygonPool.free(polygon);\n\t\t\t\t\tpolygonIndices = convexPolygonsIndices[i]\n\t\t\t\t\tconvexPolygonsIndices.splice(i, 1)\n\t\t\t\t\tthis.polygonIndicesPool.free(polygonIndices);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn convexPolygons;\n\t\t}\n\n\t\tprivate static isConcave (index: number, vertexCount: number, vertices: ArrayLike<number>, indices: ArrayLike<number>): boolean {\n\t\t\tlet previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n\t\t\tlet current = indices[index] << 1;\n\t\t\tlet next = indices[(index + 1) % vertexCount] << 1;\n\t\t\treturn !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next],\n\t\t\t\tvertices[next + 1]);\n\t\t}\n\n\t\tprivate static positiveArea (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): boolean {\n\t\t\treturn p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n\t\t}\n\n\t\tprivate static winding (p1x: number, p1y: number, p2x: number, p2y: number, p3x: number, p3y: number): number {\n\t\t\tlet px = p2x - p1x, py = p2y - p1y;\n\t\t\treturn p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n\t\t}\n\t}\n}\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface Updatable {\n        update(): void;\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n    export interface Map<T> {\n        [key: string]: T;\n    }\n\n    export class IntSet {\n        array = new Array<number>();\n\n        add (value: number): boolean {\n            let contains = this.contains(value);\n            this.array[value | 0] = value | 0;\n            return !contains;\n        }\n\n        contains (value: number) {\n            return this.array[value | 0] != undefined;\n        }\n\n        remove (value: number) {\n            this.array[value | 0] = undefined;\n        }\n\n        clear () {\n            this.array.length = 0;\n        }\n    }\n\n    export interface Disposable {\n        dispose (): void;\n    }\n\n    export interface Restorable {\n        restore (): void;\n    }\n\n    export class Color {\n        public static WHITE = new Color(1, 1, 1, 1);\n        public static RED = new Color(1, 0, 0, 1);\n        public static GREEN = new Color(0, 1, 0, 1);\n        public static BLUE = new Color(0, 0, 1, 1);\n        public static MAGENTA = new Color(1, 0, 1, 1);\n\n        constructor (public r: number = 0, public g: number = 0, public b: number = 0, public a: number = 0) {\n        }\n\n        set (r: number, g: number, b: number, a: number) {\n            this.r = r;\n            this.g = g;\n            this.b = b;\n            this.a = a;\n            this.clamp();\n            return this;\n        }\n\n        setFromColor (c: Color) {\n            this.r = c.r;\n            this.g = c.g;\n            this.b = c.b;\n            this.a = c.a;\n            return this;\n        }\n\n        setFromString (hex: string) {\n            hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n            this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n            this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n            this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n            this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n            return this;\n        }\n\n        add (r: number, g: number, b: number, a: number) {\n            this.r += r;\n            this.g += g;\n            this.b += b;\n            this.a += a;\n            this.clamp();\n            return this;\n        }\n\n        clamp () {\n            if (this.r < 0) this.r = 0;\n            else if (this.r > 1) this.r = 1;\n\n            if (this.g < 0) this.g = 0;\n            else if (this.g > 1) this.g = 1;\n\n            if (this.b < 0) this.b = 0;\n            else if (this.b > 1) this.b = 1;\n\n            if (this.a < 0) this.a = 0;\n            else if (this.a > 1) this.a = 1;\n            return this;\n        }\n    }\n\n    export class MathUtils {\n        static PI = 3.1415927;\n        static PI2 = MathUtils.PI * 2;\n        static radiansToDegrees = 180 / MathUtils.PI;\n        static radDeg = MathUtils.radiansToDegrees;\n        static degreesToRadians = MathUtils.PI / 180;\n        static degRad = MathUtils.degreesToRadians;\n\n        static clamp (value: number, min: number, max: number) {\n            if (value < min) return min;\n            if (value > max) return max;\n            return value;\n        }\n\n        static cosDeg (degrees: number) {\n            return Math.cos(degrees * MathUtils.degRad);\n        }\n\n        static sinDeg (degrees: number) {\n            return Math.sin(degrees * MathUtils.degRad);\n        }\n\n        static signum (value: number): number {\n            return value > 0 ? 1 : value < 0 ? -1 : 0;\n        }\n\n        static toInt (x: number) {\n            return x > 0 ? Math.floor(x) : Math.ceil(x);\n        }\n\n        static cbrt (x: number) {\n            let y = Math.pow(Math.abs(x), 1/3);\n            return x < 0 ? -y : y;\n        }\n\n        static randomTriangular (min: number, max: number): number {\n            return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n        }\n\n        static randomTriangularWith (min: number, max: number, mode: number): number {\n            let u = Math.random();\n            let d = max - min;\n            if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n            return max - Math.sqrt((1 - u) * d * (max - mode));\n        }\n    }\n\n    export abstract class Interpolation {\n        protected abstract applyInternal (a: number): number;\n        apply(start: number, end: number, a: number): number {\n            return start + (end - start) * this.applyInternal(a);\n        }\n    }\n\n    export class Pow extends Interpolation {\n        protected power = 2;\n\n        constructor (power: number) {\n            super();\n            this.power = power;\n        }\n\n        applyInternal (a: number): number {\n            if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n            return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n        }\n    }\n\n    export class PowOut extends Pow {\n        constructor (power: number) {\n            super(power);\n        }\n\n        applyInternal (a: number) : number {\n            return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n        }\n    }\n\n    export class Utils {\n        static SUPPORTS_TYPED_ARRAYS = typeof(Float32Array) !== \"undefined\";\n\n        static arrayCopy<T> (source: ArrayLike<T>, sourceStart: number, dest: ArrayLike<T>, destStart: number, numElements: number) {\n            for (let i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n                dest[j] = source[i];\n            }\n        }\n\n        static setArraySize<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n            let oldSize = array.length;\n            if (oldSize == size) return array;\n            array.length = size;\n            if (oldSize < size) {\n                for (let i = oldSize; i < size; i++) array[i] = value;\n            }\n            return array;\n        }\n\n        static ensureArrayCapacity<T> (array: Array<T>, size: number, value: any = 0): Array<T> {\n            if (array.length >= size) return array;\n            return Utils.setArraySize(array, size, value);\n        }\n\n        static newArray<T> (size: number, defaultValue: T): Array<T> {\n            let array = new Array<T>(size);\n            for (let i = 0; i < size; i++) array[i] = defaultValue;\n            return array;\n        }\n\n        static newFloatArray (size: number): ArrayLike<number> {\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                return new Float32Array(size)\n            } else {\n                let array = new Array<number>(size);\n                for (let i = 0; i < array.length; i++) array[i] = 0;\n                return array;\n            }\n        }\n\n        static newShortArray (size: number): ArrayLike<number> {\n            if (Utils.SUPPORTS_TYPED_ARRAYS) {\n                return new Int16Array(size)\n            } else {\n                let array = new Array<number>(size);\n                for (let i = 0; i < array.length; i++) array[i] = 0;\n                return array;\n            }\n        }\n\n        static toFloatArray (array: Array<number>) {\n            return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n        }\n\n        static toSinglePrecision (value: number) {\n            return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n        }\n    }\n\n    export class DebugUtils {\n        static logBones(skeleton: Skeleton) {\n            for (let i = 0; i < skeleton.bones.length; i++) {\n                let bone = skeleton.bones[i];\n                let mat = bone.matrix;\n                console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\n            }\n        }\n    }\n\n    export class Pool<T> {\n        private items = new Array<T>();\n        private instantiator: () => T;\n\n        constructor (instantiator: () => T) {\n            this.instantiator = instantiator;\n        }\n\n        obtain () {\n            return this.items.length > 0 ? this.items.pop() : this.instantiator();\n        }\n\n        free (item: T) {\n            if ((item as any).reset) (item as any).reset();\n            this.items.push(item);\n        }\n\n        freeAll (items: ArrayLike<T>) {\n            for (let i = 0; i < items.length; i++) {\n                if ((items[i] as any).reset) (items[i] as any).reset();\n                this.items[i] = items[i];\n            }\n        }\n\n        clear () {\n            this.items.length = 0;\n        }\n    }\n\n    export class Vector2 {\n        constructor (public x = 0, public y = 0) {\n        }\n\n        set (x: number, y: number): Vector2 {\n            this.x = x;\n            this.y = y;\n            return this;\n        }\n\n        length () {\n            let x = this.x;\n            let y = this.y;\n            return Math.sqrt(x * x + y * y);\n        }\n\n        normalize () {\n            let len = this.length();\n            if (len != 0) {\n                this.x /= len;\n                this.y /= len;\n            }\n            return this;\n        }\n    }\n\n    export class TimeKeeper {\n        maxDelta = 0.064;\n        framesPerSecond = 0;\n        delta = 0;\n        totalTime = 0;\n\n        private lastTime = Date.now() / 1000;\n        private frameCount = 0;\n        private frameTime = 0;\n\n        update () {\n            var now = Date.now() / 1000;\n            this.delta = now - this.lastTime;\n            this.frameTime += this.delta;\n            this.totalTime += this.delta;\n            if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n            this.lastTime = now;\n\n            this.frameCount++;\n            if (this.frameTime > 1) {\n                this.framesPerSecond = this.frameCount / this.frameTime;\n                this.frameTime = 0;\n                this.frameCount = 0;\n            }\n        }\n    }\n\n    export interface ArrayLike<T> {\n        length: number;\n        [n: number]: T;\n    }\n\n    export class WindowedMean {\n        values: Array<number>;\n        addedValues = 0;\n        lastValue = 0;\n        mean = 0;\n        dirty = true;\n\n        constructor (windowSize: number = 32) {\n            this.values = new Array<number>(windowSize);\n        }\n\n        hasEnoughData () {\n            return this.addedValues >= this.values.length;\n        }\n\n        addValue (value: number) {\n            if (this.addedValues < this.values.length)\n                this.addedValues++;\n            this.values[this.lastValue++] = value;\n            if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n            this.dirty = true;\n        }\n\n        getMean () {\n            if (this.hasEnoughData()) {\n                if (this.dirty) {\n                    let mean = 0;\n                    for (let i = 0; i < this.values.length; i++) {\n                        mean += this.values[i];\n                    }\n                    this.mean = mean / this.values.length;\n                    this.dirty = false;\n                }\n                return this.mean;\n            } else {\n                return 0;\n            }\n        }\n    }\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport interface VertexEffect {\n\t\tbegin(skeleton: Skeleton): void;\n\t\ttransform(position: Vector2, uv: Vector2, light: Color, dark: Color): void;\n\t\tend(): void;\n\t}\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport class JitterEffect implements VertexEffect {\n\t\tjitterX = 0;\n\t\tjitterY = 0;\n\n\t\tconstructor (jitterX: number, jitterY: number) {\n\t\t\tthis.jitterX = jitterX;\n\t\t\tthis.jitterY = jitterY;\n\t\t}\n\n\t\tbegin(skeleton: Skeleton): void {\n\t\t}\n\n\t\ttransform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n\t\t\tposition.x += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n\t\t\tposition.y += MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n\t\t}\n\n\t\tend(): void {\n\t\t}\n\t}\n}\n/******************************************************************************\n * Spine Runtimes Software License v2.5\n *\n * Copyright (c) 2013-2016, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable, and\n * non-transferable license to use, install, execute, and perform the Spine\n * Runtimes software and derivative works solely for personal or internal\n * use. Without the written permission of Esoteric Software (see Section 2 of\n * the Spine Software License Agreement), you may not (a) modify, translate,\n * adapt, or develop new applications using the Spine Runtimes or otherwise\n * create derivative works or improvements of the Spine Runtimes or (b) remove,\n * delete, alter, or obscure any trademarks or any copyright, trademark, patent,\n * or other intellectual property or proprietary rights notices on or in the\n * Software, including any copy thereof. Redistributions in binary or source\n * form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, BUSINESS INTERRUPTION, OR LOSS OF\n * USE, DATA, OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\n * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nnamespace pixi_spine.core {\n\texport class SwirlEffect implements VertexEffect {\n\t\tstatic interpolation = new PowOut(2);\n\t\tcenterX = 0;\n\t\tcenterY = 0;\n\t\tradius = 0;\n\t\tangle = 0;\n\t\tprivate worldX = 0;\n\t\tprivate worldY = 0;\n\n\t\tconstructor (radius: number) {\n\t\t\tthis.radius = radius;\n\t\t}\n\n\t\tbegin(skeleton: Skeleton): void {\n\t\t\tthis.worldX = skeleton.x + this.centerX;\n\t\t\tthis.worldY = skeleton.y + this.centerY;\n\t\t}\n\n\t\ttransform(position: Vector2, uv: Vector2, light: Color, dark: Color): void {\n\t\t\tlet radAngle = this.angle * MathUtils.degreesToRadians;\n\t\t\tlet x = position.x - this.worldX;\n\t\t\tlet y = position.y - this.worldY;\n\t\t\tlet dist = Math.sqrt(x * x + y * y);\n\t\t\tif (dist < this.radius) {\n\t\t\t\tlet theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n\t\t\t\tlet cos = Math.cos(theta);\n\t\t\t\tlet sin = Math.sin(theta);\n\t\t\t\tposition.x = cos * x - sin * y + this.worldX;\n\t\t\t\tposition.y = sin * x + cos * y + this.worldY;\n\t\t\t}\n\t\t}\n\n\t\tend(): void {\n\t\t}\n\t}\n}\nnamespace pixi_spine {\n    function isJson(resource: PIXI.loaders.Resource) {\n        var TYPE = (PIXI.loaders.Resource as any).TYPE;\n        if (TYPE) {\n            return (resource as any).type === TYPE.JSON\n        }\n        return resource.isJson;\n    }\n\n    export function atlasParser() {\n        return function (resource: PIXI.loaders.Resource, next: () => any) {\n            // skip if no data, its not json, or it isn't atlas data\n            if (!resource.data ||\n                !isJson(resource) ||\n                !resource.data.bones) {\n                return next();\n            }\n            const metadata = resource.metadata || {};\n            const metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;\n\n            const metadataAtlas = metadata ? resource.metadata.spineAtlas : null;\n            if (metadataAtlas === false) {\n                return next();\n            }\n            if (metadataAtlas && metadataAtlas.pages) {\n                //its an atlas!\n                var spineJsonParser = new core.SkeletonJson(new core.AtlasAttachmentLoader(metadataAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n                resource.spineData = skeletonData;\n                resource.spineAtlas = metadataAtlas;\n\n                return next();\n            }\n\n            const metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\n\n            /**\n             * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n             * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n             * have the same name\n             */\n            let atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\n            //remove the baseUrl\n            atlasPath = atlasPath.replace(this.baseUrl, '');\n\n            const atlasOptions = {\n                crossOrigin: resource.crossOrigin,\n                xhrType: PIXI.loaders.Resource.XHR_RESPONSE_TYPE.TEXT,\n                metadata: metadata.spineMetadata || null,\n                parentResource: resource\n            };\n            const imageOptions = {\n                crossOrigin: resource.crossOrigin,\n                metadata: metadata.imageMetadata || null,\n                parentResource: resource\n            };\n            let baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n            //remove the baseUrl\n            baseUrl = baseUrl.replace(this.baseUrl, '');\n\n            const adapter = metadata.images ? staticImageLoader(metadata.images)\n                : metadata.image ? staticImageLoader({'default': metadata.image})\n                : metadata.imageLoader ? metadata.imageLoader(this, resource.name + '_atlas_page_', baseUrl, imageOptions)\n                    : imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n\n            this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource: PIXI.loaders.Resource) {\n                new core.TextureAtlas(atlasResource.xhr.responseText, adapter, function (spineAtlas) {\n                    let spineJsonParser = new core.SkeletonJson(new core.AtlasAttachmentLoader(spineAtlas));\n                    if (metadataSkeletonScale) {\n                        spineJsonParser.scale = metadataSkeletonScale;\n                    }\n                    resource.spineData = spineJsonParser.readSkeletonData(resource.data);\n                    resource.spineAtlas = spineAtlas;\n\n                    next();\n                });\n            });\n        };\n    }\n\n    export function imageLoaderAdapter(loader: any, namePrefix: any, baseUrl: any, imageOptions: any) {\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\n            baseUrl += '/';\n        }\n        return function (line: string, callback: (baseTexture: PIXI.BaseTexture) => any) {\n            const name = namePrefix + line;\n            const url = baseUrl + line;\n            loader.add(name, url, imageOptions, (resource: PIXI.loaders.Resource) => {\n                callback(resource.texture.baseTexture);\n            });\n        }\n    }\n\n    export function syncImageLoaderAdapter(baseUrl: any, crossOrigin: any) {\n        if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length - 1)) {\n            baseUrl += '/';\n        }\n        return function (line: any, callback: any) {\n            callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n        }\n    }\n\n    export function staticImageLoader(pages: { [key: string]: (PIXI.BaseTexture | PIXI.Texture) }) {\n        return function (line: any, callback: any) {\n            let page = pages[line] || pages['default'] as any;\n            if (page && page.baseTexture)\n                callback(page.baseTexture);\n            else\n                callback(page);\n        }\n    }\n\n    PIXI.loaders.Loader.addPixiMiddleware(atlasParser);\n    PIXI.loader.use(atlasParser());\n}\ninterface Math {\n    fround(n: number): number;\n}\n\n(() => {\n    if (!Math.fround) {\n        Math.fround = Math.fround = (function(array) {\n            return function(x: number) {\n                return array[0] = x, array[0];\n            };\n        })(new Float32Array(1));\n    }\n})();\n/// <reference types=\"pixi.js\" />\n/// <reference path=\"polyfills.ts\" />\nnamespace pixi_spine {\n    /* Esoteric Software SPINE wrapper for pixi.js */\n    core.Bone.yDown = true;\n\n    let tempRgb = [0, 0, 0];\n\n    export class SpineSprite extends PIXI.Sprite {\n        region: core.TextureRegion;\n\n        constructor(tex: PIXI.Texture) {\n            super(tex);\n        }\n    }\n\n    export class SpineMesh extends PIXI.mesh.Mesh {\n        region: core.TextureRegion;\n\n        constructor(texture: PIXI.Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\n            super(texture, vertices, uvs, indices, drawMode);\n        }\n    }\n\n    /**\n     * A class that enables the you to import and run your spine animations in pixi.\n     * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n     * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n     *\n     * ```js\n     * let spineAnimation = new spine(spineData);\n     * ```\n     *\n     * @class\n     * @extends Container\n     * @memberof spine\n     * @param spineData {object} The spine data loaded from a spine atlas.\n     */\n    export class Spine extends PIXI.Container {\n        static globalAutoUpdate: boolean = true;\n\n        tintRgb: ArrayLike<number>;\n        spineData: core.SkeletonData;\n        skeleton: core.Skeleton;\n        stateData: core.AnimationStateData;\n        state: core.AnimationState;\n        slotContainers: Array<PIXI.Container>;\n        tempClipContainers: Array<PIXI.Container>;\n\n        constructor(spineData: core.SkeletonData) {\n            super();\n\n            if (!spineData) {\n                throw new Error('The spineData param is required.');\n            }\n\n            if ((typeof spineData) === \"string\") {\n                throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n            }\n\n            /**\n             * The spineData object\n             *\n             * @member {object}\n             */\n            this.spineData = spineData;\n\n            /**\n             * A spine Skeleton object\n             *\n             * @member {object}\n             */\n            this.skeleton = new core.Skeleton(spineData);\n            this.skeleton.updateWorldTransform();\n\n            /**\n             * A spine AnimationStateData object created from the spine data passed in the constructor\n             *\n             * @member {object}\n             */\n            this.stateData = new core.AnimationStateData(spineData);\n\n            /**\n             * A spine AnimationState object created from the spine AnimationStateData object\n             *\n             * @member {object}\n             */\n            this.state = new core.AnimationState(this.stateData);\n\n            /**\n             * An array of containers\n             *\n             * @member {Container[]}\n             */\n            this.slotContainers = [];\n\n            this.tempClipContainers = [];\n\n            for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n                let slot = this.skeleton.slots[i];\n                let attachment: any = slot.attachment;\n                let slotContainer = new PIXI.Container();\n                this.slotContainers.push(slotContainer);\n                this.addChild(slotContainer);\n                this.tempClipContainers.push(null);\n\n                if (attachment instanceof core.RegionAttachment) {\n                    let spriteName = (attachment.region as core.TextureAtlasRegion).name;\n                    let sprite = this.createSprite(slot, attachment, spriteName);\n                    slot.currentSprite = sprite;\n                    slot.currentSpriteName = spriteName;\n                    slotContainer.addChild(sprite);\n                }\n                else if (attachment instanceof core.MeshAttachment) {\n                    let mesh = this.createMesh(slot, attachment);\n                    slot.currentMesh = mesh;\n                    slot.currentMeshName = attachment.name;\n                    slotContainer.addChild(mesh);\n                }\n                else if (attachment instanceof core.ClippingAttachment) {\n                    this.createGraphics(slot, attachment);\n                    slotContainer.addChild(slot.clippingContainer);\n                    slotContainer.addChild(slot.currentGraphics);\n                }\n                else {\n                    continue;\n                }\n\n            }\n\n            /**\n             * Should the Spine object update its transforms\n             *\n             * @member {boolean}\n             */\n            this.autoUpdate = true;\n\n            /**\n             * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n             *\n             * @member {number}\n             * @memberof spine.Spine#\n             */\n            this.tintRgb = new Float32Array([1, 1, 1]);\n        }\n\n        /**\n         * If this flag is set to true, the spine animation will be autoupdated every time\n         * the object id drawn. The down side of this approach is that the delta time is\n         * automatically calculated and you could miss out on cool effects like slow motion,\n         * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n         * autoupdate enabled but are harder to achieve.\n         *\n         * @member {boolean}\n         * @memberof spine.Spine#\n         * @default true\n         */\n        get autoUpdate(): boolean {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        }\n\n        set autoUpdate(value: boolean) {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n\n        /**\n         * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof spine.Spine#\n         * @default 0xFFFFFF\n         */\n        get tint(): number {\n            return PIXI.utils.rgb2hex(this.tintRgb as any);\n        }\n\n        set tint(value: number) {\n            this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb as any);\n        }\n\n        /**\n         * Update the spine skeleton and its animations by delta time (dt)\n         *\n         * @param dt {number} Delta time. Time by which the animation should be updated\n         */\n        update(dt: number) {\n            this.state.update(dt);\n            this.state.apply(this.skeleton);\n            this.skeleton.updateWorldTransform();\n\n            let slots = this.skeleton.slots;\n\n            let r0 = this.tintRgb[0];\n            let g0 = this.tintRgb[1];\n            let b0 = this.tintRgb[2];\n\n            for (let i = 0, n = slots.length; i < n; i++) {\n                let slot = slots[i];\n                let attachment = slot.attachment;\n                let slotContainer = this.slotContainers[i];\n\n                if (!attachment) {\n                    slotContainer.visible = false;\n                    continue;\n                }\n\n                let attColor = (attachment as any).color;\n                if (attachment instanceof core.RegionAttachment) {\n                    let region = (attachment as core.RegionAttachment).region;\n                    if (region) {\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                            slot.currentMesh = null;\n                            slot.currentMeshName = undefined;\n                        }\n                        let ar = region as core.TextureAtlasRegion;\n                        if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n                            let spriteName = ar.name;\n                            if (slot.currentSprite) {\n                                slot.currentSprite.visible = false;\n                            }\n                            slot.sprites = slot.sprites || {};\n                            if (slot.sprites[spriteName] !== undefined) {\n                                slot.sprites[spriteName].visible = true;\n                            }\n                            else {\n                                let sprite = this.createSprite(slot, attachment, spriteName);\n                                slotContainer.addChild(sprite);\n                            }\n                            slot.currentSprite = slot.sprites[spriteName];\n                            slot.currentSpriteName = spriteName;\n                        }\n                    }\n\n                    if (slotContainer.transform) {\n                        //TODO: refactor this thing, switch it on and off for container\n                        let transform = slotContainer.transform;\n                        let transAny: any = transform;\n                        let lt: PIXI.Matrix = null;\n                        if (transAny.matrix2d) {\n                            //gameofbombs pixi fork, sorry for that, we really use it :)\n                            lt = transAny.matrix2d;\n                            transAny._dirtyVersion++;\n                            transAny.version = transAny._dirtyVersion;\n                            transAny.isStatic = true;\n                            transAny.operMode = 0;\n                        } else {\n                            if (PIXI.TransformBase) {\n                                if (transAny.position) {\n                                    transform = new PIXI.TransformBase();\n                                    slotContainer.transform = transform;\n                                }\n                                lt = transform.localTransform;\n                            } else {\n                                // if (transAny.autoUpdateLocal) {\n                                //     transAny.autoUpdateLocal = false;\n                                // }\n                                transAny.setFromMatrix(slot.bone.matrix);\n                            }\n                        }\n                        if (lt) {\n                            slot.bone.matrix.copy(lt);\n                        }\n                    } else {\n                        //PIXI v3\n                        let lt = slotContainer.localTransform || new PIXI.Matrix();\n                        slot.bone.matrix.copy(lt);\n                        slotContainer.localTransform = lt;\n                        (slotContainer as any).displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n                    }\n                    tempRgb[0] = r0 * slot.color.r * attColor.r;\n                    tempRgb[1] = g0 * slot.color.g * attColor.g;\n                    tempRgb[2] = b0 * slot.color.b * attColor.b;\n                    slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n                    slot.currentSprite.blendMode = slot.blendMode;\n                }\n                else if (attachment instanceof core.MeshAttachment) {\n                    if (slot.currentSprite) {\n                        //TODO: refactor this thing, switch it on and off for container\n                        slot.currentSprite.visible = false;\n                        slot.currentSprite = null;\n                        slot.currentSpriteName = undefined;\n\n                        if (slotContainer.transform) {\n                            slotContainer.transform = new PIXI.TransformStatic();\n                        }\n                        else {\n                            slotContainer.localTransform = new PIXI.Matrix();\n                            (slotContainer as any).displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;\n                        }\n                    }\n                    if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n                        let meshName = attachment.name;\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                        }\n\n                        slot.meshes = slot.meshes || {};\n\n                        if (slot.meshes[meshName] !== undefined) {\n                            slot.meshes[meshName].visible = true;\n                        }\n                        else {\n                            let mesh = this.createMesh(slot, attachment);\n                            slotContainer.addChild(mesh);\n                        }\n\n                        slot.currentMesh = slot.meshes[meshName];\n                        slot.currentMeshName = meshName;\n                    }\n                    (attachment as core.VertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n                    if (PIXI.VERSION[0] !== '3') {\n                        // PIXI version 4\n                        // slot.currentMesh.dirty++;\n                        //only for PIXI v4\n                        let tintRgb = slot.currentMesh.tintRgb;\n                        tintRgb[0] = r0 * slot.color.r * attColor.r;\n                        tintRgb[1] = g0 * slot.color.g * attColor.g;\n                        tintRgb[2] = b0 * slot.color.b * attColor.b;\n                    }\n                    slot.currentMesh.blendMode = slot.blendMode;\n                }\n                else if (attachment instanceof core.ClippingAttachment) {\n                    if (!slot.currentGraphics) {\n                        this.createGraphics(slot, attachment);\n                        slotContainer.addChild(slot.clippingContainer);\n                        slotContainer.addChild(slot.currentGraphics);\n                    }\n                    this.updateGraphics(slot, attachment);\n                }\n                else {\n                    slotContainer.visible = false;\n                    continue;\n                }\n                slotContainer.visible = true;\n\n                slotContainer.alpha = slot.color.a;\n            }\n\n\n            //== this is clipping implementation ===\n            //TODO: remove parent hacks when pixi masks allow it\n            let drawOrder = this.skeleton.drawOrder;\n            let clippingAttachment: core.ClippingAttachment = null;\n            let clippingContainer: PIXI.Container = null;\n\n            for (let i = 0, n = drawOrder.length; i < n; i++) {\n                let slot = slots[drawOrder[i].data.index];\n                let slotContainer = this.slotContainers[drawOrder[i].data.index];\n\n                if (!clippingContainer) {\n                    if (slotContainer.parent !== this) {\n                        slotContainer.parent.removeChild(slotContainer);\n                        //silend add hack\n                        slotContainer.parent = this;\n                    }\n                }\n                if (slot.currentGraphics) {\n                    clippingContainer = slot.clippingContainer;\n                    clippingAttachment = slot.attachment as core.ClippingAttachment;\n                    clippingContainer.children.length = 0;\n                    this.children[i] = slotContainer;\n\n                    if (clippingAttachment.endSlot == slot.data) {\n                        clippingContainer.renderable = false;\n                        clippingContainer = null;\n                        clippingAttachment = null;\n                    }\n\n                } else {\n                    if (clippingContainer) {\n                        let c = this.tempClipContainers[i];\n                        if (!c) {\n                            c = this.tempClipContainers[i] = new PIXI.Container();\n                            c.visible = false;\n                        }\n                        this.children[i] = c;\n\n                        //silent remove hack\n                        slotContainer.parent = null;\n                        clippingContainer.addChild(slotContainer);\n                        if (clippingAttachment.endSlot == slot.data) {\n                            clippingContainer.renderable = true;\n                            clippingContainer = null;\n                            clippingAttachment = null;\n                        }\n                    } else {\n                        this.children[i] = slotContainer;\n                    }\n                }\n            }\n        };\n\n        private setSpriteRegion(attachment: core.RegionAttachment, sprite: SpineSprite, region: core.TextureRegion) {\n            sprite.region = region;\n            sprite.texture = region.texture;\n            if (!region.size) {\n                sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n                sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n            } else {\n                //hacked!\n                sprite.scale.x = region.size.width / region.originalWidth;\n                sprite.scale.y = -region.size.height / region.originalHeight;\n            }\n        }\n\n        private setMeshRegion(attachment: core.MeshAttachment, mesh: SpineMesh, region: core.TextureRegion) {\n            mesh.region = region;\n            mesh.texture = region.texture;\n            attachment.updateUVs(region, mesh.uvs);\n            // if (PIXI.VERSION[0] !== '3') {\n            // PIXI version 4\n            // mesh.indexDirty++;\n            // } else {\n            // PIXI version 3\n            mesh.dirty++;\n            // }\n        }\n\n        protected lastTime: number;\n\n        /**\n         * When autoupdate is set to yes this function is used as pixi's updateTransform function\n         *\n         * @private\n         */\n        autoUpdateTransform() {\n            if (Spine.globalAutoUpdate) {\n                this.lastTime = this.lastTime || Date.now();\n                let timeDelta = (Date.now() - this.lastTime) * 0.001;\n                this.lastTime = Date.now();\n                this.update(timeDelta);\n            } else {\n                this.lastTime = 0;\n            }\n\n            PIXI.Container.prototype.updateTransform.call(this);\n        };\n\n        /**\n         * Create a new sprite to be used with core.RegionAttachment\n         *\n         * @param slot {spine.Slot} The slot to which the attachment is parented\n         * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n         * @private\n         */\n        createSprite(slot: core.Slot, attachment: core.RegionAttachment, defName: string) {\n            let region = attachment.region;\n            if (slot.tempAttachment === attachment) {\n                region = slot.tempRegion;\n                slot.tempAttachment = null;\n                slot.tempRegion = null;\n            }\n            let texture = region.texture;\n            let sprite = new SpineSprite(texture);\n            sprite.rotation = attachment.rotation * core.MathUtils.degRad;\n            sprite.anchor.x = 0.5;\n            sprite.anchor.y = 0.5;\n            sprite.position.x = attachment.x;\n            sprite.position.y = attachment.y;\n            sprite.alpha = attachment.color.a;\n\n            sprite.region = attachment.region;\n            this.setSpriteRegion(attachment, sprite, attachment.region);\n\n            slot.sprites = slot.sprites || {};\n            slot.sprites[defName] = sprite;\n            return sprite;\n        };\n\n        /**\n         * Creates a Strip from the spine data\n         * @param slot {spine.Slot} The slot to which the attachment is parented\n         * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n         * @private\n         */\n        createMesh(slot: core.Slot, attachment: core.MeshAttachment) {\n            let region = attachment.region;\n            if (slot.tempAttachment === attachment) {\n                region = slot.tempRegion;\n                slot.tempAttachment = null;\n                slot.tempRegion = null;\n            }\n            let strip = new SpineMesh(\n                region.texture,\n                new Float32Array(attachment.regionUVs.length),\n                new Float32Array(attachment.regionUVs.length),\n                new Uint16Array(attachment.triangles),\n                PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n            strip.canvasPadding = 1.5;\n\n            strip.alpha = attachment.color.a;\n\n            strip.region = attachment.region;\n            this.setMeshRegion(attachment, strip, region);\n\n            slot.meshes = slot.meshes || {};\n            slot.meshes[attachment.name] = strip;\n            return strip;\n        };\n\n        static clippingPolygon: Array<number> = [];\n\n        createGraphics(slot: core.Slot, clip: core.ClippingAttachment) {\n            let graphics = new PIXI.Graphics();\n            let poly = new PIXI.Polygon([]);\n            graphics.clear();\n            graphics.beginFill(0xffffff, 1);\n            graphics.drawPolygon(poly as any);\n            graphics.renderable = false;\n            slot.currentGraphics = graphics;\n            slot.clippingContainer = new PIXI.Container();\n            slot.clippingContainer.mask = slot.currentGraphics;\n\n            return graphics;\n        }\n\n        updateGraphics(slot: core.Slot, clip: core.ClippingAttachment) {\n            let vertices = (slot.currentGraphics.graphicsData[0].shape as PIXI.Polygon).points;\n            let n = clip.worldVerticesLength;\n            vertices.length = n;\n            clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n            slot.currentGraphics.dirty++;\n            slot.currentGraphics.clearDirty++;\n        }\n\n        /**\n         * Changes texture in attachment in specific slot.\n         *\n         * PIXI runtime feature, it was made to satisfy our users.\n         *\n         * @param slotIndex {number}\n         * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n         * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n         * @returns {boolean} Success flag\n         */\n        hackTextureBySlotIndex(slotIndex: number, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n            let slot = this.skeleton.slots[slotIndex];\n            if (!slot) {\n                return false;\n            }\n            let attachment: any = slot.attachment;\n            let region: core.TextureRegion = attachment.region;\n            if (texture) {\n                region = new core.TextureRegion();\n                region.texture = texture;\n                region.size = size;\n            }\n            if (slot.currentSprite && slot.currentSprite.region != region) {\n                this.setSpriteRegion(attachment, slot.currentSprite, region);\n                slot.currentSprite.region = region;\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\n                this.setMeshRegion(attachment, slot.currentMesh, region);\n            } else {\n                slot.tempRegion = region;\n                slot.tempAttachment = attachment;\n            }\n            return true;\n        }\n\n        /**\n         * Changes texture in attachment in specific slot.\n         *\n         * PIXI runtime feature, it was made to satisfy our users.\n         *\n         * @param slotName {string}\n         * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n         * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n         * @returns {boolean} Success flag\n         */\n        hackTextureBySlotName = function (slotName: string, texture: PIXI.Texture = null, size: PIXI.Rectangle = null) {\n            let index = this.skeleton.findSlotIndex(slotName);\n            if (index == -1) {\n                return false;\n            }\n            return this.hackTextureBySlotIndex(index, texture, size);\n        }\n    }\n\n    function SlotContainerUpdateTransformV3() {\n        let pt = this.parent.worldTransform;\n        let wt = this.worldTransform;\n        let lt = this.localTransform;\n        wt.a = lt.a * pt.a + lt.b * pt.c;\n        wt.b = lt.a * pt.b + lt.b * pt.d;\n        wt.c = lt.c * pt.a + lt.d * pt.c;\n        wt.d = lt.c * pt.b + lt.d * pt.d;\n        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n        this._currentBounds = null;\n    }\n}\n(PIXI as any).spine = pixi_spine;\n\n\n\n// WEBPACK FOOTER //\n// ../compilation.ts","module.exports = { \"default\": require(\"core-js/library/fn/math/fround\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/math/fround.js\n// module id = 74\n// module chunks = 0","require('../../modules/es6.math.fround');\nmodule.exports = require('../../modules/_core').Math.fround;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/math/fround.js\n// module id = 75\n// module chunks = 0","// 20.2.2.16 Math.fround(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', { fround: require('./_math-fround') });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.math.fround.js\n// module id = 76\n// module chunks = 0","// 20.2.2.16 Math.fround(x)\nvar sign = require('./_math-sign');\nvar pow = Math.pow;\nvar EPSILON = pow(2, -52);\nvar EPSILON32 = pow(2, -23);\nvar MAX32 = pow(2, 127) * (2 - EPSILON32);\nvar MIN32 = pow(2, -126);\n\nvar roundTiesToEven = function (n) {\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\nmodule.exports = Math.fround || function fround(x) {\n  var $abs = Math.abs(x);\n  var $sign = sign(x);\n  var a, result;\n  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n  a = (1 + EPSILON32 / EPSILON) * $abs;\n  result = a - (a - $abs);\n  // eslint-disable-next-line no-self-compare\n  if (result > MAX32 || result != result) return $sign * Infinity;\n  return $sign * result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_math-fround.js\n// module id = 77\n// module chunks = 0","// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x) {\n  // eslint-disable-next-line no-self-compare\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_math-sign.js\n// module id = 78\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/object/create\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/object/create.js\n// module id = 79\n// module chunks = 0","require('../../modules/es6.object.create');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/object/create.js\n// module id = 80\n// module chunks = 0","var $export = require('./_export');\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: require('./_object-create') });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.object.create.js\n// module id = 81\n// module chunks = 0","module.exports = { \"default\": require(\"core-js/library/fn/object/set-prototype-of\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/object/set-prototype-of.js\n// module id = 82\n// module chunks = 0","require('../../modules/es6.object.set-prototype-of');\nmodule.exports = require('../../modules/_core').Object.setPrototypeOf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/object/set-prototype-of.js\n// module id = 83\n// module chunks = 0","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.object.set-prototype-of.js\n// module id = 84\n// module chunks = 0","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object');\nvar anObject = require('./_an-object');\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_set-proto.js\n// module id = 85\n// module chunks = 0","var pIE = require('./_object-pie');\nvar createDesc = require('./_property-desc');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar has = require('./_has');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_object-gopd.js\n// module id = 86\n// module chunks = 0","import loader from './loader'\n\nconst newSpine = (spineName) => {\n    let data = loader.loadSkeleton(spineName)\n    let spine = new PIXI.spine.Spine(data)\n    let setup = ysp.Spine.SETUP[spineName]\n\n    spine.update = function (dt) {\n        // hax: Container shouldn't call this without dt\n        if (dt) {\n            PIXI.spine.Spine.prototype.update.call(this, dt)\n        }\n    }\n\n    if (setup.initAnimation.autoplay) {\n        spine.state.setAnimation(0, setup.initAnimation.name, setup.initAnimation.loop)\n    }\n    spine.skeleton.setSkinByName(setup.skin)\n\n    return spine\n}\n\nconst playAnimation = (spine, animationName, loop) => {\n    spine.state.setAnimation(0, animationName, loop)\n}\n\nconst setSkinByName = (spine, skinName) => {\n    spine.skeleton.setSkinByName(skinName)\n}\n\nexport default {\n    newSpine,\n    playAnimation,\n    setSkinByName,\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Spine/spine.js","module.exports = { \"default\": require(\"core-js/library/fn/promise\"), __esModule: true };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/core-js/promise.js\n// module id = 88\n// module chunks = 0","require('../modules/es6.object.to-string');\nrequire('../modules/es6.string.iterator');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.promise');\nrequire('../modules/es7.promise.finally');\nrequire('../modules/es7.promise.try');\nmodule.exports = require('../modules/_core').Promise;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/fn/promise.js\n// module id = 89\n// module chunks = 0","'use strict';\nvar LIBRARY = require('./_library');\nvar global = require('./_global');\nvar ctx = require('./_ctx');\nvar classof = require('./_classof');\nvar $export = require('./_export');\nvar isObject = require('./_is-object');\nvar aFunction = require('./_a-function');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar speciesConstructor = require('./_species-constructor');\nvar task = require('./_task').set;\nvar microtask = require('./_microtask')();\nvar newPromiseCapabilityModule = require('./_new-promise-capability');\nvar perform = require('./_perform');\nvar promiseResolve = require('./_promise-resolve');\nvar PROMISE = 'Promise';\nvar TypeError = global.TypeError;\nvar process = global.process;\nvar $Promise = global[PROMISE];\nvar isNode = classof(process) == 'process';\nvar empty = function () { /* empty */ };\nvar Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\nvar newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n\nvar USE_NATIVE = !!function () {\n  try {\n    // correct subclassing with @@species support\n    var promise = $Promise.resolve(1);\n    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {\n      exec(empty, empty);\n    };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch (e) { /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = LIBRARY ? function (a, b) {\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n} : function (a, b) {\n  return a === b;\n};\nvar isThenable = function (it) {\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, isReject) {\n  if (promise._n) return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function () {\n    var value = promise._v;\n    var ok = promise._s == 1;\n    var i = 0;\n    var run = function (reaction) {\n      var handler = ok ? reaction.ok : reaction.fail;\n      var resolve = reaction.resolve;\n      var reject = reaction.reject;\n      var domain = reaction.domain;\n      var result, then;\n      try {\n        if (handler) {\n          if (!ok) {\n            if (promise._h == 2) onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if (handler === true) result = value;\n          else {\n            if (domain) domain.enter();\n            result = handler(value);\n            if (domain) domain.exit();\n          }\n          if (result === reaction.promise) {\n            reject(TypeError('Promise-chain cycle'));\n          } else if (then = isThenable(result)) {\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch (e) {\n        reject(e);\n      }\n    };\n    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if (isReject && !promise._h) onUnhandled(promise);\n  });\n};\nvar onUnhandled = function (promise) {\n  task.call(global, function () {\n    var value = promise._v;\n    var unhandled = isUnhandled(promise);\n    var result, handler, console;\n    if (unhandled) {\n      result = perform(function () {\n        if (isNode) {\n          process.emit('unhandledRejection', value, promise);\n        } else if (handler = global.onunhandledrejection) {\n          handler({ promise: promise, reason: value });\n        } else if ((console = global.console) && console.error) {\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if (unhandled && result.e) throw result.v;\n  });\n};\nvar isUnhandled = function (promise) {\n  if (promise._h == 1) return false;\n  var chain = promise._a || promise._c;\n  var i = 0;\n  var reaction;\n  while (chain.length > i) {\n    reaction = chain[i++];\n    if (reaction.fail || !isUnhandled(reaction.promise)) return false;\n  } return true;\n};\nvar onHandleUnhandled = function (promise) {\n  task.call(global, function () {\n    var handler;\n    if (isNode) {\n      process.emit('rejectionHandled', promise);\n    } else if (handler = global.onrejectionhandled) {\n      handler({ promise: promise, reason: promise._v });\n    }\n  });\n};\nvar $reject = function (value) {\n  var promise = this;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if (!promise._a) promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function (value) {\n  var promise = this;\n  var then;\n  if (promise._d) return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n    if (then = isThenable(value)) {\n      microtask(function () {\n        var wrapper = { _w: promise, _d: false }; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch (e) {\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch (e) {\n    $reject.call({ _w: promise, _d: false }, e); // wrap\n  }\n};\n\n// constructor polyfill\nif (!USE_NATIVE) {\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor) {\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch (err) {\n      $reject.call(this, err);\n    }\n  };\n  // eslint-disable-next-line no-unused-vars\n  Internal = function Promise(executor) {\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected) {\n      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if (this._a) this._a.push(reaction);\n      if (this._s) notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function (onRejected) {\n      return this.then(undefined, onRejected);\n    }\n  });\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject = ctx($reject, promise, 1);\n  };\n  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n    return sameConstructor($Promise, C)\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r) {\n    var capability = newPromiseCapability(this);\n    var $$reject = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x) {\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;\n    return promiseResolve(this, x);\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform(function () {\n      var values = [];\n      var index = 0;\n      var remaining = 1;\n      forOf(iterable, false, function (promise) {\n        var $index = index++;\n        var alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapability(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      forOf(iterable, false, function (promise) {\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.e) reject(result.v);\n    return capability.promise;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es6.promise.js\n// module id = 91\n// module chunks = 0","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_an-instance.js\n// module id = 92\n// module chunks = 0","var ctx = require('./_ctx');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar anObject = require('./_an-object');\nvar toLength = require('./_to-length');\nvar getIterFn = require('./core.get-iterator-method');\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_for-of.js\n// module id = 93\n// module chunks = 0","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-call.js\n// module id = 94\n// module chunks = 0","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_is-array-iter.js\n// module id = 95\n// module chunks = 0","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function (fn, args, that) {\n  var un = that === undefined;\n  switch (args.length) {\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return fn.apply(that, args);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_invoke.js\n// module id = 96\n// module chunks = 0","var global = require('./_global');\nvar macrotask = require('./_task').set;\nvar Observer = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar isNode = require('./_cof')(process) == 'process';\n\nmodule.exports = function () {\n  var head, last, notify;\n\n  var flush = function () {\n    var parent, fn;\n    if (isNode && (parent = process.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (e) {\n        if (head) notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // Node.js\n  if (isNode) {\n    notify = function () {\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if (Observer) {\n    var toggle = true;\n    var node = document.createTextNode('');\n    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new\n    notify = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (Promise && Promise.resolve) {\n    var promise = Promise.resolve();\n    notify = function () {\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function () {\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function (fn) {\n    var task = { fn: fn, next: undefined };\n    if (last) last.next = task;\n    if (!head) {\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_microtask.js\n// module id = 97\n// module chunks = 0","var hide = require('./_hide');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) {\n    if (safe && target[key]) target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_redefine-all.js\n// module id = 98\n// module chunks = 0","'use strict';\nvar global = require('./_global');\nvar core = require('./_core');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_set-species.js\n// module id = 99\n// module chunks = 0","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/_iter-detect.js\n// module id = 100\n// module chunks = 0","// https://github.com/tc39/proposal-promise-finally\n'use strict';\nvar $export = require('./_export');\nvar core = require('./_core');\nvar global = require('./_global');\nvar speciesConstructor = require('./_species-constructor');\nvar promiseResolve = require('./_promise-resolve');\n\n$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {\n  var C = speciesConstructor(this, core.Promise || global.Promise);\n  var isFunction = typeof onFinally == 'function';\n  return this.then(\n    isFunction ? function (x) {\n      return promiseResolve(C, onFinally()).then(function () { return x; });\n    } : onFinally,\n    isFunction ? function (e) {\n      return promiseResolve(C, onFinally()).then(function () { throw e; });\n    } : onFinally\n  );\n} });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es7.promise.finally.js\n// module id = 101\n// module chunks = 0","'use strict';\n// https://github.com/tc39/proposal-promise-try\nvar $export = require('./_export');\nvar newPromiseCapability = require('./_new-promise-capability');\nvar perform = require('./_perform');\n\n$export($export.S, 'Promise', { 'try': function (callbackfn) {\n  var promiseCapability = newPromiseCapability.f(this);\n  var result = perform(callbackfn);\n  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n  return promiseCapability.promise;\n} });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/core-js/library/modules/es7.promise.try.js\n// module id = 102\n// module chunks = 0","import loader from './loader'\n\nexport default (Scene_Base) => {\n    let _isReady = Scene_Base.prototype.isReady\n    Scene_Base.prototype.isReady = function () {\n        return _isReady.call(this) && loader.isLoaded()\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/Spine/scene-base.js"],"sourceRoot":""}